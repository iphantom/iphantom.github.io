<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Phantom</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Phantom blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Phantom">
<meta property="og:url" content="chengong.me/index.html">
<meta property="og:site_name" content="Phantom">
<meta property="og:description" content="Phantom blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Phantom">
<meta name="twitter:description" content="Phantom blog">
  
    <link rel="alternative" href="/atom.xml" title="Phantom" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/avatar.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
</head>
<body>
<script src="//cdn.bootcss.com/JQuery-Snowfall/1.7.4/snowfall.jquery.min.js"></script>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Phantom</a></h1>
		</hgroup>

		
		<p class="header-subtitle">是我的海</p>
		
		
		<form><input type="text" class="search" placeholder=" Search..."></form>
				


		
			<div id="switch-btn" class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div id="switch-area" class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives/">所有文章</a></li>
				        
							<li><a href="/tags/">标签云</a></li>
				        
							<li><a href="/about/">留言板</a></li>
				        
							<li><a href="/built/">建站记事</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<ul class="social">
							
								<li id="Email"><a class="Email" target="_blank" href="mailto:admin@chengong.me" title="Email"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/iphantom" title="GitHub"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
								<li id="LinkedIn"><a class="LinkedIn" target="_blank" href="https://cn.linkedin.com/in/gong-chen-805212a5" title="LinkedIn"></a></li>
					        
						</ul>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/Oracle/" style="font-size: 12.5px;">Oracle</a> <a href="/tags/PyDev/" style="font-size: 10px;">PyDev</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/SQL用法/" style="font-size: 10px;">SQL用法</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/duoshuo/" style="font-size: 10px;">duoshuo</a> <a href="/tags/excel/" style="font-size: 10px;">excel</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/hexo用法/" style="font-size: 10px;">hexo用法</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/makedown/" style="font-size: 10px;">makedown</a> <a href="/tags/namecheap/" style="font-size: 10px;">namecheap</a> <a href="/tags/oracle/" style="font-size: 10px;">oracle</a> <a href="/tags/python/" style="font-size: 12.5px;">python</a> <a href="/tags/sublime/" style="font-size: 10px;">sublime</a> <a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a> <a href="/tags/使用指南/" style="font-size: 10px;">使用指南</a> <a href="/tags/华为/" style="font-size: 10px;">华为</a> <a href="/tags/博客/" style="font-size: 12.5px;">博客</a> <a href="/tags/安装方法/" style="font-size: 10px;">安装方法</a> <a href="/tags/小七/" style="font-size: 12.5px;">小七</a> <a href="/tags/心情/" style="font-size: 12.5px;">心情</a> <a href="/tags/感悟/" style="font-size: 17.5px;">感悟</a> <a href="/tags/感言/" style="font-size: 12.5px;">感言</a> <a href="/tags/投资/" style="font-size: 10px;">投资</a> <a href="/tags/教程/" style="font-size: 10px;">教程</a> <a href="/tags/求助/" style="font-size: 10px;">求助</a> <a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a> <a href="/tags/生日/" style="font-size: 10px;">生日</a> <a href="/tags/矩阵/" style="font-size: 10px;">矩阵</a> <a href="/tags/研究生/" style="font-size: 10px;">研究生</a> <a href="/tags/离职/" style="font-size: 10px;">离职</a> <a href="/tags/纪念日/" style="font-size: 10px;">纪念日</a> <a href="/tags/线性代数/" style="font-size: 10px;">线性代数</a> <a href="/tags/结构体/" style="font-size: 12.5px;">结构体</a> <a href="/tags/编程修养/" style="font-size: 15px;">编程修养</a> <a href="/tags/网页/" style="font-size: 10px;">网页</a> <a href="/tags/转载/" style="font-size: 20px;">转载</a> <a href="/tags/链表/" style="font-size: 12.5px;">链表</a> <a href="/tags/问题/" style="font-size: 10px;">问题</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a> <a href="/tags/面向对象/" style="font-size: 15px;">面向对象</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">————对不起，不告诉你————</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Phantom</a></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<a href="/" class="profilepic">
				<img lazy-src="/img/avatar.png" class="js-avatar">
			</a>
			<hgroup>
			  <h1 class="header-author"><a href="/" title="回到主页">Phantom</a></h1>
			</hgroup>
			
			<p class="header-subtitle">是我的海</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives/">所有文章</a></li>
		        
					<li><a href="/tags/">标签云</a></li>
		        
					<li><a href="/about/">留言板</a></li>
		        
					<li><a href="/built/">建站记事</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
						<ul class="social">
							
								<li id="Email"><a class="Email" target="_blank" href="mailto:admin@chengong.me" title="Email"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/iphantom" title="GitHub"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
								<li id="LinkedIn"><a class="LinkedIn" target="_blank" href="https://cn.linkedin.com/in/gong-chen-805212a5" title="LinkedIn"></a></li>
					        
						</ul>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-面向对象葵花宝典2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/12/面向对象葵花宝典2/" class="article-date">
  	<time datetime="2016-05-12T14:22:38.000Z" itemprop="datePublished">2016-05-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/12/面向对象葵花宝典2/">连载：面向对象葵花宝典：思想、技巧与实践(11-20章)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>无意间发现这篇文章，文章讲解由浅入深，读完后感触很深<br>特全文转到自己的博客，方便以后自己随时查看<br>文章转载自爱技术的华仔的博客[<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">http://blog.csdn.net/yunhua_lee</a>]<br>非常感谢<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">爱技术的华仔</a></p>
</blockquote>
<h1 id="第十一章-“封装”-详解"><a href="#第十一章-“封装”-详解" class="headerlink" title="第十一章 “封装” 详解"></a>第十一章 “封装” 详解</h1><p>封装的概念本身很好理解，意思就是把一堆东东装起来。</p>
<p>但要想真正理解封装，这样还远远不够。<br>第一个问题是：我们要封装什么？<br>这个问题很好回答，封装当然是封装不想让别人知道或者看到的东东了。<br>例如：<br>你的身家。。。。。。<br>漂亮MM的年龄。。。。。。<br>富二代的女朋友数。。。。。<br>明星是否整过容。。。。。。<br>你是如何赚到100万的（想想什么样的赚钱方法不想让人知道？）。。。。。。<br>你是如何消磨时间的（想想什么样的消磨时间方法不想让人知道？）。。。。。。<br>等等<br>站在面向对象的角度来说，封装就是“类”的一个功能，你可以封装“类”的属性（比如身家、年龄等），也可以封装“类”的方法（比如说如何赚钱、如何消磨时间），也就是说，面向对象通过“类”来实现了封装。</p>
<p>第二个问题是：我们为什么要封装？<br>封装数据的主要原因是“<strong>保护隐私</strong>”，因为有“隐私”，所以要“封装”。如果没有封装，你的隐私就暴露在所有人面前了，别人也可以控制你的隐私，那样将是非常危险的。</p>
<p>例如面向过程的设计中，数据结构是公开的，任何能够获取到数据的人都可以随意修改，也可以使用不同的方式修改，如果某个不小心的程序员或者菜鸟或者一个准备离职又心怀不满的开发人员，无意或有意改错了，那么其它依赖这个数据的函数都会受到影响，要么导致业务出错，甚至导致程序崩溃。</p>
<p>而面向对象的类封装了属性后，对属性的修改只能通过类的方法进行，一来不会暴露内部的具体属性，二来对属性的操作都是统一的，不会出现乱改的情况。</p>
<p>封装方法的主要原因是“<strong>隔离复杂度</strong>”。每个类只需要关注自己的负责的功能如何完成即可，如果需要其它类配合，只需要调用类的方法即可，而不需要了解其它类功能的具体的实现。</p>
<p>“隔离复杂度”的例子即使在现实世界中也比比皆是。例如我们夏天常用的空调能够提供制冷功能，我们只要轻轻一按遥控器的按钮，空调就能够开始制冷，但空调究竟是如何制冷的，绝大部分人并不知道，也并不关心。空调封装了制冷的实现过程，对人提供了一个制冷的按钮，人通过这个按钮来启动制冷的过程。</p>
<p>【封装的样例】<br>简单的这么回答你可能没有什么感觉，但给一个面向对象“封装”和面向过程“无封装”的例子，相信你就很清楚了。<br> 举个简单的例子，假设用程序实现付款这个操作，我们来看面向对象和面向过程的方式。</p>
<p>面向过程 = <a href="http://lib.csdn.net/base/31" target="_blank" rel="external">算法</a> + 数据结构<br>这里的数据结构是公开的，每个地方都可以看到和引用的，而且必须知道，否则面向过程的各个处理流程就没法处理了。<br>具体代码实现如下：<br>person.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PERSON_H_  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERSON_H_  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Person&#123;  </span><br><span class="line">    <span class="keyword">char</span>* name;  <span class="comment">//姓名  </span></span><br><span class="line">    <span class="keyword">int</span> money;   <span class="comment">//金钱数量  </span></span><br><span class="line">&#125;Person;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* PERSON_H_ */</span></span></span><br></pre></td></tr></table></figure></p>
<p>money.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"person.h"</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> null 0x00  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    Person* me = (Person*)<span class="built_in">malloc</span>(sizeof(Person));  </span><br><span class="line">    me-&gt;name = <span class="string">"华仔"</span>;  </span><br><span class="line">    me-&gt;money = <span class="number">100</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//收银员收银  </span></span><br><span class="line">    <span class="keyword">if</span>( me-&gt;money &gt; <span class="number">50</span> )&#123;  </span><br><span class="line">        me-&gt;money -= <span class="number">50</span>;   <span class="comment">//收银操作时，需要知道Person实际有多少钱，然后直接操作Person的money  </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s 付款成功，共  %d 块\n"</span>, me-&gt;name, me-&gt;money);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s 付款失败 \n"</span>, me-&gt;name);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//小偷偷钱  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"偷了 %s %d 块\n"</span>, me-&gt;name, me-&gt;money);  </span><br><span class="line">    me-&gt;money = <span class="number">0</span>;   <span class="comment">//小偷也可以直接知道Person有多少钱，并直接操作Person的money  </span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">free</span>(me);  </span><br><span class="line">    me = null;  </span><br><span class="line">    return EXIT_SUCCESS;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，你有多少钱，所有人都知道！<br>也就是说，你的钱，别人可以随便控制！<br>就像你去超市买东西，付款的时候，收银员说：把你所有的钱摆在台子上，我从里面拿50.<br>不用我说你也知道，这当然是一件很恐怖的事情！</p>
<p>面向对象 = 对象 + 交互<br>但在面向对象的实现里面就不会这样了，你不需要把钱摆出来，你只需要拿出50就可以了，你既不需要担心别人知道你有多少钱（然后实施某种后续动作），也不需要担心别人拿错了（不管是有意的还是无意的）。</p>
<p>具体实现代码如下：<br>Person.Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.oo.java;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 普通人 </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String _name;    <span class="comment">//姓名  </span></span><br><span class="line">    <span class="keyword">private</span> Integer _money;  <span class="comment">//金钱  </span></span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> _name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">pay</span><span class="params">(Integer money)</span></span>&#123;  </span><br><span class="line">        <span class="comment">//付款的逻辑由Person自己控制，例如判断当前的钱是否够支付  </span></span><br><span class="line">        <span class="keyword">if</span>( money &gt; _money )&#123;  </span><br><span class="line">              </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        _money -= money;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Cashier.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oo.java;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 收银员 </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cashier</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">get</span><span class="params">(Person person, Integer money)</span></span>&#123;  </span><br><span class="line">        Boolean result = person.pay(money);  <span class="comment">//收银员只需要调用Person的pay方法，无需知道Person当前有多少钱  </span></span><br><span class="line">        <span class="keyword">if</span>( result )&#123;  </span><br><span class="line">            System.out.println(person.getName() + <span class="string">" 付款成功，共  "</span> + money +<span class="string">" 块"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>&#123;  </span><br><span class="line">            System.out.println(person.getName() + <span class="string">" 付款失败"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Thief.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oo.java;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 小偷 </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thief</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">stole</span><span class="params">(Person person)</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//小偷想直接访问Person的money，但这样做不允许，编译出错  </span></span><br><span class="line">        System.out.println(<span class="string">"偷了 "</span> + person.getName() +<span class="string">" "</span> + person._money + <span class="string">" 块\n"</span>);  </span><br><span class="line">        person._money = <span class="number">0</span>;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//虽然小偷这个类语法上也可以直接调用Person的pay方法，  </span></span><br><span class="line">        <span class="comment">//但Person的pay方法里面可以做很多的校验功能来让这样的调用返回失败  </span></span><br><span class="line">        person.pay(<span class="number">50</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="第十二章-“继承”-详解"><a href="#第十二章-“继承”-详解" class="headerlink" title="第十二章 “继承” 详解"></a>第十二章 “继承” 详解</h1><p>继承 = 遗传<br>继承是面向对象最基本的特征，如果一个语言没有继承机制，就谈不上真正的面向对象的语言。</p>
<p>继承本身很好理解，和我们日常生活中的“继承”概念基本一样：子承父业！所以，你可以看到面向对象的编程语言里面，有了“父类”、“子类”的概念。</p>
<p>但是我个人认为“继承”这个说法并不确切，一般我们理解“继承”，都是理解为继承产业、继承财产，例如李泽钜继承李嘉诚的事业。但在面向对象的领域里面，并不是“子类”继承了“父类”的产业，而是继承了“父类”的特点，具体来说就是继承了“属性和方法”。</p>
<p>所以我认为“继承”更加贴切的说法是类似生物学上的“遗传”，按照中国话的说法就是“龙生龙，凤生凤，老鼠生来会打洞”，面向对象的继承意味“子类”遗传了了某些“父类”的属性和方法。</p>
<p>但就像生物学上的进化论一样，有遗传就有变异，正因为有了变异，才会有新的物种产生；有了变异，面向对象才有子类的出现。</p>
<p>当然，面向对象的进化不是“自然选择”的结果，而是你——伟大的程序猿——选择的结果。<br>除了可以选择子类如何变异外，你——伟大的程序猿——还可以控制另外一个遗传因素：你可以决定父类遗传什么给子类！</p>
<p>也就是说，你可以控制父类将哪些“基因”遗传下去，你也可以控制子类如何变异出哪些新基因。<br>所以，你——伟大的程序猿——就是面向对象世界的“上帝”！</p>
<p> 继承 vs 抽象？<br>我们来看看一个继承的实例：<br> <img src="http://upload-images.jianshu.io/upload_images/1985459-383ae6fb29327e10?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如果你还记得前面看过的“抽象”一章的内容，你一定会感到很惊讶：<br>抽象和继承的图完全相反，那这两个东东到底有什么区别和联系呢？</p>
<p>抽象：是分析和设计过程中的一个动作，一个技巧，通过抽象得出类<br>继承：是实现过程中的一个动作，基于抽象结果，通过编程语言的特性，完成抽象图的模拟。</p>
<p>因此，抽象和继承是前后衔接的关系，先有抽象，通过抽象得出类，后通过继承来表达抽象结果</p>
<h1 id="第十三章-“多态”-详解"><a href="#第十三章-“多态”-详解" class="headerlink" title="第十三章 “多态” 详解"></a>第十三章 “多态” 详解</h1><p>在此要向将polymorphism翻译成“多态”的人致敬！<br>因为多态的英文实在是太难理解了，而中文翻译得又如此形象如此贴切。</p>
<p>从字面意思上就可以看出，多态就是“多种形态”的意思。但仔细探究一下：“多种形态”其实还是没法很好的理解，不同的人也还是会有不同的理解。</p>
<p>动画片看得多的同学可能会以为：多种形态，就是很多种变身啦 ：），就像孙悟空72变一样，一会儿可以变成房子，一会儿可以变成牛魔王。。。。。。</p>
<p>擅长盛装打扮的美女可能会以为：多种形态，其实就是换不同的衣服嘛，你看我一会文艺小清新打扮，一会儿高贵典雅的贵妇人装束，一会儿小鸟依人的淑女形象。。。。。。</p>
<p>学院派技术宅男可能会以为：多种形态，其实就是多种状态啦，比如说TCP协议栈有XX种状态，线程有XX种状态。。。。。。</p>
<p>还可能有很多其它各种各样的理解，但在面向对象领域，这些理解都不正确，多态不是变身、不是换装、不是状态变化，而是“多胎”！！</p>
<p>你可能会很惊讶，以为这里是打字打错了，怎么可能是“多胎”呢？“多胎”又是什么意思呢？</p>
<p>多胎在这里也是一个形象的说法，在面向对象领域，多态的真正含义是：使用指向父类的指针或者引用，能够调用子类的对象。</p>
<p>我们以Java程序为例：<br>Animal.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oo.base.polymorphism;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 这是父类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">talk</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">Dog.java</span><br></pre></td></tr></table></figure></p>
<p>package com.oo.base.polymorphism;  </p>
<p>/** </p>
<ul>
<li>子类：狗 </li>
<li><p>*/<br>public class Dog extends Animal {  </p>
<p> public Dog() {  </p>
<p> }  </p>
<p> @Override<br> String talk() {  </p>
<pre><code>return &quot;Dog......wang wang&quot;;  
</code></pre><p> }  </p>
</li>
</ul>
<p>}<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Pig.java</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">package</span> com.oo.base.polymorphism;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 子类：猪 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pig</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pig</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function">String <span class="title">talk</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Pig......ao ao"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Cat.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oo.base.polymorphism;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 子类：猫 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function">String <span class="title">talk</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cat......miao miao"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oo.base.polymorphism;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     *  </span><br><span class="line">     * <span class="doctag">@param</span> a Animal  这个参数就是“多态”的具体表现形式 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Animal a)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//在调用a.talk()的时候, 函数并不知道a究竟是Pig，Dog，还是Cat，只知道是一个Animal  </span></span><br><span class="line">        System.out.println(a.talk());   </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//在调用write函数的时候，可以传入Cat/Dog/Pig对象，并且输出也不一样  </span></span><br><span class="line">        write(<span class="keyword">new</span> Cat()); <span class="comment">//传入Cat，输出"Cat......miao miao"  </span></span><br><span class="line">        write(<span class="keyword">new</span> Dog()); <span class="comment">//传入Dog，输出"Dog......wang wang"  </span></span><br><span class="line">        write(<span class="keyword">new</span> Pig()); <span class="comment">//传入Pig，输出"Pig......ao ao"  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的样例可以看出，Pig、Dog、Cat是三个Animal的子类，在函数调用的时候，参数类型指定为Animal，但具体传入的参数值可以是Animal的子类Pig、Dog、Cat，也就是说：指定为Animal类型的参数，可以为Pig，也可以为Dog，也可以为Cat，总共有3中不同的形态。</p>
<p>多态的特性在面向对象编程的领域中具有十分重要的作用。多态屏蔽了子类对象的差异，使得调用者可以写出通用性的代码，而无需针对每个子类都需要写不同的代码。<br>例如，如上的样例，如果没有多态，Test的write函数就必须这么写了：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.oo.<span class="keyword">base</span>.polymorphism;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 不支持多态的Test实现 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test2</span> &#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 如果不支持多态，每个write函数都需要和具体的子类对应， </span><br><span class="line">     * writeCat对应Cat子类 </span><br><span class="line">     * @param a </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeCat</span>(<span class="params">Cat a</span>) </span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(a.talk());   </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 如果不支持多态，每个write函数都需要和具体的子类对应， </span><br><span class="line">     * writeDog对应Dog子类 </span><br><span class="line">     * @param a </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeDog</span>(<span class="params">Dog a</span>) </span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(a.talk());   </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 如果不支持多态，每个write函数都需要和具体的子类对应， </span><br><span class="line">     * writePig对应Pig子类 </span><br><span class="line">     * @param a </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writePig</span>(<span class="params">Pig a</span>) </span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(a.talk());   </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//需要针对每个子类调用不同的函数  </span></span><br><span class="line">        writeCat(<span class="keyword">new</span> Cat()); <span class="comment">//传入Cat，输出"Cat......miao miao"  </span></span><br><span class="line">        writeDog(<span class="keyword">new</span> Dog()); <span class="comment">//传入Dog，输出"Dog......wang wang"  </span></span><br><span class="line">        writePig(<span class="keyword">new</span> Pig()); <span class="comment">//传入Pig，输出"Pig......ao ao"  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码与Test1的代码对比，很明显Test1的要清晰和简洁很多，要少写很多代码。</p>
<p>除了能够让代码清晰简洁外，多态还有一个更加重要的作用：<br><strong>当增加新的子类时，调用者的代码无需变动就能适用新的子类</strong>。<br>以Test1为例，假设我们增加一个Cock的Animal子类，Test1的代码无需任何改变就可以支持Cock类，而Test2则需要增加一个writeCock的函数。</p>
<h1 id="第十四章-面向对象开发技术流程"><a href="#第十四章-面向对象开发技术流程" class="headerlink" title="第十四章  面向对象开发技术流程"></a>第十四章  面向对象开发技术流程</h1><p>抛开项目流程，让我们来谈谈“技术流程”吧！！</p>
<p>谈到流程，很多人立刻就会想到熟悉的瀑布模型、螺旋模型、迭代开发、敏捷、RUP等一堆软件工程相关的软件开发流程，但对于大部分人来说，这些流程仅仅是项目管理上的概念，只有项目经理开例会时那红红绿绿的甘特图、燃尽图、路径图等，或者只有评估工作量和是否要加班的时候，我们才会意识到这些流程的存在。</p>
<p>通俗的讲，项目管理上的流程主要是用于指导项目经理如何管理项目用的，但对于如何指导开发人员如何开发项目，并无多大用处。一个典型的情况就是刚毕业的大学生，软件工程掌握的很熟悉，各个开发阶段应该做什么，瀑布流程有什么优缺点等，谈起来都头头是道，但真的参加开发项目后，就会发现有一种无从下手的感觉。例如：<br>Ø 需求分析阶段要分析需求，但具体怎么分析呢？<br>Ø 客户的需求是描述性的，例如“我们需要一个POS机”，而代码是一个一个具体的类和函数，那么如何从描述性的语言最后转化到具体的类和函数呢？<br>Ø 具体语言的特性，例如Java和C++的private、protected、public这些属性是从哪里来的？什么时候设计的？<br>Ø 面向对象的类、接口等，是怎么设计出来的 ？</p>
<p>相信这些问题都曾经困扰过很多人，但软件工程并没有给出这些问题的答案，因此也就导致了很多开发人员在实际开发过程中，要么只能在别人的指导下工作，要么就瞎蒙乱撞、拼凑堆砌，反正最后也能够实现需求，至于效果嘛，那就要看运气了。少数几个领悟力强的人，经过一段时间的磨练后，也许就慢慢掌握了门道，但大部分人可能就一直原地踏步，不断的在重复别人分配给自己的工作。</p>
<p>其实，就像项目管理上有一套完整的流程一样，<strong>项目开发也有一套完整的过程</strong>，尤其对于面向对象来说，整个开发流程其实是非常清晰的，只是很少有人将这部分归纳总结提炼出一套用于指导开发人员进行开发的流程。</p>
<p>为了区别起见，我们将瀑布模型、敏捷开发等称为“管理流程”，而将面向对象开发流程称为<strong>“技术流程”</strong>。面向对象的技术流程可以概括如下：<br>需求模型 -&gt; 领域模型 -&gt; 设计模型 -&gt; 实现模型</p>
<p>l 需求模型<br>通过和客户沟通，结合行业经验和知识，明确要求客户的需求。</p>
<p>l 领域模型<br>基于需求模型，提炼出领域相关的概念，为后面的面向对象设计打下基础。</p>
<p>l 设计模型<br>以领域模型为基础，综合面向对象的各种设计技巧，完成类的设计。</p>
<p>l 实现模型<br>以设计模型为基础，将设计模型翻译为具体的语言实现，完成编码。</p>
<p>以上流程环环相扣，上一步流程的输出就是下一步流程的输入。后面我们可以看到，通过这种一步一个脚印的方式，即使是经验并不丰富的菜鸟，也能完成从需求到最后实现的相关工作，而不再需要仰望和崇拜其他大虾大牛，或者自己摸着石头过河了！</p>
<h1 id="第十五章-需求详解"><a href="#第十五章-需求详解" class="headerlink" title="第十五章 需求详解"></a>第十五章 需求详解</h1><p>很多人像老黄牛一样辛辛苦苦做了很多年软件开发，但却连“需求”到底是什么都不清楚。当然，没有人自己会承认这点！</p>
<p><strong>【需求到底是什么】</strong><br>凡事都有一个开头，软件项目也不例外，对于软件项目来说，需求就是项目最开始的一个输入。</p>
<p>参考维基百科，需求定义如下：</p>
<blockquote>
<p>In systems engineering, a requirement can be a description of what a system must do, referred to as a Functional Requirement.</p>
</blockquote>
<p>简单翻译一下就是：需求即系统需要做什么。</p>
<p>但正是这个简单的定义，让很多人陷入了<strong>陷阱</strong>：需求即功能。<br>单纯从字面意思来理解这样也是没有问题的：系统需要做什么，当然就是系统要提供什么功能了！</p>
<p>我们来看一个简单的例子：ATM自动取款机。<br>有的人说，ATM的功能是取款、存款、查询余额，所以针对ATM的需求应该是：取款、存款、查询余额；<br>有的人说，ATM的功能有很多：识别卡、密码认证、点钞、验钞、查询余额、跨行取款等，所以针对ATM的需求应该是：识别卡、密码认证、点钞、验钞、查询余额、跨行取款。</p>
<p>如果你是ATM购买商，你认为哪种才是你的需求？<br>如果你是ATM制造者，你认为哪种才是你的需求？<br>如果你是ATM使用者，你认为哪种才是你的需求？</p>
<p>可能大部分人都会支持第二种，原因很简单：取款也要密码认证、存款也要密码认证，所以密码认证是一个需求，而不是分到两个需求里面。<br>而且第二种方式划分需求有一个好处：系统最后提供的功能和需求基本上是一一对应的。</p>
<p>看起来很美妙，但其实我们忽略了一个问题：采用第二种方式的主要原因是我们对ATM机很熟悉了！</p>
<p>但如果换一个身份，比如说你是一个只识字的农民工，你对ATM机的要求会是“识别卡、密码认证。。。。。。”这样专业的需求么？<br>肯定不会，你的需求应该是“取款”、“存款”、“查询余额”。</p>
<p>我们继续打破砂锅问到底：为什么农民工兄弟的需求肯定是“取款”、“存款”、“查询余额”，而不是“识别卡”、“密码认证”、“点钞”。。。。。。？</p>
<p>我们假设一下，假如农民工兄弟对ATM的需求是“点钞”，那么就会出现这样滑稽的场景：他经常拿着卡去ATM机，让ATM机点一下钞；又或者他的需求是“密码认证”，那么他经常拿着卡去ATM机验证一下密码。</p>
<p>你当然不会看到这样的场景，农民工兄弟也不会有这样的需求，他只管能取到钱即可，因为取到钱他就可以拿钱去花了，至于取钱的过程中管你是密码认证、点钞还是验钞，说的搞笑一点：他更希望把卡插进去，钱就自动吐出来而且不受限额。</p>
<p>相信到这里，你已经能够明白需求和功能的差别了，我们总结一下：<br>需求：对客户来说有价值的事情；<br>功能：系统为了实现客户价值而提供的能力；</p>
<p>因此，区别是需求还是功能的方法很简单了：只要判断是否对客户有价值。<br>我们可以举更多例子来证明这个方法：<br>POS机：“买单”是需求，“商品扫描”、“金额汇总”、“收银”等是功能，因为买完单后顾客就能将产品拿走；<br>汽车：“驾驶”是需求，“发动机”、“刹车”、“加速”等是功能；<br>打印机：“打印”是需求，“进纸”、“设定”、“与电脑连接”等是功能；<br>。。。。。。<br>（有兴趣的朋友可以自己多想想）</p>
<p>【需求非常重要】<br>俗话说，万事开头难，需求是软件项目的最开始输入，肯定是非常重要的，按道理来说也应该是需要重点关注的。</p>
<p>然而现实情况却恰恰相反：很多项目都不怎么重视需求！</p>
<p>你可以经常看到这样的场景：<br>需求分析人员和客户沟通了一下，然后把客户的要求简单整理了一下就交给研发了。。。。。。<br>项目计划比较紧，那么就把需求分析阶段加快一些吧（实际上就是减少投入时间）。。。。。。<br>产品给了一个简单的需求，为了能够快速交付，没有怎么分析就开始设计编码了。。。。。。</p>
<p>虽然看起来时间是节省了，项目是加快了，然而最终的结果却令人失望：据统计，有将近1/3的项目失败或者陷入困境时因为需求原因导致的！</p>
<p>这个就是所谓的“垃圾进垃圾出（Garbage in, garbage out）”的效果，即：<br>如果最开始的输入是错误的，后面的过程再怎么优秀，最终都会输出垃圾产品。而且可能是后面越优秀，最终输出越垃圾，就像你朝一个错误的方向跑步，跑得越快离正确的终点越远一样。</p>
<p>举一个虽然恶心但很形象的例子：给你一坨屎，你放到饼干生产线上，最后生产出来的不是饼干，而是像饼干的一坨屎！：）</p>
<p>你可能会说，错了我改还不行么？<br>当然是可以的，但你要做好心理准备，还有一个更加令人抓狂的事实：修复需求错误的问题的成本非常高昂！</p>
<p>我们假设编码阶段发现和修复一个错误所耗费的人力是1个单位，那么在测试阶段修复需求错误的成本是5~10倍，在维护阶段（产品正式应用后），修复需求错误的成本是20倍，而如果在需求阶段修复需求错误，成本只需要0.1~0.2即可。</p>
<p>也就是说，需求错误的成本存在这样的比例关系：维护阶段修复 = 需求阶段修复 * 200 ！<br>原因显而易见：如果你的需求错了，那么你几乎是要把软件项目重做一遍！</p>
<p>相信经过前面的分析，你对于需求的重要性已经有了充分的认识了。<br>请时刻牢记：需求很重要！</p>
<h1 id="第十六章-需求分析终极目的"><a href="#第十六章-需求分析终极目的" class="headerlink" title="第十六章 需求分析终极目的"></a>第十六章 需求分析终极目的</h1><p><strong>需求分析有三种级别，你自认为属于哪一级呢 ？   —写在前面</strong></p>
<hr>
<p>============================华丽丽的分割线=============================</p>
<p><strong>需求分析的目的是什么？</strong></p>
<p>你可能会毫不犹豫的回答：需求分析的目的当然是了解客户需要什么！</p>
<p>这个回答看起来是毫无疑问的，我们当然要了解客户需要什么，我们才能给他们做出他们想要的。<br>但只做到这样就可以了么？</p>
<p>我们来看一个简单的需求，客户找到你说：“我要一只羊！”<br>这个需求够简单吧？那你是不是毫不犹豫的就抓一只羊给客户呢？</p>
<p>如果你这样做了，如果你运气好，客户可能非常满意，但大部分情况，也许客户很不满意，为什么？<br>我们来看“我要一只羊”这个需求的多个版本：<br>图一：<br>一个饥肠辘辘的人说，我要一只羊，用来烤着吃！<br>（来源于网络： <a href="http://soufun.com/Album/PictureDetail_40800605_200_127935903.htm" target="_blank" rel="external">http://soufun.com/Album/PictureDetail_40800605_200_127935903.htm</a> ）<br><img src="http://upload-images.jianshu.io/upload_images/1985459-c6661e6c2ee64bc4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>图二：<br>一个慈爱的父亲说，我要一只羊，给我小孩做宠物！<br>（来源于网络： <a href="http://ww4.sinaimg.cn/mw600/763f9322jw1duqu3vsy6wj.jpg" target="_blank" rel="external">http://ww4.sinaimg.cn/mw600/763f9322jw1duqu3vsy6wj.jpg</a> ）<br><img src="http://upload-images.jianshu.io/upload_images/1985459-0446205833b3ef35?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>图三：<br>一个农场主说，我要一只羊，生小羊！<br>（来源于网络： <a href="http://cs.cq.gov.cn/upfiles/2009-3/20093293042143.jpg" target="_blank" rel="external">http://cs.cq.gov.cn/upfiles/2009-3/20093293042143.jpg</a> ）<br><img src="http://upload-images.jianshu.io/upload_images/1985459-f202bb2bbeb85e1d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>看了上面这几幅图，相信你就大概明白了：客户会告诉我们他们的需求，但大部分情况都不会告诉你需求背后的问题。而需求分析的终极目的，就是要“<strong>挖掘客户的问题，实现客户价值</strong>”！</p>
<p>因为只有你提供的东西，最后能够解决客户的问题，客户才会满意。如果你提供的东西，没有解决客户的问题，就算你是一五一十的按照客户提的来做的，客户还是不会满意，客户不满意，你的BOSS就会不满意，你的BOSS不满意，你的上司就会不满意。。。。。。最后，损失最大的还是你！</p>
<p>但我们为什么费心费力的要去挖掘客户的问题呢？客户难道不会直接告诉我们么？<br>客户当然不会告诉你“我饿了”，因为这是他的问题，不是他的需求，他告诉你“我要一只羊”，这才是需求，只是这个需求是解决他的问题的。</p>
<p>但既然这样，我们为什么要管他的问题，直接满足他的需求不就得了？<br>这又涉及另外一个问题，大部分的客户都会基于自己的经验、知识、阅历等，自己设计一个解决方案，然后作为需求向你提出来。如果你碰上懂行的客户，那自然要谢天谢地了；<br>但是绝大部分情况你碰到的客户可能就是每天坐在办公室，一张报纸一杯茶，上上网打打牌，然后接到某个领导的“信息化”任务，然后就给你提了一个需求！</p>
<p>除此之外，深入了解客户的问题，有助于你更好的实现需求。就举前面的“我要一只羊”的例子，<br>如果客户是用来吃的，也许你更应该提供一顿烤羊肉，或者一只大羊腿，客户会更加满意；<br>如果客户是用来给他小孩做宠物的，那么给一只雪白的漂亮的小羊羔也许他的小孩更高兴；<br>如果客户是用来生小羊的，那么给一只强壮的成年母羊是更好的选择。</p>
<p>一般来说，需求分析有三重境界，分为“记录员”、“分析员”、“引导员”三个级别，我们以上面提到的“我要一只羊”的需求来作为样例：<br><strong>1） 第一重：记录员，记录客户的需求；</strong><br>需求分析人员记录下了如下需求：XX客户需要一只羊，品种：绵羊，颜色：白色，重量：20Kg。<br>点评：只是简单记录了客户的需求，没有明白客户的问题，如果真的提供了一只羊，肚子饿的客户可能会再次提出要将羊烤好（或者做羊肉汤）。</p>
<p><strong>2） 第二重：分析员，和客户一起分析问题，完善需求；</strong><br>需求分析人员记录下了如下需求：XX客户肚子饿了，需要一只羊烤着吃，由于客户并不会自己烤羊，因此我们需要提供一只烤好的羊。<br>点评：发现了客户的问题，需求调整为“烤好的羊”，这个已经能够解决客户的问题了，但还不够完美。</p>
<p><strong>3） 第三重：引导员，能够引导客户的需求；</strong><br>需求分析人员记录了如下需求：XX客户肚子饿了，需要一只羊烤着吃，但目前是夏天，烤羊火气太重，经过与客户沟通，客户更愿意吃一顿冰镇啤酒海鲜大餐。<br>点评：发现了客户的问题，并且引导客户将需求调整为更合理的需求。</p>
<p>我们可以看到，<strong>要想做好需求分析，要时刻抓住“客户的问题和价值”这个指导思想</strong>！</p>
<p>===============2015.02.17补充========================<br>网上看到一个更加生动和更加深入解读的文章，大家可以参考：<a href="http://www.yixieshi.com/ucd/20359.html" target="_blank" rel="external">用户都是骗子</a></p>
<h1 id="第十七章-需求分析518方法"><a href="#第十七章-需求分析518方法" class="headerlink" title="第十七章 需求分析518方法"></a>第十七章 需求分析518方法</h1><p>对于大部分人来说，可能并没有机会进行需求分析，因为在大部分的公司里面，需求分析都是有很多工作经验的资深人员，或者是对系统很熟悉的老的开发人员。</p>
<p>所以，很多人都会对需求分析有一种景仰的心态，认为既然做需求的人要求这么高，那么需求分析一定很复杂、很难、很高级了。而且很多需求分析人员动不动就会教训“你要站在客户的角度”、“你要全面的分析”等，然后再抛出几个需求建模之类的玩意吓吓你。。。。。。</p>
<p>但其实做需求分析一点都不高深，只要掌握正确的方法，大部分人都能够做需求分析，而且可以做的很好！</p>
<p>而且这个正确的方法掌握起来很简单，不需要你另外再去买一本书刻苦阅读，也不需要你花费大量的时间去实践，去探索。</p>
<p>下面我们就来看，这个简单的正确方法究竟是什么。</p>
<p>我总结起来就是“<strong>需求分析518方法</strong>”,简称“我要发”，具体来说就是5W1H8C！！<br>5：5W，即When、Where、Who、What、Why<br>1：1H，即How<br>8：8C，即8个Constraint，包括性能Performance、成本Cost、时间Time、可靠性Reliability、安全性Security、合规性Compliance、技术性Technology、兼容性Compatibility</p>
<p>下面我们来详细分析这几个点。<br>【5W】<br>5W：5W作为一组，首先是它们都以W开头，但这不是最关键，最关键的在于这些是一个需求产生的环境，或者说上下文（英文Context）。<br>为什么我们要关注需求产生的环境？很简单：环境影响需求。</p>
<p>举个很简单的例子：同样是垃圾桶，放在巴西贫民窟的要求和放在纽约帝国大厦肯定不一样。贫民窟可能有很多顽皮的小孩，将垃圾桶作为玩具，或者作为足球的射门目标；而帝国大厦都是文质彬彬的白领金领，对美学可能有特别的要求；因此，两个不同地方的垃圾桶，需求是完全不一样的。</p>
<p>有人会说，客户难道不是最明白他们需求的环境么？为什么他们不直接告诉我们？</p>
<p>前面我们提到，客户往往基于自己的经验、理解、学识等，给出一个解决方案，然后他们跟你说这是他们的需求。理想的情况，当然是客户非常在行，最好就是软件分析师出身的；但现实却往往不妙，很多客户对软件的理解可能仅仅停留在Windows甚至QQ上，甚至有客户会认为你会变魔法，只要他说一个简单需求，你就能变出他想要的！</p>
<p>客户当然不会是软件分析师，我们也不是魔法师，因此，我们必须亲自出马，弄清需求产生的环境。</p>
<p>==When==<br>这是和时间相关的环境信息，常见的时间信息有：<br>1） 季节信息：春夏秋冬等<br>2） 日期信息：节日、假日等<br>3） 作息事件：白天、晚上、凌晨、早晨、上午、下午、晚上、深夜等</p>
<p>一个简单的例子：我在以前公司做通讯设备的时候，如果是做数据倒换工具，都要求非常智能，最好是一键式操作？为什么呢，因为数据倒换都是在晚上凌晨2~4点进行，此时操作人员最困，思维最迟钝，如果你做的数据倒换工具需要操作七七四十九大步，九九八十一小步，而只要一步出错就全部重来，那么谁敢去操作？</p>
<p>==Where==<br>这个事和地点相关的环境信息，常见的地点信息有：<br>1） 国家、地区：不同的国家和地区有不同的文化、风俗、制度等；<br>2） 室内、室外、街道；<br>3） 建筑物</p>
<p>一个简单的例子：一个垃圾桶，放在室内就可能要求美观小巧（不占地方）；而放在室外就可能要求防晒、防雨、防风、防疯子，而且要求比较大。</p>
<p>==Who==<br>这是和参与者相关的，注意我这里用的是“参与者”来描述的，而不是说“人”，为什么呢？<br>因为很多外部参与者不一定是“人”，例如外系统、动物等都可以算作Who里面的。<br>常见的参与者信息有：<br>1） 投资者、管理者<br>2） 使用者、维护者<br>3） 监督者、评估者：例如政府机构、监管机构等<br>4） 其它系统</p>
<p>一个简单例子，银行的ATM机，参与者有如下几类：<br>顾客：使用ATM机器取款、存款；<br>银行维护人员：每天将钱放进ATM机器；<br>质检机构：根据XX法律对ATM机进行检查；</p>
<p>==What==<br>这个就是客户最终想要的输出。例如一个文档、一份报告、一个图片、一个系统等。<br>一般情况下，这也是我们看到的最原始的需求。</p>
<p>==Why==<br>这个就是客户遇到的问题、困难、阻碍等，也是客户提出需求的驱动力。<br>只要是客户觉得不爽的地方都是Why的范围。</p>
<p>【一个长颈鹿的实例：5W】<br>有一个建筑公司的需求分析人员收到了一个客户需求“给我建一栋很大的房子”，于是建筑公司就建了房子，房子是欧式风格，又大又宽敞，全套宜家家居，全木地板，进口电器。。。。。简直是应有尽有，结果客户来收房子的时候说了一句话，让建筑公司吐血，你知道是什么话么？<br>客户说：“先生们，我是要一栋房子给我们的长颈鹿住！”</p>
<p>因此即使是简单的一句话需求，我们也需要详细分析。例如：<br>Who：这套房子的购买者是动物园、管理者是动物园的饲养员、使用者是长颈鹿、评估者可能是动物管理协会、卫生局等政府部门”<br>When：这个可能要求一年四季了，如果长颈鹿知识运来展览一下，那么就是展览的这几个月。”<br>Where：这个房子要建在动物园，而不是其它居民小区，那么动物园肯定有一些相关的规定”<br>What：要求一套房子，但不是简单意义上的房子，而是长颈鹿住的房子，这就需要考虑高度、围栏等”<br>Why： 这个就可能动物园要临时展览，也可能要引进长颈鹿，也有可能是原来的长颈鹿房子破旧了”</p>
<p>虽然我们前面讲的时候，5W都是一视同仁的，但实际上有一个W是非常关键的，如果这个W错了，那么即使其它4W全部正确，也可能导致最后没有满足客户需求，客户不满意。</p>
<p>这个最关键的W就是Why，因为只有真正了解了客户的需求驱动力，才能解决客户的问题，而只有解决了客户的问题，那么客户才会真正的满意。这也是我们前面提到的需求分析的终极目的是“挖掘客户的问题，实现客户价值”！</p>
<p>如下图形象的描绘了5W的关系：<br> <img src="http://upload-images.jianshu.io/upload_images/1985459-2bb0e9b2bd24e070?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>【1H】<br>H代表How，但具体是指什么How呢？</p>
<p>很多人常犯的一个错误是在需求分析阶段分析了需求如何实现，这样做是不正确的。需求分析阶段的How不是指如何实现需求，而是指需求本身的流程，如何实现需求那是设计阶段的事情！</p>
<p>你可能会有疑问：“需求本身还有什么流程”？</p>
<p>需求又简单和复杂之分，有的需求可能很简单，客户想要的东西也很明确；但有的需求比较复杂，涉及到多次交互，或者多个状态变化等，这种情况就要把需求的流程描述清楚。<br>举个例子吧，取款是一个需求，但取款本身包含多次交互，要插卡、输入密码、输入金额、打印账单、取钱这些步骤，How就是用来描述这整个流程是如何运行的。</p>
<p>说起来How很简单，但实际上这是需求分析工作量最大的一部分，How分析的结果是需求分析的主要输出，而且How分析的质量直接影响最后需求实现的质量。</p>
<p>在前面进行5W分析的时候，我们没有什么具体的指导方法，分析时主要靠分析人员的经验、水平，而How则不一样，进行How分析时有一套成熟的方法，这就是“用例方法”！我们将在后续章节详细介绍用例方法。</p>
<p>【8C】<br>8C指的是8个约束和限制（Constraintes），具体如下：<br>| 性能Performance<br>性能是指系统提供相应服务的效率。一般而言，性能主要包括响应时间、吞吐量。<br>性能是很多系统<a href="http://lib.csdn.net/base/16" target="_blank" rel="external">架构</a>设计的关键约束条件之一。例如，同样一个Web网站，虽然都是提供信息给用户流浪，但一个日访问量1万的网站，和日访问量10亿的网站，两者的设计是完全不一样的。</p>
<p>l 成本Cost<br>成本指为了实现系统而需要付出的代价。<br>成本也是很多系统架构设计的关键约束之一。例如，客户只愿意出100万来买这个系统，最后我们却设计了一个耗费1000万的系统，要么客户不愿买，要么我们自己亏损。无论哪种情况，最后都是我们赔本了。</p>
<p>l 时间Time<br>指客户要求什么时候交付。</p>
<p>l 可靠性Reliability<br>指系统长时间正确运行的能力，银行、证券、电信这些公司，对宕机时间要求很严格的</p>
<p>l 安全性Security<br>指对信息安全的保护能力，涉及到钱、身份证、社会保险号等需求对这个要求很高</p>
<p>l 合规性Compliance<br>指满足各种行业标准、法律法规、规范等，例如3C、SOX、3GPP、ITUT等</p>
<p>l 技术性Technology<br>有的客户可能要求我们采用某种技术，例如客户现在都是Windows的机器，那么就可能要求我们基于Windows平台开发</p>
<p>l 兼容性Compatibility<br>指我们的产品与系统与客户其它已有的产品或者系统的兼容能力，要知道现在很少有产品是孤立运行的，特别是在大企业、大公司中，多个系统都是互相交互、互相配合的。新的系统必须能够和已有的系统配合，否则将无法运行。</p>
<p>为什么我们要将这8个C单独列出来呢？</p>
<p>需求分为功能属性和质量属性，前面的5W+1H是属于功能属性，而8C是属于质量属性，一个需求最终是否被正确的实现了，既要看功能属性是否正确，也要看质量属性是否正确，两者缺一不可！ </p>
<p>例如，你做了一个超牛逼的系统，功能超级强大，但一个操作需要10分钟，你觉得这样的系统客户有耐心用么？</p>
<h1 id="第十八章-用例分析"><a href="#第十八章-用例分析" class="headerlink" title="第十八章 用例分析"></a>第十八章 用例分析</h1><p>很多人在分析需求的时候，采用的是东扯葫芦西扯瓢的方式，列出了很多的需求点，但当你看完后，你还是不知道到底要干嘛！！  —- 写在前面</p>
<p>用例，英文名称Use Case，英文和中文都是很好理解，因为大家都这么用，我们暂且不去追究名称上的问题，只要知道“用例是用来描述需求的流程”，即：<strong>描述5W1H中的How</strong>。</p>
<p>看起来用例应该很好写，因为用例是描述需求的流程的，而需求的流程一般都是客户根据自己的业务总结出来，然后告诉我们的。我们只要将客户描述的内容记录下来即可，既简单又轻松！</p>
<p>但现实与理想总是有差距的，你可能会遇到一个对业务并不十分熟悉的客户，又或者和你交流的人员是客户的临时工，还有可能和你交流的人马上要休婚假了，他巴不得赶快了结这个无聊的事。。。。。。总之，各种各样的情况都可能出现，就是完美的情况不会出现！</p>
<p>这种情况下，我们如何才能做到完善的分析呢？我们怎么知道我们的分析是否正确，是否有遗漏，是否足够了？</p>
<p>一般的情况下，公司里负责需求分析得人员都是资深的员工，对领域、对系统有一定的积累和经验，即使面对这些情况，也可以通过自己的经验来弥补。</p>
<p>但对于一个菜鸟，遇到这种情况应该怎么办呢？难道菜鸟就不能做需求分析了么？</p>
<p>别慌，菜鸟虽然没有经验，但只要掌握正确的方法，一样可以做出很好的需求分析，这就是我总结的用例三部曲方法，又或叫做NEA方法。</p>
<p>我总结出的用例方法三段法（NEA方法）：<br>1） 正常处理（Normal）：通过和客户沟通，分析需求的正常流程；<br>2） 异常处理（Exception）：在正常处理流程的步骤上，分析每一步的各种异常情况和对应的处理；<br>3） 替代处理（Alternative）：在正常处理流程的步骤上，分析每一步是否有其它替代方法，以及替代方法如何做；</p>
<p>经过这简单三步后，How可以说分析得八九不离十了。<br>【用例的具体写法】<br>前面我们学习了518需求分析方法，而一个完整的用例，正好体现了518需求分析方法中涉及的内容。<br>一个完整的用例应该包含如下几个部分：<br>【用例名称】<br>一般情况下，用例的名称即需求的名称。<br>【场景】<br>场景即用例发生的环境，正好对应5W中的3个W：Who、Where、When<br>【用例描述】<br>描述详细的用例内容，对应5W中的What和How，即用户应该怎样做，以及每个步骤中的输出。但并不要求每个步骤都一定有输出，可以有也可以没有，也可以有多个。<br>【用例价值】<br>描述用例对应的客户价值，对应5W中的Why。<br>【约束和限制】<br>即整个需求流程中相关的约束和限制条件，对应518方法中的8C。</p>
<p>我们来看一个简单的样例：POS机。<br><strong>【第一步：正常处理】</strong><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">【用例名称】</span><br><span class="line">买单</span><br><span class="line">【场景】</span><br><span class="line">Who：顾客、收银员</span><br><span class="line">Where：商店的收银台</span><br><span class="line">When：营业时间</span><br><span class="line">【用例描述】</span><br><span class="line"><span class="bullet">1. </span>顾客携带选择好的商品到收银台；</span><br><span class="line"><span class="bullet">2. </span>收银员逐一扫描商品条形码，系统根据条形码查询商品信息；</span><br><span class="line"><span class="bullet">3. </span>扫描完毕，系统显示商品总额，收银员告诉顾客商品总额；</span><br><span class="line"><span class="bullet">4. </span>顾客将钱交给收银员；</span><br><span class="line"><span class="bullet">5. </span>收银员清点钱数，输入收到的款额，系统给出找零的数目；</span><br><span class="line"><span class="bullet">6. </span>收银员将找零的钱还给顾客，并打印小票；</span><br><span class="line"><span class="bullet">7. </span>买单完成，顾客携带商品和小票离开；</span><br><span class="line">【用例价值】</span><br><span class="line">顾客买完单以后，就可以携带商品离开，而超市也将得到收入；</span><br><span class="line">【约束和限制】</span><br><span class="line"><span class="bullet">1. </span>POS机必须符合国标XXX；</span><br><span class="line"><span class="bullet">2. </span>键盘使用中文，因为收银员都是中国人；</span><br><span class="line"><span class="bullet">3. </span>一次买单数额不能超过99999RMB；</span><br><span class="line"><span class="bullet">4. </span>POS机要非常稳定，至少一天内不要出现故障；</span><br></pre></td></tr></table></figure></p>
<p><strong>【第二步：异常处理】</strong><br>在第一步的基础上，我们增加相关步骤的异常情况说明和处理，例如如下的黑体字：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">【用例名称】</span><br><span class="line">买单</span><br><span class="line">【场景】</span><br><span class="line">Who：顾客、收银员</span><br><span class="line">Where：商店的收银台</span><br><span class="line">When：营业时间</span><br><span class="line">【用例描述】</span><br><span class="line"><span class="bullet">1. </span>顾客携带选择好的商品到收银台；</span><br><span class="line">（这一步没有异常）</span><br><span class="line"><span class="bullet">2. </span>收银员逐一扫描商品条形码，系统根据条形码查询商品信息；</span><br><span class="line">2.1 扫描仪坏了，必须支持手工输入条形码；</span><br><span class="line">2.2 <span class="strong">**商品的条形码无法扫描，必须支持手工输入条形码；**</span></span><br><span class="line">2.3 <span class="strong">**条形码能够扫描，但查询不到信息，需要收银员和顾客沟通，放弃购买此产品**</span></span><br><span class="line"><span class="bullet">3. </span>扫描完毕，系统显示商品总额，收银员告诉顾客商品总额；</span><br><span class="line">（这一步没有异常）</span><br><span class="line"><span class="bullet">4. </span>顾客将钱交给收银员；</span><br><span class="line">4.1 <span class="strong">**顾客的钱不够，顾客和收银员沟通，删除某商品**</span>；</span><br><span class="line">4.2 <span class="strong">**顾客的钱不够，顾客和收银员沟通，删除某类商品中的一个或几个（例如买了5包烟，去掉两包）**</span></span><br><span class="line">4.3 <span class="strong">**顾客觉得某个商品价格太高，要求删除某商品；**</span></span><br><span class="line"><span class="bullet">5. </span>收银员清点钱数，输入收到的款额，系统给出找零的数目；</span><br><span class="line">（这一步没有异常）</span><br><span class="line"><span class="bullet">6. </span>收银员将找零的钱还给顾客，并打印小票；</span><br><span class="line"><span class="bullet">7. </span>买单完成，顾客携带商品和小票离开；</span><br><span class="line">【用例价值】</span><br><span class="line">顾客买完单以后，就可以携带商品离开，而超市也将得到收入；</span><br><span class="line">【约束和限制】</span><br><span class="line"><span class="bullet">1. </span>POS机必须符合国标XXX；</span><br><span class="line"><span class="bullet">2. </span>键盘使用中文，因为收银员都是中国人；</span><br><span class="line"><span class="bullet">3. </span>一次买单数额不能超过99999RMB；</span><br><span class="line"><span class="bullet">4. </span>POS机要非常稳定，至少一天内不要出现故障；</span><br></pre></td></tr></table></figure></p>
<p>有的人可能会认为第3、第5、第6步都应该有异常，例如系统坏了应该怎么处理。<br>但实际上我们没有必要这么写，因为用例分析的目的是为了详细分析为了实现客户价值，系统应该怎么做，如果系统本身都坏了，这个就不是用例关注的内容了。</p>
<p>需要注意的是：用例分析中的“异常”是指流程的异常情况，而不包含系统本身的的异常。</p>
<p><strong>【第三步：替代处理】</strong><br>在第二步的基础上，我们增加替代处理。即：有的步骤可以换一种方式来实现。例如如下用例中的付款方式，可以有信用卡支付、会员卡支付、购物卡支付等。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">【用例名称】</span><br><span class="line">买单</span><br><span class="line">【场景】</span><br><span class="line">Who：顾客、收银员</span><br><span class="line">Where：商店的收银台</span><br><span class="line">When：营业时间</span><br><span class="line">【用例描述】</span><br><span class="line"><span class="bullet">1. </span>顾客携带选择好的商品到收银台；</span><br><span class="line">（这一步没有异常）</span><br><span class="line"><span class="bullet">2. </span>收银员逐一扫描商品条形码，系统根据条形码查询商品信息；</span><br><span class="line">2.1 扫描仪坏了，必须支持手工输入条形码；</span><br><span class="line">2.2 商品的条形码无法扫描，必须支持手工输入条形码；</span><br><span class="line">2.3 条形码能够扫描，但查询不到信息，需要收银员和顾客沟通，放弃购买此产品</span><br><span class="line"><span class="bullet">3. </span>扫描完毕，系统显示商品总额，收银员告诉顾客商品总额；</span><br><span class="line">（这一步没有异常）</span><br><span class="line"><span class="bullet">4. </span>顾客将钱交给收银员；</span><br><span class="line">4.1 顾客的钱不够，顾客和收银员沟通，删除某商品；</span><br><span class="line">4.2 顾客的钱不够，顾客和收银员沟通，删除某类商品中的一个或几个（例如买了5包烟，去掉两包）</span><br><span class="line">4.3 顾客觉得某个商品价格太高，要求删除某商品；</span><br><span class="line">4-A：<span class="strong">**顾客使用信用卡支付**</span></span><br><span class="line">4-A.1 信用卡支付流程（请读者自行思考完善，可以写在这里，如果太多，也可以另外写一个子用例）</span><br><span class="line">4-B：<span class="strong">**顾客使用购物卡支付**</span></span><br><span class="line">        4-B.1 购物卡支付流程</span><br><span class="line">4-C：<span class="strong">**顾客使用会员卡积分支付**</span></span><br><span class="line">        4-C.1 会员卡积分支付流程</span><br><span class="line"><span class="bullet">5. </span>收银员清点钱数，输入收到的款额，系统给出找零的数目；</span><br><span class="line">（这一步没有异常）</span><br><span class="line"><span class="bullet">6. </span>收银员将找零的钱还给顾客，并打印小票；</span><br><span class="line"><span class="bullet">7. </span>买单完成，顾客携带商品和小票离开；</span><br><span class="line">【用例价值】</span><br><span class="line">顾客买完单以后，就可以携带商品离开，而超市也将得到收入；</span><br><span class="line">【约束和限制】</span><br><span class="line"><span class="bullet">1. </span>POS机必须符合国标XXX；</span><br><span class="line"><span class="bullet">2. </span>键盘使用中文，因为收银员都是中国人；</span><br><span class="line"><span class="bullet">3. </span>一次买单数额不能超过99999RMB；</span><br><span class="line"><span class="bullet">4. </span>POS机要非常稳定，至少一天内不要出现故障；</span><br></pre></td></tr></table></figure>
<p>经过上面步步为营，逐步细化和求精，我们已经得到了一个比较完善的需求了，这个过程中并没有高深的技巧，也没有涉及需要丰富的经验。</p>
<p>有的读者可能会有疑问：我怎么知道第4步有那些异常、那些替代方案呢？<br>其实很简单：问你的客户！客户是最清楚了，但如果你不问，嘿嘿，客户倒不一定会告诉你：）</p>
<p>但只要我们掌握了NEA用例分析方法，即使客户忘记了，或者没有意识到，我们也会将需求挖出来，这样需求就不会遗漏。</p>
<p>【要画图么？】<br>大家可以看到，我们在前面进行用例分析的时候，并没有看到任何图，而是纯文本！</p>
<p>对于那些UML狂热分子来说，这可能是难以接受的，怎么能没有图呢？UML中的用例图不就是用来分析需求的么？</p>
<p>我们当然不怀疑UML的权威性，但任何东西都有局限性，UML也不例外。UML的局限就在于UML是一个建模的语言，就像汉语、英语一样，只是一种表达形式，而不是一种分析和创作方式。</p>
<p>比如说你会汉语，但并不代表你就能写小说，你会画UML用例图，但并不代表你就能做需求分析。相反，必须是有了需求和用例之后，才有用例图，说白了，用例图是用例的图形化描述，但是它并不能取代用例。</p>
<p>除了UML本身的局限性外，还有另外一个更重要的原因：用例是客户和公司关于产品的一个共同认识！一般情况下，市场人员和客户沟通交流，了解客户的需求，然后和客户一一确认，最后形成需求文档。在这个过程中，主要是客户和市场人员参与，而没有研发的人员参与。</p>
<p>对于客户来说，他肯定是以自然语言，而不会用UML来描述需求；对于市场人员来说也一样，他可能对UML一窍不通，甚至他以前可能都是卖医疗器械，甚至有可能是狗皮膏药的，他还管你什么软件工程，什么UML？</p>
<p>所以，采用用例方法分析需求的时候，我们都是采用纯文本来描述需求的，而不会采用用例图来分析需求</p>
<h1 id="第十九章-功能点提取"><a href="#第十九章-功能点提取" class="headerlink" title="第十九章 功能点提取"></a>第十九章 功能点提取</h1><p>完成了用例之后，需求分析的工作基本上已经完成，接下来我们需要趁热打铁，完成另外一个事情：<strong>提取功能点</strong>！</p>
<p>有了用例之后，提取功能可以说是一个水到渠成的事情，基本上只是一个文字工作，我们只需要将用例中那些需要系统完成的事情——更简单的说：是动词——提取出来，就成为了系统的功能。</p>
<p>以前面的POS机为例，我们看看如何提取功能，如下<strong>粗体</strong>字即为提取的功能：<br> <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">【用例名称】</span><br><span class="line">买单</span><br><span class="line">【场景】</span><br><span class="line">Who：顾客、收银员</span><br><span class="line">Where：商店的收银台</span><br><span class="line">When：营业时间</span><br><span class="line">【用例描述】</span><br><span class="line">1. 顾客携带选择好的商品到收银台；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">2. 收银员逐一*<span class="strong">*扫描商品条形码*</span><span class="strong">*，系统根据条形码*</span><span class="strong">*查询商品信息*</span><span class="strong">*；</span><br><span class="line">2.1 扫描仪坏了，必须支持*</span><span class="strong">*手工输入条形码*</span><span class="strong">*；</span><br><span class="line">2.2 商品的条形码无法扫描，必须支持*</span><span class="strong">*手工输入条形码*</span><span class="strong">*；</span><br><span class="line">2.3 条形码能够扫描，但查询不到信息，需要收银员和顾客沟通，放弃购买此产品</span><br><span class="line">3. 扫描完毕，系统*</span><span class="strong">*计算商品总额并显示*</span><span class="strong">*，收银员告诉顾客商品总额；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">4. 顾客将钱交给收银员；</span><br><span class="line">4.1 顾客的钱不够，顾客和收银员沟通，*</span><span class="strong">*删除某商品*</span><span class="strong">*；</span><br><span class="line">4.2 顾客的钱不够，顾客和收银员沟通，*</span><span class="strong">*删除某类商品中的一个或几个*</span><span class="strong">*（例如买了5包烟，去掉两包）</span><br><span class="line">4.3 顾客觉得某个商品价格太高，要求*</span><span class="strong">*删除某商品*</span><span class="strong">*；</span><br><span class="line">4-A：顾客使用信用卡支付</span><br><span class="line">4-A.1 信用卡支付流程（请读者自行思考完善，可以写在这里，如果太多，也可以另外写一个子用例）</span><br><span class="line">4-B：顾客使用购物卡支付</span><br><span class="line">        4-B.1 购物卡支付流程</span><br><span class="line">4-C：顾客使用会员卡积分支付</span><br><span class="line">        4-C.1 会员卡积分支付流程</span><br><span class="line">5. 收银员清点钱数，*</span><span class="strong">*输入收到的款额*</span><span class="strong">*，系统*</span><span class="strong">*给出找零的数目*</span><span class="strong">*；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">6. 收银员将找零的钱还给顾客，并*</span><span class="strong">*打印小票*</span><span class="strong">*；</span><br><span class="line">7. 买单完成，顾客*</span><span class="strong">*携带*</span><span class="strong">*商品和小票*</span><span class="strong">*离开*</span><span class="strong">*；</span><br><span class="line">【用例价值】</span><br><span class="line">顾客买完单以后，就可以携带商品离开，而超市也将得到收入；</span><br><span class="line">【约束和限制】</span><br><span class="line">1. POS机必须符合国标XXX；</span><br><span class="line">2. 键盘使用中文，因为收银员都是中国人；</span><br><span class="line">3. 一次买单数额不能超过99999RMB；</span><br><span class="line">4. POS机要非常稳定，至少一天内不要出现故障；</span></span><br></pre></td></tr></table></figure></p>
<p>我们将提取的功能列出来：</p>
<table>
<thead>
<tr>
<th style="text-align:center">功能编号</th>
<th style="text-align:center">功能描述</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">001</td>
<td style="text-align:center">扫描商品条形码</td>
<td style="text-align:center">NA</td>
</tr>
<tr>
<td style="text-align:center">002</td>
<td style="text-align:center">手工输入条形码</td>
<td style="text-align:center">在用例的几个步骤中有体现</td>
</tr>
<tr>
<td style="text-align:center">003</td>
<td style="text-align:center">删除某商品</td>
<td style="text-align:center">在用例的几个步骤中有体现</td>
</tr>
<tr>
<td style="text-align:center">004</td>
<td style="text-align:center">删除某类商品中的一个或几个</td>
<td style="text-align:center">NA</td>
</tr>
<tr>
<td style="text-align:center">005</td>
<td style="text-align:center">顾客使用信用卡支付</td>
<td style="text-align:center">这三个功能点比较大，如有需要，可以继续拆分。</td>
</tr>
<tr>
<td style="text-align:center">006</td>
<td style="text-align:center">顾客使用购物卡支付</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">007</td>
<td style="text-align:center">顾客使用会员卡积分支付</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">008</td>
<td style="text-align:center">计算找零的数目</td>
<td style="text-align:center">用例中是“给出”，对应系统功能是我们改为“计算”，因为这更加符合计算机的描述术语。</td>
</tr>
<tr>
<td style="text-align:center">009</td>
<td style="text-align:center">打印小票</td>
<td style="text-align:center">NA</td>
</tr>
</tbody>
</table>
<p>注意用例中可能同一个功能在不同的步骤中出现了多次（例如“手工输入条形码”、“删除某商品”），最后提取的时候要合并。</p>
<p>除了同一用例中某些功能要合并外，不同的用例中相同的功能也需要合并，我们以ATM机为例：</p>
<table>
<thead>
<tr>
<th style="text-align:center">功能编号</th>
<th style="text-align:center">功能描述</th>
<th style="text-align:center">涉及用例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">001</td>
<td style="text-align:center">银行卡验证</td>
<td style="text-align:center">取款、存款、查询余额</td>
</tr>
<tr>
<td style="text-align:center">002</td>
<td style="text-align:center">密码验证</td>
<td style="text-align:center">取款、存款、查询余额</td>
</tr>
<tr>
<td style="text-align:center">003</td>
<td style="text-align:center">点钞</td>
<td style="text-align:center">取款、存款</td>
</tr>
<tr>
<td style="text-align:center">004</td>
<td style="text-align:center">验钞</td>
<td style="text-align:center">存款</td>
</tr>
<tr>
<td style="text-align:center">005</td>
<td style="text-align:center">打印交易清单</td>
<td style="text-align:center">取款、存款</td>
</tr>
</tbody>
</table>
<p>有的同学可能会问：有了用例后，为什么还要将功能点单独提取出来呢？直接看用例不就可以了么？<br>这个问题要从多方面来回答：<br>首先，从美学的角度来看，看一个功能列表的表格，肯定比看一长篇用例文档，然后在脑袋里组织功能列表要方便很多；</p>
<p>其次，从项目管理的角度来看，功能列表更易于管理，例如任务分配时不可能基于用例进行分配的，因为不同用例间可能存在大量重复的功能点；</p>
<p>再次，从开发角度来说，开发是基于功能点的，而不是基于用例的；<br>最后，从测试的角度来说，虽然最后的验收测试是基于用例的，但产品测试主要还是基于功能点进行测试的</p>
<h1 id="第二十章-用例图的陷阱"><a href="#第二十章-用例图的陷阱" class="headerlink" title="第二十章 用例图的陷阱"></a>第二十章 用例图的陷阱</h1><p>你知道么，用例图 <strong>不是</strong> 用来描述 用例的哦！！！！</p>
<p>熟悉UML的朋友都肯定知道，UML有一个叫做用例图的东东。<br>单纯从名字上来看，你可能以为用例图是用来描述用例的，即：用例图 = 用例的图形化表示。</p>
<p>然而各位发明ＵＭＬ的大师们，却在无意中给我们设下了一个陷阱：所谓的用例图，不是用来描述用例，而是用来描述系统的图形。</p>
<p>听起来有点奇怪和别扭，既然是用来描述系统的图形，为什么叫做用例图，而不叫系统图呢？</p>
<p>这和用例图的画法有关，用例图虽然是用来描述系统的图形，但其内容主要就是用例。<br>我们来看用例图的定义：</p>
<blockquote>
<p>The use case view captures the behavior of a system, subsystem, or class as it appears to an outside user</p>
</blockquote>
<p>简单翻译一下：用例图用于捕获系统、子系统或者类相关的呈现给外部用户的行为。</p>
<p>单纯看这个定义有点难以理解，其实看看用例图的组成就很简单了。用例图的组成如下：<br>Actor：系统外的用户，对应5W中的Who，包括但不限于用户、外系统；<br>Use Case：用例，对应前面讲到的用例；<br>System：系统，所有用例的集合就是系统了。</p>
<p>我们以ATM取款机为样例，用例图如下：<br> <img src="http://upload-images.jianshu.io/upload_images/1985459-31dcde23ec6fede4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>从这个图可以清楚的看到，所谓用例图，可以简单的<strong>理解为系统用例的集合</strong>，而不是详细描述每个用例的具体步骤和流程。<br>这也是前面我们提到的为什么是用“用例”来分析需求，而不是用“用例图”来分析需求的原因</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/软件笔记/">软件笔记</a>
	</div>


      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面向对象/">面向对象</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
        var yiliaConfig = {
        fancybox: true,
        mathjax: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        open_in_new: false
        }
        </script>
     

  
    <article id="post-面向对象葵花宝典1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/11/面向对象葵花宝典1/" class="article-date">
  	<time datetime="2016-05-11T14:38:40.000Z" itemprop="datePublished">2016-05-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/11/面向对象葵花宝典1/">连载：面向对象葵花宝典：思想、技巧与实践(1-10章)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>无意间发现这篇文章，文章讲解由浅入深，读完后感触很深<br>特全文转到自己的博客，方便以后自己随时查看<br>文章转载自爱技术的华仔的博客[<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">http://blog.csdn.net/yunhua_lee</a>]<br>非常感谢<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">爱技术的华仔</a></p>
</blockquote>
<h1 id="第一章-程序设计思想的发展"><a href="#第一章-程序设计思想的发展" class="headerlink" title="第一章 程序设计思想的发展"></a>第一章 程序设计思想的发展</h1><p><strong>史前时代：面向机器</strong><br>最早的程序设计都是采用机器语言来编写的，直接使用二进制码来表示机器能够识别和执行的指令和数据。简单来说，就是直接编写0和1的序列来代表程序语言。例如：使用0000 代表 加载（LOAD），0001 代表 存储（STORE）等。 </p>
<p>机器语言由机器直接执行，速度快，但一个很明显的缺点就是：写起来实在是太困难了，一旦你发现自己写错了，改起来更蛋疼！这样直接导致程序编写效率十分低下，编写程序花费的时间往往是实际运行时间的几十倍或几百倍。<br>有一个关于机器语言和比尔盖茨的笑话，是说比尔盖茨拿着绣花针在一张光盘上戳，把Windows给戳出来了！但如果真的让你去戳，不要说Windows，连一个简单的“Hello world”都要让人戳到眼睛冒烟！ </p>
<p>由于机器语言实在是太难编写了，于是就发展出了汇编语言。汇编语言亦称符号语言，用助记符代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址，。汇编语言由于是采用了助记符号来编写程序，比用机器语言的二进制代码编程要方便些，在一定程度上简化了编程过程。例如使用LOAD 来代替 0000，使用STORE来代替0001。 </p>
<p>即使汇编语言相比机器语言提升了可读性，但其本质上还是一种面向机器的语言，编写同样困难，也很容易出错。相信很多计算机毕业的学生至今都对学校的汇编课程中的练习程序心有余悸。 </p>
<p><strong>脱离机器第一步：面向过程</strong><br>面向机器的语言通常情况下被认为是一种“低级语言”，为了解决面向机器的语言存在的问题，计算机科学的前辈们又创建了面向过程的语言。面向过程的语言被认为是一种“高级语言”，相比面向机器的语言来说，面向过程的语言已经不再关注机器本身的操作指令、存储等方面，而是关注如何一步一步的解决具体的问题，即：解决问题的过程，这应该也是面向过程说法的来由。 </p>
<p>相比面向机器的思想来说，面向过程是一次思想上的飞跃，将程序员从复杂的机器操作和运行的细节中解放出来，转而关注具体需要解决的问题；面向过程的语言也不再需要和具体的机器绑定，从而具备了移植性和通用性；面向过程的语言本身也更加容易编写和维护。这些因素叠加起来，大大减轻了程序员的负担，提升了程序员的工作效率，从而促进了软件行业的快速发展。 </p>
<p>典型的面向过程的语言有：COBOL、FORTRAN、BASIC、C语言等。</p>
<p><strong>第一次软件危机：结构化程序设计</strong><br>随着计算机硬件的飞速发展，以及应用复杂度越来越高，软件规模越来越大，原有的程序开发方式已经越来越不能满足需求了。1960年代中期开始爆发了第一次软件危机，典型表现有软件质量低下、项目无法如期完成、项目严重超支等，因为软件而导致的重大事故时有发生。例如1963年美国（<a href="http://en.wikipedia.org/wiki/Mariner_1）" target="_blank" rel="external">http://en.wikipedia.org/wiki/Mariner_1）</a> 的水手一号火箭发射失败事故，就是因为一行FORTRAN代码错误导致的。 </p>
<p>软件危机最典型的例子莫过于IBM的System/360的操作系统开发。佛瑞德·布鲁克斯（Frederick P. Brooks, Jr.）作为项目主管，率领2000多个程序员夜以继日的工作，共计花费了5000人一年的工作量，写出将近100万行的源码，总共投入5亿美元，是美国的“曼哈顿”原子弹计划投入的1/4。尽管投入如此巨大，但项目进度却一再延迟，软件质量也得不到保障。布鲁克斯后来基于这个项目经验而总结的《人月神话》一书，成了史上最畅销的软件工程书籍。<br>为了解决问题，在1968、1969年连续召开两次著名的NATO会议，会议正式创造了“软件危机”一词，并提出了针对性的解决方法“软件工程”。虽然“软件工程”提出之后也曾被视为软件领域的银弹，但后来事实证明，软件工程同样无法解决软件危机。 </p>
<p>差不多同一时间，“结构化程序设计”作为另外一种解决软件危机的方案被提出来了。 Edsger Dijkstra 于1968发表了著名的《GOTO有害论》的论文，引起了长达数年的论战，并由此产生了结构化程序设计方法。同时，第一个结构化的程序语言Pascal也在此时诞生，并迅速流行起来。<br>结构化程序设计的主要特点是抛弃goto语句，采取“自顶向下、逐步细化、模块化”的指导思想。结构化程序设计本质上还是一种面向过程的设计思想，但通过“自顶向下、逐步细化、模块化”的方法，将软件的复杂度控制在一定范围内，从而从整体上降低了软件开发的复杂度。结构化程序方法成为了1970年代软件开发的潮流。 </p>
<p>科学研究证明，人脑存在人类短期记忆一般一次只能记住5-9个事物，这就是著名的 7+- 2原理。结构化程序设计是面向过程设计思想的一个改进，使得软件开发更加符合人类思维的7+-2特点。</p>
<p><strong>第二次软件危机：面向对象程序设计</strong><br>结构化编程的风靡在一定程度上缓解了软件危机，然而好景不长，随着硬件的快速发展，业务需求越来越复杂，以及编程应用领域越来越广泛，第二次软件危机很快就到来了。 </p>
<p>第二次软件危机的根本原因还是在于软件生产力远远跟不上硬件和业务的发展，相比第一次软件危机主要体现在“复杂性”，第二次软件危机主要体现在“可扩展性”、“可维护性”上面。传统的面向过程（包括结构化程序设计）方法已经越来越不能适应快速多变的业务需求了，软件领域迫切希望找到新的银弹来解决软件危机，在这种背景下，面向对象的思想开始流行起来。 </p>
<p>面向对象的思想并不是在第二次软件危机后才出现的，早在1967年的Simula语言中就开始提出来了，但第二次软件危机促进了面向对象的发展。 面向对象真正开始流行是在1980s年代，主要得益于C++的功劳，后来的Java、C#把面向对象推向了新的高峰。到现在为止，面向对象已经成为了主流的开发思想。 </p>
<p>虽然面向对象开始也被当做解决软件危机的银弹，但事实证明，和软件工程一样，面向对象也不是银弹，而只是一种新的软件方法而已。 </p>
<p>虽然面向对象并不是解决软件危机的银弹，但和面向过程相比，面向对象的思想更加贴近人类思维的特点，更加脱离机器思维，是一次软件设计思想上的飞跃。</p>
<h1 id="第二章-面向对象语言发展历史"><a href="#第二章-面向对象语言发展历史" class="headerlink" title="第二章 面向对象语言发展历史"></a>第二章 面向对象语言发展历史</h1><p><strong>Simula </strong><br>面向对象技术最早是在编程语言Simula中提出的。1967年5月20日，在挪威奥斯陆郊外的小镇莉沙布举行的IFIP TC-2 工作会议上，挪威科学家Ole-Johan Dahl和Kristen Nygaard正式发布了Simula 67语言。Simula 67被认为是最早的面向对象程序设计语言，是面向对象的开山祖师，它引入了所有后来面向对象程序设计语言所遵循的基础概念：对象、类、继承，但它的实现并不是很完整。<br>Simula虽然最早提出面向对象的概念，但因为其本身复杂，比较难学，而并没有大规模流行。但Simula提出的面向对象的概念对程序语言后继的发展产生了巨大和深远的影响。</p>
<p><strong>Smalltalk</strong><br>Smalltalk是公认为历史上第二个面向对象的程序语言，而且是第一个完整实现了面向对象技术的语言。<br>最早的Smalltalk原型由艾伦·凯于70年代初提出。类（来自Simula-67）、海龟绘图（来自MIT的LOGO）以及图形界面等概念的有机组合，构成了Smalltalk的最初的蓝图。在1971年到1975年之间，艾伦·凯在Xerox PARC的小组设计并实现了第一个真正的Smalltalk语言系统。<br>Smalltalk引领了面向对象的设计思想的思潮，对其它众多的程序设计语言的产生起到了极大的推动作用。C++，C#，Objective-C，Actor，Java和Ruby等，无一不受到Smalltalk的影响，这些程序语言中也随处可见Smalltalk的影子。<br>除了编程语言受到Smalltalk的影响外，90年代的许多软件开发思想得利于Smalltalk，例如设计模式、敏捷编程和代码重构等。</p>
<p><strong>C++</strong><br>C++是第一个大规模使用的面向对象语言，面向对象程序设计在80年代成为了一种主导思想，这很大程度上得益于C++的流行。而且与Simula、Smalltalk不同的是，C++到现在为止还是排名前三的编程语言，并没有湮没在历史的洪流中。<br>C++由贝尔实验室的Bjarne Strou-strup与1983年推出，C++进一步扩充和完善了C语言，成为一种面向 对象的程序设计语言。<br>C++最开始的时候不是叫做C++，而是C with class，这是把它当作一种C语言的有效扩充。由于当时C语言在编程界居于老大的地位，要想发展一种新的语言，最强大的竞争对手就是C语言，所以当时有两个问题最受关注：C++要在运行时间、代码紧凑性和数据紧凑性方面能够与C语言相媲美，但是还要尽量避免在语言应用领域的限制。在这种情况下，一个很自然的想法就是让C++从C语言继承过来，但如果只是简单继承的话，就不能有所突破了，因此Bjarne博士采取了拿来主义，参考了很多的语言，将它们的优点“继承”过来了。例如：从Simula继承了类的概念，从Algol68继承了运算符重载、引用以及在任何地方声明变量的能力，从BCPL获得了//注释，从Ada得到了模板、名字空间，从Ada、Clu和ML取来了异常。<br>正是因为C++兼容C，同时又具备了面向对象的能力，使得C++能够大行其道，广受欢迎；然而也正是C++是一个超级大杂烩，语言本身很复杂，导致针对C++存在很多批评和争议。有一个玩笑是说：Bjarne Strou-strup发明C++语言的时候就没有指望任何一个程序员能够完全掌握C++！</p>
<p><strong>Java</strong><br>Java是目前使用最广的面向对象编程语言，拥有全球最多的开发者，常年稳居开发语言排行榜第一名（偶尔和C交换一下位置）。如果说C++促进了面向对象的流行，那么Java就将面向对象推上了王座。比尔盖茨曾这样评价“Java是很长时间以来最优秀的程序设计语言”。<br>Java是由Sun Microsystems公司于 1995年5月推出，由“Java之父”James Gosling和一群技术天才创造，并在1995年正式推出。最初的Java被称为Oak —— 以Gosling办公室外的一棵橡树命名，后来由于商标版权问题，改名为Java —— 据说取名的灵感来自印尼爪哇岛味道优美的咖啡。<br>Sun 公司在推出 Java 之际就将其作为一种开放的技术，并且定位于互联网应用。因此随着互联网的发展和流行，加上开源运动的发展，Java逐渐成为了最流行的编程语言。<br>相比C++来说，Java语言是一个更加纯净、更加易用的面向对象编程语言。Java语言的编程风格和C++比较相似，但去掉了很多C++中复杂和容易出错的特性，例如指针，多继承等，同时增加了垃圾回收等大大提升生产率的特性。Sun公司对Java语言的解释是：“Java编程语言是个简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言”，虽然有点王婆卖瓜的味道，但Java针对C++的改进，确实大大提升了生产力，降低了复杂度，客观上也促进了Java的流行。</p>
<h1 id="第三章-面向过程-vs-面向对象"><a href="#第三章-面向过程-vs-面向对象" class="headerlink" title="第三章 面向过程 vs 面向对象"></a>第三章 面向过程 vs 面向对象</h1><h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><p>在介绍面向对象之前，我们首先要介绍“面向过程“，首先是因为”面向过程“是软件思想中的鼻祖；其次是因为只有了解了面向过程，你才能更好的了解面向对象！正所谓：知己知彼百战百胜！<br>面向过程是一种以“过程”作为中心的编程思想，其中过程的含义就是“完成一件事情的步骤”。<br>面向过程其实是一种“机械的思想”，它就像流水线一样，一个阶段衔接一个阶段，每个阶段都有自己的输入、处理、输出，而在流水线上流动的就是我们的原料或者中间产品，每个阶段都有一个机械进行处理，最后的输出就是我们的产品。<br> 在运用面向过程的方法时，你也需要设计这样一条程序流水线：将程序划分为不同的阶段，设计好各个阶段如何衔接，然后定义好每个阶段需要处理的数据。<br>但凡学过编程的都知道这么一个说法：程序=[算法]+ [数据结构]，这个总结其实正好契合了机械化的特征，“算法”=“流水线”，“数据结构”= “原料/中间产品”，“程序”= “产品”。<br>面向过程的这种特征其实是和计算机的本质相关的，计算机本质上是一台机器，其核心-CPU处理的是指令流水，简单点说就是01串，要让计算机跑起来，按照CPU的特点进行思考和处理是理所当然的。<br>即使我们使用面向对象的语言进行开发，最后转换为CPU能执行的指令，还是面向过程的，所以说，面向过程无处不在，是计算机的基石。<br>如下图片是啤酒生产线的全流程图，形象的说明了面向过程的处理方式：<br><img src="http://upload-images.jianshu.io/upload_images/1985459-006e7f2ffc765f7a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象是一种以“对象”作为中心的编程思想，其中对象的含义可以理解为“存在的东西”。<br>与面向过程的方法相比，面向对象不再局限于计算机的机器本质，而更加侧重于对现实世界的模拟。面向过程的方法中，有一套设计严格的操作顺序，有一个类似中央控制器的角色来进行统一调度；而面向对象的方法中，并没有明确的中央控制的角色，也不需要指定严格的操作顺序，而是设计了很多对象，并且指定了这些对象需要完成的任务，以及这些对象如何对外界的刺激做出反应。<br>如果说面向过程像一条流水生产线，那么面向对象就像是一个足球队。没有哪个人能够在一场比赛开始的时候，就精确指定每个队员的每一次跑动，每一次出脚，每一次传球。。。。。。而只能指定队员的角色（前锋、中场、后卫、门将），然后由队员门自己根据情况做出反应。所以世界上有两个一样的生产线，但绝对不会存在两场一模一样的比赛。<br>面向对象这种对现实世界的模拟的思想，其本质上就是“人的思想”，这是一个质的飞跃，意味着程序员可以按照人的思想来观察、分析、设计系统。<br>什么叫做“人的思想”？你可以放下书本，关上电脑，站起来，环顾四周，你看到的是什么？可能是你的同事、桌子、墙、电脑、花盆；或者是电话、窗子、书本。。。。。。怎么样，这些都是“对象”吧？除了观察目标聚焦于“对象”外，当我们观察人类世界各种事情的运作的时候，我们也不知不觉的聚焦于“对象”。例如，一个公司的运作，由董事长、经理、主管、员工等人分工合作，根据不同的任务或者外界竞争而去做各种各样的事情。<br>人大部分的时间都是按照面向对象的方式进行思考的，而且人类世界主要也是按照面向对象的方式进行运转的，所以说，“面向对象”其实更加符合人的思维习惯。<br>面向过程中有“程序=算法+数据结构”的经典总结，面向对象也有类似的总结：“程序=对象 + 交互”。其中对象就是具体存在的事物，而交互则是事物之间的相互作用、互动等。<br>如下是一张医院的组织结构图，形象的说明了面向对象的处理方式：<br><img src="http://upload-images.jianshu.io/upload_images/1985459-6d853d82b57015fb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h1 id="第四章-面向对象是瑞士军刀还是一把锤子？"><a href="#第四章-面向对象是瑞士军刀还是一把锤子？" class="headerlink" title="第四章 面向对象是瑞士军刀还是一把锤子？"></a>第四章 面向对象是瑞士军刀还是一把锤子？</h1><h2 id="为什么要面向对象？"><a href="#为什么要面向对象？" class="headerlink" title="为什么要面向对象？"></a>为什么要面向对象？</h2><p>可以说，面向过程和计算机是如影随形的。从计算机诞生之日起，面向过程就是占据着主导地位的思想，即使到了现在，面向过程也是无处不在的，C语言、操作系统、协议栈、驱动系统，都是面向过程的代表。 </p>
<p>那为什么还会有面向对象的诞生并流行呢？当然是面向过程存在某些不足，如果面向过程足够好，谁还费心费力的去搞另外一套呢？ </p>
<p>前面我们提到，面向过程是一种机器的思想，我们以流水线作为类比，那么我们先抛开面向过程，来看看流水线有什么不足。<br>举个简单的流水线例子：啤酒生产流水线。啤酒生产流水线分为“洗瓶”，“灌装”，“压盖”，“杀菌”等几个阶段，这些阶段总体上来说对生产一瓶醋是差不多的，但是一条啤酒生产线能够生产醋么？应该是不行的，即使行，估计也要换一些东西，但是换了东西后，又不能生产啤酒了。<br>面向过程同样就有流水线的这个缺点，即：流程和原料相对固定，扩展比较麻烦。 </p>
<p>对于工业系统来说，流水线的缺点几乎可以微不足道，因为工业化讲究的是效率，而扩展性却不是那么重要，一旦一条生产线建成，至少需要运行几年，甚至运行十几年都有。<br>而对于软件系统来说，很难想象一个软件开发完成后，几年都不变，大部分的情况是，软件可能是1年扩展多次，甚至还没有开发完，客户新的需求又来了。 </p>
<p>在软件系统这种环境下，面向过程显得就比较吃力了，每次需求的变更，可能都要将流程的每个步骤、原料、中间产品都进行修改，这样的代价在软件系统中几乎是不可接受的，因为每次修改都需要对全系统改动一次，不但工作量上大大增加，同时风险也是大大增加。 </p>
<p>而面向对象正是为了解决面向过程的这个缺点儿诞生的，因此面向对象其实也不是什么复杂和玄妙的技术，面向对象思想的核心是“可扩展性”！<br>注：中文“可扩展性”对应英文有两种解释：extensibility 和 scalability，extensibility指系统需求变化后，能够比较容易的扩展以支持新需求；scalability指系统访问压力增加后，能够通过简单的增加更多硬件设备以支撑访问压力，又翻译为“可伸缩性”。 本文的可扩展性是指extensibility。</p>
<h2 id="面向对象应用范围"><a href="#面向对象应用范围" class="headerlink" title="面向对象应用范围"></a>面向对象应用范围</h2><p>能做什么？<br>既然面向对象思想的核心是“可扩展性”，那么其适用范围就显而易见了：经常变化的地方就是面向对象应用的地方。<br>对于软件系统来说，常见的可变的主要集中在客户需求部分，而不变的一般都是属于计算机系统的基础。<br>因此，操作系统、数据库、协议（TCP、3GPP等）这些并不适合面向对象大展身手，因为这些基础软件一般都比较稳定（相对稳定，并不是不变）。而对于企业应用、互联网等应用，需求经常变更，功能不断扩展，这正是面向对象大展身手的地方。</p>
<p>不能做什么？<br>下图是一个软件质量属性的全图：<br> <img src="http://upload-images.jianshu.io/upload_images/1985459-979e1a5b25f0c245?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>大家可以看到，“可扩展性”只是软件质量属性中很小的一部分，其它的属性都不是面向对象能够解决的。<br>明白了面向对象的特点和适用范围，是应用面向对象的关键，经过前面的分析，我们知道，面向对象不是瑞士军刀，而只是一个普通的锤子而已，千万不要拿着锤子到处敲！</p>
<h1 id="第五章-面向对象迷思：面向对象导致性能下降？"><a href="#第五章-面向对象迷思：面向对象导致性能下降？" class="headerlink" title="第五章 面向对象迷思：面向对象导致性能下降？"></a>第五章 面向对象迷思：面向对象导致性能下降？</h1><p><strong> 面向对象会导致性能降低？</strong><br>这是一个在IT江湖流传已久的传说，很多对面向对象不甚了解、或者一知半解的人，每当需要抵触面向对象时，就会把这条“金科玉律”拿出来救驾！</p>
<p>更要命的是，每个相信这个传说的人都会举一个看起来很显而易见的例子：C和Java的对比！</p>
<p>你可以到网上搜索一大堆C和Java的性能对比，你自己也可以做一个简单的对比测试，我毫不怀疑测试结果肯定是C快，但这能证明面向对象导致性能降低么？</p>
<p>从语言层面来说，面向对象的语言肯定要比面向过程的语言性能要低一些，毕竟这是由处理机制决定的，就像不同的人的差别由基因决定一样，这个很难改变。</p>
<p>但在实际应用中，除了上一章我们提到的专有系统（操作系统、驱动、嵌入式），对一般的业务系统来说，无论是企业级应用、还是互联网应用、还是电信银行应用，无一例外的都是复杂的系统，这些系统要和存储系统（磁盘、磁带等）打交道、要通过网络进行交互、要访问数据库。。。。。。等等。</p>
<p>我们看一下常见的一些性能数据（量级数据，不一定精确）：<br>CPU： 每秒10亿次，性能是纳秒级<br>内存：每秒1000万次，每次请求时间是微秒级<br>磁盘：每次请求5ms，请求时间是毫秒级<br>网络（TCP）：每次网络交互2ms，请求时间是毫秒级<br>数据库：基本等于网络和磁盘之和，甚至更慢</p>
<p>从上面的数据我们可以看出，如果你的业务流程中涉及了磁盘、网络、数据库等操作，那么性能就一下子降到了毫秒级。</p>
<p>而对于大部分开发语言来说，语言本身的运行速度至少是内存级别的</p>
<p>试想一下，你的整个流程中，语言本身的处理占了微妙级的时间，而一次磁盘或者网络的时间是毫秒级时间，那么全流程来看，就算你把语言本身的处理速度提高了10倍，对整个流程来说，性能几乎没有影响。</p>
<p>例如：假设C语言全流程处理时间：10微秒（语言部分） +  5ms（磁盘操作） =  5.01ms<br>如果换成Java，那么处理时间变成：100微秒（语言部分） + 5ms（磁盘操作） = 5.1 ms<br>从这个简单的样例可以看出，语言本省性能的提升，对整个流程中性能提升几乎没有影响！！</p>
<p>因此，对于复杂的业务系统来说，性能的好坏是由设计来决定的，而不是由语言来决定的，更不会因为采用了面向对象而导致性能的降低！</p>
<h1 id="第六章-不要说你懂“类”"><a href="#第六章-不要说你懂“类”" class="headerlink" title="第六章 不要说你懂“类”"></a>第六章 不要说你懂“类”</h1><blockquote>
<p>方以类聚，物以群分——《周易 易传》。 </p>
</blockquote>
<p>类是面向对象领域里最基础的一个概念，也是面向对象分析和设计的基石。<br>然而，如此重要的一个概念，竟然很难找到深入的说明，绝大部分介绍面向对象的书籍或者资料基本上都是这么解释的：“类是一组对象的抽象”，这个解释看起来清晰明了，但实际上犯了一个逻辑上的错误：以未明确的概念来解释待明确的概念，什么是对象，什么是抽象，我们都还不知道，你却用这个概念来解释类？那当然看不懂了。<br>还有另外一个解释：类就是属性和方法的集合！甚至还会给出如下这样的样例：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Class</span> Person&#123;</span><br><span class="line"><span class="attribute">Int</span>  age;</span><br><span class="line"><span class="attribute">String</span>  name;</span><br><span class="line"><span class="attribute">Void</span> play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种解释深究一下，其实很容易发现其犯了本末倒置的错误：类是本，代码是末，只有清晰地掌握了类的概念，才能写出好的代码。否则，即使写出了代码，也是一堆烂代码。</p>
<p>那究竟何为类呢？<br>其实，抛开面向对象，抛开程序开发，即使在我们的现实世界中，类也是无处不在的：<br>古语云： 物以类聚，人以群分，这里的“类”，其实和面向对象中的“类”的逻辑含义并无不同。<br>我们的生物学将生物分为动物、植物、微生物等种类，这里的“类”，和面向对象中的类概念也是一致的。<br>因此，当我们在定义什么才是“类”的时候，其实完全不需要和面向对象扯上关系。简单来说，类就是一组相似事物的统称。<br>这个定义看起来再简单不过了，但为了避免在实践过程中设计不合理的类，我们还要深挖背后的玄机，玄机在哪里呢？</p>
<p>玄机就在定义里面，我们来认真分析一下定义：<br>首先：请看“一组”，思考一下为什么是“一组”，不是“一个”？<br>其次：请看“相似”，思考一下为什么是“相似”，不是“相同”？<br>最后：请看“统称”，思考一下为什么是“统称”，不是“名称”？<br>第一个玄机——“一组”：一组的玄机在于“多个“，单个事物无法成为类。<br>一个很简单的例子：“人“可以是一类，但“我”就不是一个类（那又是什么呢，请看后文分解？）<br>第二个玄机——“相似”：相似的玄机在于“比较像，但不完全相同”。<br>还是“人”这个例子：奥巴马和克林顿都是美国总统，都是人，有很多相似的地方，但他们两个绝对不是完全相同的。<br>第三个玄机——“统称”：统称的玄机在于“统”，也可以叫做“通称”，统称要能够概括这多个事物。<br>还是上一个例子：奥巴马和克林顿的统称可以为“人”、“男人”、“总统”，但不会统称为“奥巴马”，因为奥巴马是一个具体的人了。<br>类的定义玄机我们已经基本解读，看起来已经比较清晰了，但不要高兴太早，还有一个更大的玄机：我们怎么划分类？</p>
<p>一个很简单的问题：你和我是一类么？<br>。。。应该是：）<br>再一个简单的问题：你和猪是一类么？<br>你肯定会跳起来：我怎么和猪是一类呢？<br>但我要说，我们和猪确实是一类，我们都是“哺乳动物“。<br>再一个简单的问题：你和松树是一类么？<br>这次你可能学乖了：也是一类，都是“生物“。<br>。。。。。。<br>到这里你可能已经迷惑了“到底我和什么是一类“？<br>这个问题引出了类最重要的一个玄机：“如何定义类“？<br>其实答案就隐藏在我们前面的问题中：“只要有相似点的就是同一类“！<br>我和你都是一类，是因为我们都是“人“；<br>你和猪是一类，是因为都是“哺乳动物“；<br>你和树一类，是因为都是“生物“；<br>。。。。。。</p>
<p>但这样又引出另外一个问题：如果只要有相似点就是同一类，那么最后是不是只要用一个类“事物”或者“东西”就可以了呢，干嘛还用得着分那么多类么？<br>万法归一，所有的事物当然最后都可以归为一类（例如在Java中就有一个大一统的类Class），但这显然远远不能满足我们的要求，实际应用中我们肯定需要不同的、多种多样的类，那么具体如何操作呢？<br>有一句广告词可以很好的概括：角度决定看法！<br>也就是说：站在你的观察角度，能够看到相似点就是同一类！<br>当你观察人时，我和你是一类，但你和猪就不是一类了；<br>当你观察动物时，我、你、猪都是一类，但树就不是了；<br>当你观察生物时，我、你、猪、树都是一类<br>。。。。。。。<br><strong>所以最后我们总结一下如何划分类：站在你的观察角度，具有相似点的事物就是同一类！</strong></p>
<h1 id="第七章-“对象”新解"><a href="#第七章-“对象”新解" class="headerlink" title="第七章 “对象”新解"></a>第七章 “对象”新解</h1><p>有了“类”的清晰定义后，“对象”就比较容易理解了。<br><strong>对象就是一个具体的类，一个真实存在的类。</strong><br>前面我们提到面向对象是对现实世界的模拟，那么对象就是现实世界中存在的“物体”。</p>
<p>例如，“人”是一个类，我就是一个“人”的对象，你也是“人”的对象，奥巴马也是“人”的对象。。。。。。<br>又比如：你去国美买冰箱，但国美肯定没有一个单独叫做“冰箱”的东西卖给你，而是具体的某台海尔XX型号的冰箱、西门子XX型号的冰箱等。这里的“冰箱”就是一个类，而具体的“某台海尔XX型号冰箱”、“某台西门子XX型号冰箱”就是一个具体的对象。</p>
<p>但是，我们要继续深究一下：有了类，为什么还会有对象？“类”和“对象”各自的作用是什么？</p>
<p>我们知道，在人类出现以前，世界上就有各种各样的物体了，有恐龙、老虎、鳄鱼、松树、青草、石头、空气。。。。。等等，也就是说，真实存在的是对象，而“类”，是有了人类文明后，根据观察分析，加以归纳总结而的出来的。</p>
<p>在软件世界也是这样的，真正存在于软件运行过程中的是“对象”，而不是“类”，“类”只是在程序编写中由程序员分析归纳出来的。这也是面向对象之所以叫做“面向对象”而不是“面向类”的一个原因吧。</p>
<p>虽然我们前面定义对象为“一个具体的类”，但这是否意味着必须是先有类后有对象呢？<br>要回答这个问题，我们首先要澄清几个概念：现实对象、现实类、软件对象、软件类。</p>
<p>现实对象：你能看到的物体都可以称为现实对象；<br>现实类：对现实对象的归纳总结；<br>软件对象：软件实际运行过程中存在的对象；<br>软件类：软件设计过程中归纳总结出来的类；</p>
<p>定义看起来很简单，但它们的区别和联系是什么呢？<br>如下图示清晰的描述了它们之间的关系：<br> <img src="http://upload-images.jianshu.io/upload_images/1985459-dc0ec487c639e2a4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>也就是说，首先是存在现实对象，然后人们根据自己的观察角度和要求将现实对象抽象成现实类，然后软件设计人员基于现实类模拟出软件类，最后在程序中将软件类实例化成软件对象，最终的程序就是软件对象的活动和交互。</p>
<p>那这样是否意味着只有你能够看见、能够感知的对象才能抽象为类呢？<br>对于现实类和现实对象来说，可以说确实是这样的；但对于软件类和软件对象并不完全是这样的。<br>有一句名言叫做“电影来源于生活，但高于生活”，用在面向对象领域中就是“软件类来源于现实类，但高于现实类”，为什么这么说呢？</p>
<p>首先，现实类在软件类中必须有对应，但并不是完全一 一对应的，有的时候需要将现实类拆成几个软件类。<br>例如：比如说ATM机是现实世界真实存在的类，但在做软件设计的时候，可能将ATM机拆分为“ATM认证”、“ATM打印”、“ATM取款”等几个软件类，这些软件类互相配合，最后完成现实世界的ATM机器的功能。</p>
<p>其次：软件类并不一定是现实存在的<br>例如：策略（Strategy）是一个人的概念，但并不是你可以看见或者感知到的；但在软件领域中，这是一个很常见的类</p>
<p>也就是说，软件类是对现实类的模拟，但并不简单的等同，除了实现现实类相对应的功能外，我们还会创造出许多现实中并不存在的类，而这个创造过程，正是各种设计方法、设计模式、设计原则大显身手的地方。</p>
<p>当你创造出各种各样、丰富多彩的对象后，各种对象开始发挥自己的功能，并且相互作用，相互影响，软件世界就开始运作起来，呈现出多姿多彩的功能和作用，整个软件世界都处于你的控制之下，你甚至只需小小的修改几行代码，整个软件就可能呈现完全不同的功能。</p>
<p><strong>你，就是软件世界的上帝！</strong></p>
<p>一个简单的对象实例如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style="font-size:14px;"&gt;package com.oo.demo;  </span><br><span class="line">  </span><br><span class="line">public class Tester &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        // 奥巴马是一个“人”的对象  </span><br><span class="line">        Person obama = new Person();  </span><br><span class="line">        obama.setName("Obama");  </span><br><span class="line">        obama.playBasketball();  </span><br><span class="line">          </span><br><span class="line">        System.out.println();  </span><br><span class="line">          </span><br><span class="line">       // 我也是一个“人”的对象  </span><br><span class="line">        Person me = new Person();  </span><br><span class="line">        me.setName("Yunhua Lee");  </span><br><span class="line">        me.playFootball();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="第八章-“接口”-详解"><a href="#第八章-“接口”-详解" class="headerlink" title="第八章 “接口” 详解"></a>第八章 “接口” 详解</h1><p>“<strong>接口”是我见过的面向对象领域中滥用、乱用、误用最多的术语</strong>：<br>有的人说：兄弟，给我提供一个“查询XXX”的接口。。。。。。<br>有的人说：系统对外提供了“查询”、“插入”、“更新”、“删除”4个接口。。。。。。<br>有的人说：我们要基于“接口”编程。。。。。。<br>有的人说：你这样做破坏了我们的接口设计。。。。。。<br>。。。。。。。。。。。<br>倒不是在这里指责他们的水平有多差，而是接口这个属于的中文翻译确实难以理解。<br>台湾译为介面，仲介之面的意思；大陆译作界面，也译作接口，但无论是“界面”、“介面”、“仲介之面”还是“接口”，都远远没有“类”、“对象”那么直白和容易理解。</p>
<p>既然中文很难理解，那么我们从英文入手，看看是否会有什么新的发现。<br>“接口”英文为“interface”，按照英文的方法将其拆开，其实就是“inter – face”，也就是说其包含两层意思：<br><strong>【Inter】： 互相，与互相对应的是单个、多个，为什么这里要强调2个呢？</strong><br>首先，“单个”不存在交互，你自己玩自己的，别人管不了，也就没法交互了；<br>其次，“多个”交互就混乱了，比如说，假设一个USB接口能够同时接鼠标和键盘，那么怎么知道收到的信号时谁发出的，发出的信号又是要发给谁呢？</p>
<p>【Face】：面，与面对应的是点、线，这里为什么要强调“面”呢？<br> 首先，“面”很形象，围着你的电脑看一下，USB接口、网络接口、VGA接口，形状是不是都是“面”？<br>其次，“面”体现了功能的多样性。即：接口包含多个“功能点”，例如：USB接口有输入功能、输出功能、充电功能，这三个功能都是USB接口具备的，而不是三个接口。</p>
<p>基于上述分析，我们可以给接口下一个清晰和容易理解的定义：接口是一组相关的交互功能点定义的集合。<br>这个定义的三个关键点详细解析一下：<br><strong>【相关】</strong><br>接口中包含的功能点是相关的，而不是一堆无关功能的堆砌。<br>例如USB接口，你见过既支持USB协议、又支持VGA协议、还支持PS/2的接口么？</p>
<p><strong>【交互】</strong><br>接口是用于不同物体交互，如果只是自己玩，那么就不能成为接口；</p>
<p><strong>【定义】</strong><br>接口中的功能点只是定义，并不涉及具体实现。<br>也就是说，接口是一个交互协议，是交互双方的一个约定，但具体如何实现，由具体的交互实体各自实现即可。<br>就像USB接口，张三可以接鼠标、李四可以接键盘、王五可以接散热风扇，但无论是鼠标、键盘还是风扇，都必须遵循USB接口的协议标准。</p>
<p><strong>【集合】</strong><br>接口是多个功能点的集合，而不是一个具体的功能点。</p>
<p>但如果你说要我重新将interface翻译成简单易理解的中文，恕我才能不够，我也没法翻译。</p>
<p>回过头来看本章前面提到的关于接口的不同说法：<br>有的人说：兄弟，给我提供一个“查询XXX”的接口——这里说的是一个功能<br>有的人说：系统对外提供了“查询”、“插入”、“更新”、“删除”4个接口——这里说的是多个功能，这些功能合起来才是一个完整的接口<br>有的人说：我们要基于“接口”编程——这个符合接口的定义<br>有的人说：你这样做破坏了我们的接口设计——这个可能符合接口的定义，也可能不符合，关键看这里的接口是指某个功能还是一组功能。</p>
<p><a href="http://lib.csdn.net/base/17" target="_blank" rel="external">Java</a>语言中的接口很好的展现了接口的含义：<br>IAnimal.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.oo.demo;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAnimal</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* </span><br><span class="line">     * Java的Interface很好的体现了我们前面分析的接口的特征： </span><br><span class="line">     * 1）是一组功能的集合，而不是一个功能 </span><br><span class="line">     * 2）接口的功能用于交互，所有的功能都是public，即别的对象可操作 </span><br><span class="line">     * 3）接口只定义函数，但不涉及函数实现 </span><br><span class="line">     * 4）这些功能是相关的，都是动物相关的功能，但光合作用就不适宜放到IAnimal里面了 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pig.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oo.demo;  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “猪”的类设计,实现了IAnnimal接口 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pig</span> <span class="keyword">implements</span> <span class="title">IAnimal</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//如下每个函数都需要详细实现  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"Pig like to eat grass"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"Pig run: front legs, back legs"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"Pig sleep 16 hours every day"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"Pig can not speak"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Person2.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oo.demo;  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 实现了IAnimal的“人”，有几点说明一下： </span><br><span class="line"> * 1）同样都实现了IAnimal的接口，但“人”和“猪”的实现不一样， </span><br><span class="line"> *    为了避免太多代码导致影响阅读，这里的代码简化成一行，但输出的内容不一样， </span><br><span class="line"> *    实际项目中同一接口的同一功能点，不同的类实现完全不一样 </span><br><span class="line"> * 2）这里同样是“人”这个类，但和前面介绍类时给的类“Person”完全不一样， </span><br><span class="line"> *    这是因为同样的逻辑概念，在不同的应用场景下，具备的属性和功能是完全不一样的 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person2</span> <span class="keyword">implements</span> <span class="title">IAnimal</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"Person like to eat meat"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"Person run: left leg, right leg"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"Person sleep 8 hours every dat"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"Hellow world, I am a person"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Tester03.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oo.demo;  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * <span class="doctag">@author</span> liyunhua </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester03</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"===This is a person==="</span>);  </span><br><span class="line">        IAnimal person = <span class="keyword">new</span> Person2();  </span><br><span class="line">        person.eat();  </span><br><span class="line">        person.run();  </span><br><span class="line">        person.sleep();  </span><br><span class="line">        person.speak();  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"\n===This is a pig==="</span>);  </span><br><span class="line">        IAnimal pig = <span class="keyword">new</span> Pig();  </span><br><span class="line">        pig.eat();  </span><br><span class="line">        pig.run();  </span><br><span class="line">        pig.sleep();  </span><br><span class="line">        pig.speak();  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有了类之后为什么还要有接口呢？我直接用类不行么？<br>例如，我想操作人的时候就用Person，我想操作猪的时候就用Pig</p>
<p>大部分情况下这样做是可以的，但有的时候，你可能并不知道你面对的是一个人还是一头猪，因为这个动物可能是别人创建的，或者是上帝创建的。你只知道这是个动物，但你又希望这个动物按照你的要求进行活动。这就是接口的用处所在，即：你不知道一个对象所属的具体“类”，只知道这些对象都具备某种功能</p>
<h1 id="第九章-“抽象类”-详解"><a href="#第九章-“抽象类”-详解" class="headerlink" title="第九章 “抽象类” 详解"></a>第九章 “抽象类” 详解</h1><p>抽象类是一种特殊的类，其特殊性在于<strong>抽象类只能用于继承，不能被实例化为具体的对象</strong>。例如在Java中不能new一个抽象类，但可以extends一个抽象类。</p>
<p>抽象类的定义其实很简单，但其使用并不那么简单，有几个问题我们需要深入研究一下。</p>
<p><strong>第一个问题是：有了类，为什么还要抽象类，为什么设计一种只能继承，不能实例化的类？</strong><br>答案就在于：某些场景下普通类不够用。例如，“苹果”、“桔子”、“香蕉”都是“水果”，这里的“水果”就是一个抽象类。你可以说你喜欢吃“水果”，但你真正吃“水果”的时候，要么是“苹果”，要么是“桔子”，要么是“香蕉”。。。。。。但你绝不可能真正吃到一个叫做“水果”的东东。</p>
<p>从设计的角度来看，抽象类是更高层次的抽象。如果说普通类是从现实对象抽象出来的，那么抽象类就是基于类而抽象出来的。例如上面的样例，从“苹果”、“桔子”、“香蕉”这几个普通类，抽象出了“水果”这个类。</p>
<p>从实现的角度来看，抽象类与普通类不同的地方在于：抽象类有的存在抽象方法（方法只有声明，没有定义），子类必须自己定义这些抽象方法，而不能像普通的方法一样，通过继承就可以获得父类的方法。这一点上来看，抽象类和接口有点类似。</p>
<p><strong>第二个问题是：抽象类和接口有什么区别，为什么有了接口，还要有抽象类？</strong><br>答案就在于：抽象类本质上还是类，强调一组事物的相似性，包括属性和方法的相似性；而接口只强调方法的相似性，并且仅仅体现在方法声明上的相似性，而没有方法定义上的相似性。</p>
<p>例如：假设我们设计一个游戏，其中使用“苹果”、“桔子”、“香蕉”来做“补血”，“苹果”、“桔子”、“香蕉”都有“颜色”、“重量”这样的属性，但每种水果的补血方式是不一样的。这种情况下，使用抽象类可以很好的表达，我们设计一个抽象类“水果”，将“颜色”、“重量”作为“水果”的属性，“获取颜色”、“获取重量”、“减少重量”等方法作为“水果”的方法，将“补血”作为“水果”的抽象方法。这样设计能够大大减少“苹果”、“桔子”、“香蕉”几个普通类的实现工作量，它们只需要实现“补血”方法，其它的属性和方法都只需继承“水果”类即可。而如果采用接口的方式实现，则“苹果”、“桔子”、“香蕉”每个类都需要自己增加“颜色”、“重量”属性，增加“获取颜色”、“获取重量”、“减少重量”、“补血”等方法，工作量和代码量大大增加。</p>
<p>综合上述的分析，我们可以看出，抽象类看起来是一个介于类和接口之间的一个概念，同时具备类和接口的部分特性。</p>
<h1 id="第十章-“抽象”-详解"><a href="#第十章-“抽象”-详解" class="headerlink" title="第十章 “抽象” 详解"></a>第十章 “抽象” 详解</h1><p>抽象的中文概念非常形象，简单来说就是“抽取出来比较像的部分”。</p>
<p>那么，在面向对象的领域里，抽取什么东西比较像的部分？</p>
<p>还记得前面给类下的定义么？我们一起来回顾一下：类就是一组相似事物的统称。<br>再结合我们对象的定义：对象就是一个具体的类，一个真实存在的类。<br>我们就很容易发现了抽象的详细含义：抽取多个对象或者类中比较像的部分。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/1985459-87f15627b00ad160?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>注：<br>史派克：《猫和老鼠》中的斗牛犬</p>
<p>这里的抽象分为两个层次：<br><strong>第一个层次：对象 抽象成 类。</strong><br>例如奥巴马和梅西抽象成“人”，这一层的抽象主要是将“属性类似”的对象抽取成类。<br>注意这里的属性类似是指属性类别一致，而属性的取值是不一样的。例如如果将“奥巴马”和“梅西”都抽象成“人”，那么其属性有身高、体重、性别、年龄等，但“奥巴马”和“梅西”的这些属性取值肯定是不同的。</p>
<p><strong>第二个层次（或更高层次）：将 类 抽象成超类</strong>（或者说父类，其实就是更高一级的类），<br>例如人和猪抽象成“动物”，这一层的抽象主要是将“行为类似”的类抽象成父类。<br>注意这里是“行为类似”，而不是第一层抽象的那样“属性类似”，因为在面向对象领域，行为一致的话就认为是同一类的，当然也不能是完全不同，完全不同的话就没有相似点，也就无法抽象成类了，所以这一层抽象的重点是“相似”。</p>
<p>实际应用中，抽象的层次是不限的，根据业务的需要，或者不同的观察角度，可以抽象出很多层。</p>
<p><strong>【抽象的作用】</strong><br>抽象并不是面向对象领域特有的概念和方法，在人类的科学研究中，抽象是再常见不过的技术了：生物学将猪马牛羊等生物抽象为“动物”，将花草树木等抽象为“植物”，医学将心肝脾肺肾抽象为“内脏”，化学将碳氢氧氮等抽象为“元素”，物理学上将地球、火星、水星等抽象为“行星”。。。。。。等等。</p>
<p>又比如我们的高中学习课程，也抽象出“语文、数学、物理、化学”等学科，我们的大学课程，又分为了几十上百个专业。</p>
<p>在人类的科学研究，以及日常生活和学习中，抽象最主要的作用是“划分类别”，而划分类别的主要目的其实还是“隔离关注点，降低复杂度”。因为这个世界太复杂了，复杂到一个人不可能同时关注所有的内容。心理学上的研究证实，人同时能关注的事务不超过 7+/-2个。可以想象，如果没有抽象分类，我们将面对一个混沌的世界，同时关注如此多的内容，即使是天才，估计也要崩溃。</p>
<p>在面向对象领域，抽象也不例外。抽象的主要作用也是划分类别，所以，<strong>抽象是面向对象领域里面发现类的主要方法</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/软件笔记/">软件笔记</a>
	</div>


      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面向对象/">面向对象</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
        var yiliaConfig = {
        fancybox: true,
        mathjax: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        open_in_new: false
        }
        </script>
     

  
    <article id="post-面向对象葵花宝典3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/11/面向对象葵花宝典3/" class="article-date">
  	<time datetime="2016-05-11T14:38:40.000Z" itemprop="datePublished">2016-05-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/11/面向对象葵花宝典3/">连载：面向对象葵花宝典：思想、技巧与实践(21-30章)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>无意间发现这篇文章，文章讲解由浅入深，读完后感触很深<br>特全文转到自己的博客，方便以后自己随时查看<br>文章转载自爱技术的华仔的博客[<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">http://blog.csdn.net/yunhua_lee</a>]<br>非常感谢<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">爱技术的华仔</a></p>
</blockquote>
<h1 id="第二十一章-SSD"><a href="#第二十一章-SSD" class="headerlink" title="第二十一章 SSD"></a>第二十一章 SSD</h1><p>用例图是用来描述系统的，而SSD（系统序列图）又是来描述用例的，oh my god，这不是在玩我们么？<img src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/crazy.gif" alt="抓狂"></p>
<p>System Sequence Diagram，缩写为SSD（注意不要与SSD硬盘混淆），中文翻译为“<strong>系统顺序图</strong>”，主要用于描述某个用例的某个分支场景下，外部参与者与系统的交互过程。简单来说：SSD就是用例的可视化描述。</p>
<p>细心的朋友可能会发现，前面我们在介绍“用例方法”的时候说不需要画图，这里又说SSD是用来描述用例的，这不是互相冲突了么？</p>
<p>事实上并不冲突，原因在于：用例方法分析需求的时候，确实不需要图；但用例方法分析完成后得到的用例，我们可以使用SSD让用例更直观一些。</p>
<p>SSD有几点需要特别注意：<br>1）SSD不是标准的UML图形：UML只有顺序图、用例图，但是没有一个专门的“系统顺序图”；之所以叫做“系统”顺序图，是因为这个顺序图中只有两类对象：系统、与系统交互的对象；<br>2）SSD是用来描述某个用例的某个分支，而不是描述系统的结构；<br>3）画SSD的时候，整个系统被当做一个黑盒，不涉及系统的分解；<br>4）不需要为每个用例每个分支都画一个SSD，挑出关键的用例和分支即可；</p>
<p>有的朋友可能会有疑问：如何知道哪些用例的哪些分支是关键的呢？</p>
<p>我的答案是：你认为是关键的你就画，你认为不是关键的你就不画；如果你认为所有的用例都很关键，那么所有的用例你都画即可，只要你不怕麻烦或者工作量太大；如果你认为所有的用例都很简单，那么一个都不画也可以。至于你的判断是否正确，主要靠经验积累，当经验不够的时候，也可以求助有经验的人。</p>
<p>以POS机为例，假如我们认为POS机的正常处理流程是关键分支，则对应的SSD如下：<br> <img src="http://upload-images.jianshu.io/upload_images/1985459-8395e443e4ac5871?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>仔细对照SSD和POS机的用例，我们会发现SSD和用例基本上是对应的，但并不完全对应，例如：<br>Ø 用例中第1步是“顾客携带选择好的商品到收银台”，但SSD中第1步是开始交易；<br>Ø 用例中“顾客将钱交给收银员”，但SSD中并没有对应的步骤；<br>Ø 用例中最后一步是“买单完成，顾客携带商品和小票离开”，但SSD中最后一步是“交易结束”；</p>
<p>为什么会出现这种不对应的情况呢？<br>主要原因在于：用例是整个业务的流程，而SSD是站在系统的角度来描述系统与外部对象的交互，这就需要我们在画SSD的时候做一些技巧性的处理：<br>Ø 删除系统无关的业务步骤<br>例如上述的“顾客将钱交给收银员”，这个步骤和POS机没有关系，因此无需体现，再说了，就算你想体现，你也体现不了；<br>Ø 将业务语言转换为系统语言<br>例如用例中是描述“顾客携带选择好的商品到收银台”，但对应系统来说，这就意味了“交易开始”；同样，“买单完成，顾客携带商品和小票离开”意味着“交易结束”。</p>
<p>有的朋友可能会认为，应该在用例分析的时候就应该详细写清楚。例如，“买单完成，顾客携带商品和小票离开，收银员告诉POS机交易结束”。<br>这种想法本身没错，但问题在于，理想和现实总是有差距的，用例不可能那么完善，甚至有的时候用例可能都存在错误，如果我们自己没有一定的分析和理解能力，完全依赖原始的用例，这样做是不可能设计出优秀的系统的，甚至连合格的系统都可能做不到。</p>
<p>综合上面的分析，我们可以看到，SSD虽然来源于用例，但还需要在用例的基础上稍微加工一下，使得SSD能够更加聚焦于“系统”这个主角。</p>
<p>最后小小吐槽一下：<strong>用例图是用来描述系统的，而SSD又是来描述用例的，oh my god，这不是在玩我们么？</strong></p>
<h1 id="第二十二章-领域模型"><a href="#第二十二章-领域模型" class="headerlink" title="第二十二章 领域模型"></a>第二十二章 领域模型</h1><p>领域模型是面向对象分析和设计的第一步！！</p>
<p>完成了需求分析之后，我们已经有了一个良好的开端，但我们的主角“面向对象”还不见踪影。<br>前面我们提到，需求分析和面向对象是没有直接关系的，需求分析阶段是不区分是面向对象还是面向过程，那么什么时候才真正开始面向对象的工作呢？</p>
<p>答案就在本章：<strong>领域建模</strong>。<br>从领域模型开始，我们就开始了面向对象的分析和设计过程，可以说，领域模型是完成从需求分析到面向对象设计的一座桥梁。</p>
<p>领域模型，顾名思义，就是需求所涉及的领域的一个建模，更通俗的讲法是业务模型。<br>参考百度百科（<a href="http://baike.baidu.cn/view/757895.htm" target="_blank" rel="external">http://baike.baidu.cn/view/757895.htm</a> ），领域模型定义如下：</p>
<blockquote>
<p>领域模型是对领域内的概念类或现实世界中对象的可视化表示，又称概念模型、领域对象模型、分析对象模型。它专注于分析问题领域本身，发掘重要的业务领域概念，并建立业务领域概念之间的关系。</p>
</blockquote>
<p>从这个定义我们可以看出，领域模型有两个主要的作用：<br>1）发掘重要的业务领域概念<br>2）建立业务领域概念之间的关系</p>
<p>【领域建模三字经】<br>领域模型如此重要，很多同学可能会认为领域建模很复杂，需要很高的技巧。然而事实上领域建模非常简单，简单得有点难以让人相信，领域建模的方法概括一下就是“找名词”！</p>
<p>许多同学看到这个方法后估计都会笑出来：太假了吧，这么简单，找个初中生都会啊，那我们公司那些分析师和设计师还有什么用哦？</p>
<p>分析师和设计师当然有用，后面我们会看到，即使是简单的找名词这样的操作，也涉及到分析和提炼，而不是简单的摘取出来就可，这种情况下分析师和设计师的经验和技能就能够派上用场了。但领域模型分析也确实相对简单，即使没有丰富的经验和高超的技巧，至少也能完成一个能用的领域模型。</p>
<p>虽然我们说“找名词”很简单，但一个关键的问题还没有说明：从哪里找？<br>如果你还记得领域模型是“需求到面向对象的桥梁”，那么你肯定一下子就能想到：从需求模型中找，具体来说就是从用例中找。</p>
<p>归纳一下域建模的方法就是“从用例中找名词”。<br>当然，找到名词后，为了能够更加符合面向对象的要求和特点，我们还需要对这些名词进一步完善，这就是接下来的步骤：加属性，连关系！</p>
<p>最后我们总结出领域建模的三字经方法：<strong>找名词、加属性、连关系</strong>。</p>
<p>欲知具体如何操作，请看下回分解</p>
<h1 id="第二十三章"><a href="#第二十三章" class="headerlink" title="第二十三章"></a>第二十三章</h1><p>看起来有点不可思议，需求阶段“白纸黑字”的用例文档，经过我们一步一步的操作，逐步就得到了“图形化”的领域模型，面向对象初具雏形。</p>
<p>领域建模的三字经方法：<strong>找名词、加属性、连关系</strong>。</p>
<p>我们接下来以一个样例看看领域模型具体如何建模。</p>
<h2 id="1-1-找名词"><a href="#1-1-找名词" class="headerlink" title="1.1 找名词"></a>1.1 找名词</h2><p>我们以POS机买单的用例来看看具体如何建领域模型。</p>
<p>首先，将用例中所有的名词挑选出来（如下用例文档中<strong>蓝色加粗</strong>的词组）：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">【用例名称】</span><br><span class="line">买单</span><br><span class="line">【场景】</span><br><span class="line">Who：*<span class="strong">*顾客、收银员*</span>*</span><br><span class="line">Where：商店的*<span class="strong">*收银台*</span>*</span><br><span class="line">When：营业时间</span><br><span class="line">【用例描述】</span><br><span class="line">1. *<span class="strong">*顾客*</span><span class="strong">*携带选择好的*</span><span class="strong">*商品*</span><span class="strong">*到收银台；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">2. 收银员逐一扫描商品*</span><span class="strong">*条形码*</span><span class="strong">*，系统根据条形码查询商品信息；</span><br><span class="line">2.1 *</span><span class="strong">*扫描仪*</span><span class="strong">*坏了，必须支持手工输入条形码；</span><br><span class="line">2.2 商品的*</span><span class="strong">*条形码*</span><span class="strong">*无法扫描，必须支持手工输入条形码；</span><br><span class="line">2.3 条形码能够扫描，但查询不到信息，需要收银员和顾客沟通，放弃购买此产品</span><br><span class="line">3. 扫描完毕，系统显示商品总额，收银员告诉顾客商品总额；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">4. 顾客将*</span><span class="strong">*钱*</span><span class="strong">*交给收银员；</span><br><span class="line">4.1 顾客的钱不够，顾客和收银员沟通，删除某商品；</span><br><span class="line">4.2 顾客的钱不够，顾客和收银员沟通，删除某类商品中的一个或几个（例如买了*</span><span class="strong">*5包烟*</span><span class="strong">*，去掉两包）</span><br><span class="line">4.3 顾客觉得某个商品价格太高，要求删除某商品；</span><br><span class="line">4-A：顾客使用*</span><span class="strong">*信用卡*</span><span class="strong">*支付</span><br><span class="line">4-A.1 信用卡支付流程（请读者自行思考完善，可以写在这里，如果太多，也可以另外写一个子用例）</span><br><span class="line">4-B：顾客使用*</span><span class="strong">*购物卡*</span><span class="strong">*支付</span><br><span class="line">        4-B.1 购物卡支付流程</span><br><span class="line">4-C：顾客使用*</span><span class="strong">*会员卡*</span><span class="strong">*积分支付</span><br><span class="line">        4-C.1 会员卡积分支付流程</span><br><span class="line">5. 收银员清点钱数，输入收到的款额，系统给出找零的数目；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">6. 收银员将找零的钱还给顾客，并打印*</span><span class="strong">*小票*</span><span class="strong">*；</span><br><span class="line">7. *</span><span class="strong">*买单*</span><span class="strong">*完成，顾客携带*</span><span class="strong">*商品*</span><span class="strong">*和*</span><span class="strong">*小票*</span><span class="strong">*离开；</span><br><span class="line">【用例价值】</span><br><span class="line">顾客买完单以后，就可以携带商品离开，而超市也将得到收入；</span><br><span class="line">【约束和限制】</span><br><span class="line">1. POS机必须符合国标XXX；</span><br><span class="line">2. 键盘和屏幕使用*</span><span class="strong">*中文*</span><span class="strong">*，因为收银员都是*</span><span class="strong">*中国人*</span><span class="strong">*；</span><br><span class="line">3. 一次买单数额不能超过99999RMB；</span><br><span class="line">4. POS机要非常稳定，至少一天内不要出现故障；</span></span><br></pre></td></tr></table></figure></p>
<p>名词列表：<br>顾客、收银员、收银台、商品、条形码、扫描仪、钱、5包烟、信用卡、会员卡、小票、买单、键盘、屏幕、中文、中国人</p>
<p>通过这种简单的方法，我们很轻松的就识别出了领域中的各种概念，但是还不能高兴的太早，识别领域概念的工作还没有结束，接下来我们还需要提炼。</p>
<p>有了前面步骤识别的名词列表后，提炼的工作就相对很简单了，只需要删除不是领域对象的名词即可。<br>但具体应该删除什么名词，是和不同的业务领域强相关的，并没有完全统一的标准，此时分析师的行业和领域经验起决定作用，而这也正是菜鸟和专家的区别。</p>
<p>以我们的收银机为例，提炼的过程如下：<br>1）删除“收银台”：收银台只是一个物理设备，且这个设备与我们的POS机也没有任何交互，所以不能算作领域模型中的一个概念；<br>2）删除“5包烟”：5包烟只是用例中举例时的一个实例，是一个具体的商品，已经包含在“商品”中了；<br>3）删除“中文”：“中文”只是“键盘”和“屏幕”的一个属性，并不是一个独立的领域概念；<br>4）删除“中国人”：“中国人”只是“收银员”的一个属性，并不是一个独立的领域概念；<br>5）删除“条形码”：“条形码”只是“商品”的一个属性，并不是一个独立的领域概念；</p>
<p>经过上面的提炼步骤后，就得到了真正的POS机领域类，详细如下：<br><strong>顾客、收银员、商品、扫描仪、钱、信用卡、会员卡、小票、买单、键盘、屏幕</strong></p>
<h2 id="1-2-加属性"><a href="#1-2-加属性" class="headerlink" title="1.2. 加属性"></a>1.2. 加属性</h2><p>找出领域模型的名词后，接下来一个重要工作就是将这些名词相关的属性找出来，使其更加准确。</p>
<p>但加属性和前面找名词有一点点差别：有的属性并没有在用例中明确给出，需要分析人员和设计人员额外添加，此时也是分析师的行业和领域经验起决定作用。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名词</th>
<th style="text-align:center">属性</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">顾客</td>
<td style="text-align:center">NA</td>
<td style="text-align:center">对于POS机来说，并不需要识别顾客的相关信息，因此在领域模型中，顾客是没有属性的</td>
</tr>
<tr>
<td style="text-align:center">收银员</td>
<td style="text-align:center">国籍、编号</td>
<td style="text-align:center">“国籍”由找名词步骤中的“中国人”提炼</td>
</tr>
<tr>
<td style="text-align:center">商品</td>
<td style="text-align:center">条形码、名称、价格</td>
<td style="text-align:center">名称和价格并没有在用例中体现，但毫无疑问这是商品最基本的属性</td>
</tr>
<tr>
<td style="text-align:center">扫描仪</td>
<td style="text-align:center">NA</td>
<td style="text-align:center">扫描仪是POS机的一个输入设备，POS机不需要识别扫描仪的相关信息，因此在领域模型中，扫描仪也是没有属性的</td>
</tr>
<tr>
<td style="text-align:center">钱（现金）</td>
<td style="text-align:center">数量，币别</td>
<td style="text-align:center">从领域分析的角度来讲，“现金”更专业一些</td>
</tr>
<tr>
<td style="text-align:center">信用卡</td>
<td style="text-align:center">卡号</td>
<td style="text-align:center">NA</td>
</tr>
<tr>
<td style="text-align:center">会员卡</td>
<td style="text-align:center">会员号、积分、有效期</td>
<td style="text-align:center">NA</td>
</tr>
<tr>
<td style="text-align:center">小票</td>
<td style="text-align:center">交易信息、POS机信息、收银员信息</td>
<td style="text-align:center">小票的属性在用例中并没有详细体现，但有经验的分析师能够很容易识别出来</td>
</tr>
<tr>
<td style="text-align:center">买单（交易）</td>
<td style="text-align:center">商品列表、日期时间、总额、支付信息</td>
<td style="text-align:center">这里的属性看起来和“小票”一样，是因为“小票”本质上是给客户的一个交易记录。这里为了更加符合软件系统的属于习惯，可以将“买单“改为“交易”。</td>
</tr>
<tr>
<td style="text-align:center">键盘</td>
<td style="text-align:center">NA</td>
<td style="text-align:center">和扫描仪类似，POS机不需要识别键盘信息</td>
</tr>
<tr>
<td style="text-align:center">屏幕</td>
<td style="text-align:center">NA</td>
<td style="text-align:center">和扫描仪类似，POS机不需要识别屏幕信息</td>
</tr>
</tbody>
</table>
<h2 id="1-3-连关系"><a href="#1-3-连关系" class="headerlink" title="1.3. 连关系"></a>1.3. 连关系</h2><p>有了类，也有了属性，接下来自然就是找出它们的关系了。</p>
<p>有了前面的工作，看起来连关系自然也是睡到渠成的事情，但不要忘了我们的这个例子是非常简单的，在一些复杂的系统中，领域模型之间的关系并不那么明显，菜鸟可能就只能看到最显而易见的一些联系，而系统分析师和设计师可以凭着丰富的经验、良好的技巧识别出来，这也是系统分析师和设计师的价值所在。</p>
<p>POS机的领域类关系如下（仅供参考，并不要求每个分析师和设计师都一定是这么理解，但总体来说应该相似）：<br>  <img src="http://upload-images.jianshu.io/upload_images/1985459-46215f9e8a1ea2e8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>看起来有点不可思议，需求阶段白纸黑字的用例文档，经过我们一步一步的操作，最后得到了图形化的领域模型。<br>只要曾经画过甚至只是看过UML类图的同学都应该很容易发现，领域模型和设计类图非常相似，面向对象终于有了雏形了</p>
<h1 id="第二十四章"><a href="#第二十四章" class="headerlink" title="第二十四章"></a>第二十四章</h1><p>完成领域类到软件类的转换，这就是面向对象领域设计阶段的主要任务。</p>
<p>经过领域模型的分析后，面向对象已经初具雏形，但领域类并不能指导我们进行编码工作，因为领域类只是从用例模型中提炼出来的反应业务领域的概念，而并不是真正意义上的软件类。</p>
<p>“革命尚未成功，同志还需努力”，我们需要再进一步，完成<strong>领域类到软件类的转换</strong>，这就是面向对象领域设计阶段的主要任务。</p>
<p>设计阶段是整个面向对象分析和设计的高潮阶段。在设计阶段中，我们将要输出设计模型，并且需要综合各种方法、技巧，运用十八般武艺，使出浑身解数，以求能够设计出满足各种需要的设计方案。</p>
<p>这也是最考验设计师功力的时候，因为设计并没有一个量化的标准，也没有一个标准答案，更多的时候需要设计师综合知识、技能、经验、灵感等因素，综合权衡而得出一个方案。世界上找不到两片相同的叶子，同样，你也找不到两个完全一样的设计方案。毫不夸张的说，面向对象的设计更多时候是一项艺术。</p>
<p>虽然我们说面向对象设计是一门艺术，但这并不意味着只有天才才能进行面向对象设计，面向对象设计也是有一定的规律和方法可寻的，我们将在接下来的章节逐一介绍。</p>
<p>【设计模型总览】<br>设计模型主要包含2部分内容：<strong>静态模型、动态模型</strong>，任何一个模型的缺失或者不完善，都将导致最终的设计质量不高，甚至可能导致最终的系统没有实现业务需求。</p>
<p>静态模型又可以称为“类模型”，主要关注系统的“静态”结构，描述了系统包含的类， 以及类的名称、职责、属性、方法，类与类之间的关系。<br>动态模型关注系统的“动态”行为，描述类本身的一些动作或者状态变化，以及类之间如何配合以完成最终的业务功能。只有结合静态模型和动态模型，我们才能够真正的将一个系统描述清楚。</p>
<p>静态模型和动态模型对于后续的编码也具有不同的指导意义。静态模型主要用于指导类的声明，包括类名称，属性名，方法名；而动态模型主要用于指导类的实现，主要就是每个方法内部的具体实现。</p>
<h1 id="第二十五章"><a href="#第二十五章" class="headerlink" title="第二十五章"></a>第二十五章</h1><p>面向对象设计和弹吉他差不多，有很多成熟的理论和技巧，学会弹吉他并不难，你只需要应用这些理论和技巧即可！</p>
<p><strong>【师傅领进门，修行在个人】</strong><br>“类模型”是整个面向对象设计模型的核心，是面向对象设计阶段的主要输出，也是设计师们最能够发挥自己才能的地方。</p>
<p>虽然“类模型”如此重要，但面向对象设计技术经过几十年的发展后，目前已经形成了很成熟的一套体系，因此真正在进行“类模型”设计的时候，其实难度并不高，这也是多亏了众多前辈们的无私贡献，才能使得我们这些芸芸众生也能轻松掌握这些原本带有艺术色彩的技能。</p>
<p>不过话又说回来了，入门容易精通难，“类模型”的设计也是如此，虽然有前辈们各种各样的思想结晶指导着我们，但毕竟如何理解、如何应用这些思想结晶，还是要看个人的领悟力和把握力。就像同样的《葵花宝典》，岳不群看了创立了气宗，蔡子峰看了创立了剑宗，渡元禅师听了后悟出了辟邪剑法，东方不败看了竟然练出了绣花针绝技！所以接下来的内容，也只是“师父领进门，修行在个人”，如果希望做出优秀的设计，更多还是依靠个人的领悟和实践！</p>
<p><strong>【设计的魔法崇拜】</strong><br>面向对象类的设计很多时候都蒙上了一层神秘的面纱。一个常见的场景是：“设计师”拿到需求后，经过一段时间的设计，感觉就像变戏法一样，然后就拿出了一个类模型。普通的开发人员看到这样的类模型，很难想象如何从需求才能够得到了这些类，由于大部分公司的设计人员确实也都是公司里面的牛人，因此大家就自然而然地认为这是水平和创造力的表现，心底不由得产生由衷的赞叹：“牛逼啊！”</p>
<p>我称这种现象为设计的“魔法崇拜”，具体表现就是认为设计是一种魔法，做设计的人是魔法师，只有牛逼的人才能够做设计。</p>
<p>但这种认识并不准确，就像我们前面提到的，面向对象领域已经发展了几十年，各种思想、理论都已经基本成熟，绝大部分人在做设计的时候，都不可能有什么天才的创新或者天才的灵感，而只是这些已经成熟的思想和理论的应用而已。</p>
<p>之所以现在还会出现这种现象，主要原因还是在于各种思想、理论、方法都是针对具体问题的分析或者总结，但并没有谁明确的将这些东东形成一套完整的面向对象设计体系。</p>
<p>可能很多人都有这种感觉：面向对象我也懂，设计模式我也知道，设计原则我也明白，但真的要进行设计的时候，就不知道如何下手了，比如说：<br>对象从哪里来？<br>什么时候用设计模式？<br>如何判断设计是否正确？<br>什么样的设计才是优秀的设计？<br>。。。。。。。。。。。</p>
<p>正因为存在这样的原因，我们自然会对那些能够设计出完整的类模型的设计师们刮目相看了。</p>
<p>其实面向对象设计并不是什么高深的技术，也不需要天才的创新，更不需要变魔法，而是有章可循的，只要我们按照一定的步骤，一步一个脚印，不断精益求精，就能够完成面向对象的设计。</p>
<p>但正如前面提到的一样，面向对象设计更多的时候是一门艺术。虽然我们按照一定的步骤能够完成面向对象的设计，但在这些步骤实施的过程中，如何应用相关技术，如何做出设计选择等，更多时候是带有艺术色彩的。就像很多人都会弹吉他，但真正的吉他大师弹出来的感觉，肯定和一个普通人弹的不一样。</p>
<p>接下来我们将会分几个小节讲述如何进行面向对象的类设计：</p>
<p>第一步（照猫画虎）：领域类映射 — 告诉你类从哪里来<br>第二步（精雕细琢）：应用设计原则和设计模式   —告诉你如何设计“好”类<br>第三步（照本宣科）：拆分辅助类   —告诉你如何和你的开发框架结合起来</p>
<h1 id="第二十六章"><a href="#第二十六章" class="headerlink" title="第二十六章"></a>第二十六章</h1><p><strong>类模型设计其实就是程咬金打天下 – 三板斧 而已 ：）</strong></p>
<hr>
<h2 id="第一斧（照猫画虎）：领域类映射"><a href="#第一斧（照猫画虎）：领域类映射" class="headerlink" title="第一斧（照猫画虎）：领域类映射"></a><strong>第一斧（照猫画虎）：领域类映射</strong></h2><p>面向对象类设计首先要解决的一个问题是：类从哪里来 ？</p>
<p>有的人可能会认为，要发挥想象力、创造力。。。。。等各种“力”——这种方法的主要问题是：我们不是在进行纯粹的艺术创造，而是要最终满足客户需求，而不能天马行空。</p>
<p>有的人可能会想到，参考其它的系统吧，把类似系统拿过来改吧改吧 ——这种方法的主要问题是：如果没有其它类似系统给你参考呢 ？还有的人干脆就说：拍脑袋吧，凭感觉吧 —— 这种方法的主要问题是：猴子能敲出莎士比亚全集么 ？看起来以上方法都不太可行，那究竟如何才能从哪里找到我们需要的类呢？</p>
<p>相信绝大部分认真看书的同学都会灵光一闪：领域模型。我们将上一章中的领域模型图拿出来，重新再看一下：<img src="http://img.blog.csdn.net/20140415094916296" alt="">相信不用我多说，绝大部分同学一眼就能看出：哇塞，这不就是类么？</p>
<p>确实是这样的，<strong>领域模型中的“领域类”，是设计模型中“软件类”最好的来源</strong>。通过“领域类”来启发我们设计最初的“软件类”，具有如下几个明显的<strong>优点</strong>：1）软件类来自领域类，领域类来自用例，用例来自客户，这样一环扣一环，软件类的正确性得到了保证，不用担心拍脑袋带来的问题；2）领域类到软件类的转换非常简单，不需要天才的创新，或者丰富的想象力，只要掌握基本的面向对象的知识就能完成，菜鸟也能做设计；3）不需要参考其它系统，不用担心没有参照物时无法设计的问题；从领域类到软件类的转换操作非常简单，基本上就是一个照猫画虎的过程。</p>
<p><strong>【类筛选】</strong>虽然我们说从领域类到软件类是一个照猫画虎的过程，但并不意味着将领域类全盘拷贝过来即可。主要的原因在于“软件类”是软件系统内部的一个概念，而领域类是业务领域的概念，并不是每个领域类最终都会体现在软件系统中。以POS机的领域类为例，领域类“顾客”不需要转换为软件类，因为顾客是POS机业务领域的一个重要参与者，但并不是POS机内部需要实现的一个实体，在POS机业务中，顾客甚至都不是和POS机直接交互的实体，站在POS软件系统的角度来说，顾客和POS机其实没有任何关系。对于屏幕、键盘、扫描仪这些输入输出设备，一般情况下我们认为它们是POS机系统硬件的一部分，而并不是POS机软件系统的一部分。但假如POS机有一个需求是既支持图形界面输出，又支持字符界面输出，那么POS的软件系统就需要处理这种和屏幕相关的需求了，此时屏幕就是POS机软件系统的一部分了，需要将领域类转换为软件类。为了简单处理，接下来的分析中，输入输出设备不做转换。经过筛选后，剩下的领域类就需要都转换为软件类，具体如下：收银员、商品、交易、小票、支付、信用卡、会员卡、现金、购物卡。</p>
<p><strong>【名称映射】</strong>筛选完成后，我们开始讲领域类转换为软件类，转换的方法很简单，首先不管三七二十一，将每个领域类都用一个软件类与对应，名称都保持一样即可。有的同学可能担心这样设计是否会不符合面向对象设计的要求，是否会导致设计质量不高。。。。。。等等，其实这种担心是多余的，因为我们后续还有很多工作要做，目前做的只是一个开始工作。</p>
<p><strong>【属性映射】</strong>通过名称映射的方法得到软件类后，接下来就是要设计类的属性了。由于领域类中也已经有了属性，因此我们也只需简单的照搬过来即可。</p>
<p><strong>【提炼方法】</strong>软件类的属性设计完成后，接下来就需要设计软件类的方法了。但这次我们就没有那么好的运气了，因为领域类中并没有方法！因此我们不能通过简单映射的方法来获取方法，必须采取其它手段。和类的设计一样，类方法的设计同样不能采取“创造力、参考其它系统、拍脑袋”等方式来完成，为了确保正确性，类的方法设计也同样应该能够从已有的模型中推导出来。由于已经明确领域模型中没有方法了，因此就不能从领域模型中得到软件类的方法，剩余只有一个“用例模型”了，因此我们锁定“用例模型”，看看如何从中找到我们所需要的方法。其实方法也很简单，概括一下就是：<strong>找动词</strong>。你可能不敢相信自己的眼睛，这么简单，那几乎初中生都会做设计啊，找动词谁不会呢？然而不管你信不信，这一步确实是这么简单，当然，如果面向对象设计只是到此为止，那确实初中生也是可以做的，但实际上这只是面向对象类设计的开始步骤而已，后面的工作还多着了，所以完全不用担心初中生来抢你的饭碗。我们以POS机为例，来看看如何通过“找动词”这种技巧来找到软件类的方法。如下是POS机的用例，我们将相关动词都<strong>加粗</strong>显示：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">【用例名称】</span><br><span class="line">买单</span><br><span class="line">【场景】</span><br><span class="line">Who：顾客、收银员</span><br><span class="line">Where：商店的收银台</span><br><span class="line">When：营业时间</span><br><span class="line">【用例描述】</span><br><span class="line">1. 顾客*<span class="strong">*携带*</span><span class="strong">*选择好的商品到收银台；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">2. 收银员逐一*</span><span class="strong">*扫描*</span><span class="strong">*商品条形码，系统根据条形码*</span><span class="strong">*查询*</span><span class="strong">*商品信息；</span><br><span class="line">2.1 扫描仪坏了，必须支持*</span><span class="strong">*手工输入*</span><span class="strong">*条形码；</span><br><span class="line">2.2 商品的条形码无法扫描，必须支持*</span><span class="strong">*手工输入*</span><span class="strong">*条形码；</span><br><span class="line">2.3 条形码能够扫描，但查询不到信息，需要收银员和顾客*</span><span class="strong">*沟通*</span><span class="strong">*，放弃购买此产品</span><br><span class="line">3. 扫描完毕，系统*</span><span class="strong">*显示*</span><span class="strong">*商品总额，收银员*</span><span class="strong">*告诉*</span><span class="strong">*顾客商品总额；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">4. 顾客将钱*</span><span class="strong">*交给*</span><span class="strong">*收银员；</span><br><span class="line">4.1 顾客的钱不够，顾客和收银员沟通，*</span><span class="strong">*删除*</span><span class="strong">*某商品；</span><br><span class="line">4.2 顾客的钱不够，顾客和收银员沟通，*</span><span class="strong">*删除*</span><span class="strong">*某类商品中的一个或几个（例如买了5包烟，去掉两包）</span><br><span class="line">4.3 顾客觉得某个商品价格太高，要求*</span><span class="strong">*删除*</span><span class="strong">*某商品；</span><br><span class="line">4-A：顾客使用信用卡*</span><span class="strong">*支付*</span>*</span><br><span class="line">4-A.1 信用卡支付流程（请读者自行思考完善，可以写在这里，如果太多，也可以另外写一个子用例）</span><br><span class="line">4-B：顾客使用购物卡*<span class="strong">*支付*</span>*</span><br><span class="line">        4-B.1 购物卡支付流程</span><br><span class="line">4-C：顾客使用会员卡积分*<span class="strong">*支付*</span>*</span><br><span class="line">        4-C.1 会员卡积分支付流程</span><br><span class="line">5. 收银员*<span class="strong">*清点*</span><span class="strong">*钱数，*</span><span class="strong">*输入*</span><span class="strong">*收到的款额，系统*</span><span class="strong">*给出找零*</span><span class="strong">*的数目；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">6. 收银员将找零的钱还给顾客，并*</span><span class="strong">*打印*</span><span class="strong">*小票；</span><br><span class="line">7. 买单完成，顾客*</span><span class="strong">*携带*</span><span class="strong">*商品和小票*</span><span class="strong">*离开*</span><span class="strong">*；</span><br><span class="line">【用例价值】</span><br><span class="line">顾客买完单以后，就可以携带商品离开，而超市也将得到收入；</span><br><span class="line">【约束和限制】</span><br><span class="line">1. POS机必须符合国标XXX；</span><br><span class="line">2. 键盘使用中文，因为收银员都是中国人；</span><br><span class="line">3. 一次买单数额不能超过99999RMB；</span><br><span class="line">4. POS机要非常稳定，至少一天内不要出现故障；</span></span><br></pre></td></tr></table></figure></p>
<p>标识出所有的动词后，还需要进一步的工作：<br>【筛选】并不是所有的动词都一定是软件类的方法，我们需要将这些动词识别出来并排除在后续设计范围之外。<br>例如：“顾客携带选择好的商品到收银台”：这里的“携带”是顾客的一个动作，而顾客并不是我们的软件类；“收银员告诉顾客商品总额”：这里的“告诉”确实是收银员的一个动作，而且“收银员”确实也是我们的软件类，但这里也要排除“告诉”，因为“告诉”这个动作和POS系统并没有关系，只是业务流程中的一个步骤而已。其它需要排除的动词还有：“需要收银员和顾客沟通”、“顾客将钱交给收银员”、“收银员清点钱数”、“收银员将找零的钱还给顾客”、“顾客携带商品和小票离开”<br>【提炼】筛选完不需要的动词后，剩下的就是我们需要的动词了，但此时并不能简单的将所有动词拿出来直接扔给某个软件类就行了，我们还需要进行一些加工。</p>
<p>继续以POS机为例：“收银员逐一扫描商品条形码”：这里的“扫描”看起来是“收银员”的一个动作，而且“收银员”确实也是我们的软件类，但其实深究一下，“扫描”这个动词并不能分配给“收银员”这个软件类，因为真正执行“扫描”功能的是“扫描仪”，收银员只是拿着扫描仪扫描商品，并不是收银员自己去读取商品条形码；类似的动词还有“必须支持手工输入条形码”，也不能算作“收银员”的功能。</p>
<p>那我们为什么不排除这两个动词呢？秘密就在于我们要从这两个动词提炼出软件类的方法。稍作分析，我们就可以发现，无论是“扫描条形码”，还是“手工输入条形码”，其实最终的目的都是“添加本次交易的商品”，因此我们可以提炼出“增加交易商品”的动词。</p>
<p>还有一种提炼的方法需要从已有的动词中推断出来，例如：“扫描完毕，系统显示商品总额”，这里只提到了“显示”这个动词，但相信大部分人都能一眼看出，“显示”之前肯定要“计算”，不然显示出来的值从哪里来呢？</p>
<p>有的朋友可能会疑惑，为什么不在用例的时候就写清楚呢？例如：扫描完毕，系统计算商品总额，然后系统显示商品总额。这样不就一目了然的看出来了么？</p>
<p>理想情况下这种想法当然没错，但现实往往没有那么美好，写用例的产品人员可能经验不足，也可能表达能力有限，还有可能比较马虎，或者遗漏了。。。。。。总之会有很多异常情况，因此设计人员必须具备这样的推断和判断能力。</p>
<p>经过这一步骤后，我们获得的动词如下：</p>
<ul>
<li>增加商品</li>
<li>计算商品总额</li>
<li>显示商品总额</li>
<li>删除商品</li>
<li>现金支付</li>
<li>信用卡支付</li>
<li>购物卡支付</li>
<li>会员卡积分支付</li>
<li>打印小票<br>当然，以上列出来的动词并不是就一定是100%的标准答案，不同的人来进行分析和设计，可能略有不同，但总体应该比较相似，毕竟业务是一样的，而业务需求就是设计最强的约束。<br>【分配】<br>识别出有效的动词后，最有一步就是分配了，即：将从用例中提炼出来的动词，分配给已经有了属性的软件类。这种分配操作很多时候都是按图索骥，特别是对于有领域经验的人来说，基本上凭直觉就能基本分配正确。当然，如果你的经验并不是很丰富，那么还是老老实实的一个一个来分析吧。<br>以POS机为例：</li>
<li>增加商品：很明显应该分配给“交易”类</li>
<li>计算商品总额：分配给“交易”类</li>
<li>显示商品总额：分配给“交易”类</li>
<li>删除商品：分配给“交易”类</li>
<li>现金支付：分配给“现金”类</li>
<li>信用卡支付：分配给“信用卡”类</li>
<li>购物卡支付：分配给“购物卡”类</li>
<li>会员卡积分支付：分配给“会员卡”类</li>
<li>打印小票：这个动词的分配存在一定的灵活性，有的人可能认为应该分配给“交易”类，因为打印小票可以认为是“交易”流程中的一个步骤；有的人可能认为应该分配给“小票”类，因为打印小票可以认为是“小票”类的一个基本功能。其实两者都有一定道理，如果没有其它更有力的选择因素，我建议根据个人经验选择一个即可，这里我们选择分配给“小票”。分配完成后，我们可以看到“交易”、“小票”、“信用卡”、“购物卡”、“会员卡”、“现金”都已经有方法了。</li>
</ul>
<p>当然，对于有经验的人来说，以上步骤完全可以在脑海中就迅速完成了，而并不会这样一步一步的演示给别人看，所以看起来就像变戏法一样，不知怎么就设计出来了很多的软件类。</p>
<p>经过上面的处理步骤后，我们得到如下的类图：<img src="http://img.blog.csdn.net/20140415100326625" alt=""><br>与领域模型相比，部分领域类被剔除了，留下来的领域类映射成软件类后，又增加了方法。虽然还不完善，但软件类的是越来越有型，越来越清晰了。</p>
<h2 id="第二斧（精雕细琢）：应用设计原则和设计模式"><a href="#第二斧（精雕细琢）：应用设计原则和设计模式" class="headerlink" title="第二斧（精雕细琢）：应用设计原则和设计模式"></a><strong>第二斧（精雕细琢）：应用设计原则和设计模式</strong></h2><p>完成了从领域类到软件类的映射后，类出来了，属性也出来了，方法也有了，看起来设计已经大功告成了。事实上也确实有很多人基本上做到这一步就开始动手编码了，而且经过一番拼搏，最后发布的系统也能用。</p>
<p>但相信很多人都会有这个疑问：这样做就够了么，这样设计是否是好的设计呢？要回答这个问题，我们首先要明确：什么叫做“好”的设计呢 ？</p>
<p>到目前为止，我们已经有了一个类的设计模型，而且如果按照这个模型去实现的话，最终应该也是能够满足用户的需求，毕竟我们这个类模型是按照“需求模型 -&gt; 领域模型 -&gt; 类模型”这样一路推导过来的，不会出现大的偏差。</p>
<p>那么，满足了用户需求的设计就是好的设计么？相信有经验的朋友都会知道答案：“满足用户需求”只是设计的一个最基本要求，而不是一个“好设计”的评判标准。</p>
<p>既然如此，那么到底什么才是好的设计呢，是否有明确的标准来进行评价呢？幸运的是，面向对象领域经过几十年的发展，确实已经发展出了很多成熟的指导思想和方法，用于评价和指导如何才能做好面向对象的设计。其中最具代表性的就是<strong>“设计原则”和“设计模式”</strong>。</p>
<p><strong>【设计原则】</strong></p>
<p>当我们谈到面向对象领域的设计原则的时候，我们其实都是在谈论罗伯特.C.马丁（Robert C. Martin ，又叫Bob大叔）的SOLID原则。这也难怪，Bod大叔实在是太牛了，面向对象领域的设计原则几乎被他全部包揽了，加上他在他的畅销书《敏捷软件开发：原则、模式与实践》中详细的将这些原则集中一 一阐述，面向对象领域设计原则的权威非他莫属。毫不夸张的说，Bob大叔的威名和在面向对象领域中的地位，和设计模式的“四人帮”是不相上下的。虽然很多资料都将SOLID原则和敏捷开发、测试驱动开发等方法绑定在一起，但我觉得只要是面向对象设计，不管是瀑布流程、、CMM流程、RUP流程、还是敏捷开发流程，都应该应用设计原则以提高设计质量。参考wiki百科，SOLID设计原则简单介绍如下：SOLID实际上是取5个设计原则的首字母拼起来的一个助记单词。具体的设计原则如下（详细的设计原则，我们会在后面详细阐述，这里不再详细展开）：</p>
<table>
<thead>
<tr>
<th>首字母</th>
<th>英文简写</th>
<th>英文名称</th>
<th>中文名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>SRP</td>
<td>Single Responsibility Principle</td>
<td>单一职责原则</td>
<td>对象应该只具备单一职责</td>
</tr>
<tr>
<td>O</td>
<td>OCP</td>
<td>Open/Close Principle</td>
<td>开放/封闭原则</td>
<td>认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。</td>
</tr>
<tr>
<td>L</td>
<td>LSP</td>
<td>Liskov Substitution Principle</td>
<td>Liskov替换原则</td>
<td>认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念</td>
</tr>
<tr>
<td>I</td>
<td>ISP</td>
<td>Interface Segregation Principle</td>
<td><a href="http://zh.wikipedia.org/w/index.php?title=%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99&amp;action=edit&amp;redlink=1" target="_blank" rel="external">接口隔离原则</a></td>
<td>多个特定客户端接口要好于一个宽泛用途的接口</td>
</tr>
<tr>
<td>D</td>
<td>DIP</td>
<td>Dependency Inversion Principle</td>
<td><a href="http://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99" target="_blank" rel="external">依赖反转原则</a></td>
<td>依赖于抽象而不是一个实例</td>
</tr>
</tbody>
</table>
<p>[wik链接]（<a href="http://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1）" target="_blank" rel="external">http://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1）</a></p>
<p>前面我们简单的八卦了一下，现在回归正题：设计原则有什么用？其实和所有的原则一样，设计原则也是一个判断标准，说通俗点，设计原则就像是木匠手中的尺子，尺子是用来衡量木材的长短的，而设计原则就是衡量类设计的“尺子”：量一量，看长了还是短了，还是正好，长了就裁短一些，短了就加长一些。经过如此衡量并调整，最终就能够得到我们希望的设计作品。当然，和木匠的尺子稍有不同，木匠不用尺子就做不出能用的家具，但我们不用设计原则的话，其实还是能够做出满足需求的系统的。<br>既然这样，我们为什么一定要用设计原则呢？ARTHUR J.RIEL在《OOD启思录》一书中针对这个问题给出了非常形象的解释：你不必严格遵守这些原则，违背它也不会被处以宗教刑罚。但你应当把这些原则看做警铃，若违背了其中的一条，那么警铃就会响起。”——-ARTHUR J.RIEL,《OOD启思录》<br>也就是说，如果违背了这些设计原则，就可能有危险，但究竟是什么危险呢，警铃要警告我们什么呢，是火灾、水灾、地震、陷阱、还是有狮子、老虎。。。。。？</p>
<p>要回答这个问题，还需要回到面向对象的本源：我们在第一章解释为什么要面向对象的时候提到了面向对象的核心思想是“可扩展性”，这其实就是我们应用设计原则的根本目的：保证可扩展性。如果我们不遵守这些设计原则，警铃就会响起，提醒我们：你的设计可扩展性会有问题！除了设计原则外，后面要讲到的设计模式，其本质也是为了提高可扩展性。这也是为什么我们通过领域类映射得到了很多软件类之后，还需要不辞辛劳的继续应用设计原则和设计模式的主要原因，本质上都是为了提高设计的可扩展性。</p>
<p>SOLID设计原则的各个子原则详细介绍会在后面详细介绍，这里我们简单的以POS机为例，看看如何应用设计原则。</p>
<p>仔细观察我们通过领域类映射得到的软件类，可以发现一个很明显不符合SOLID原则中的DIP原则的地方，即：“交易类”直接依赖“会员卡”、“购物卡”、“信用卡”、“现金”4个子类，这样的实现不符合DIP原则，当需要增加新的支付方式时，“交易类”也需要跟着修改。</p>
<p>既然不满足DIP设计原则，那么我们就按照DIP原则的要求，提取出一个支付的父类来，即：“交易类”依赖“支付类”，“会员卡”、“购物卡”、“信用卡”、“现金”都继承“支付”类。具体实现如下：<br><img src="http://upload-images.jianshu.io/upload_images/1985459-07a1cace538a47a9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看到，应用DIP设计原则之后，我们又多出了一个“支付”的类，这个类原来在领域模型中是没有的，而是我们在设计阶段“创造”出来的。对于其它各个类，我们都可以依次使用设计原则进行判断，当发现不符合设计原则的设计时，就采取增加、删除、合并、拆分等手段，使我们的设计逐步改进，最终达到符合设计原则的目的。</p>
<p><strong>【设计模式】</strong></p>
<p>相比设计原则来说，设计模式更加普及和流行，当我们谈到设计方法的时候，大部分人肯定都会想到设计模式，设计模式如此深入人心，几乎到了言必谈设计模式的地步。<br>和设计原则类似，当我们谈论设计模式的时候，我们其实都是在谈论GOF（Gang of Four，中文翻译为“四人帮”）在经典名作《设计模式  –可复用面向对象软件的基础》一书中提到的设计模式。<br>通俗的讲，设计模式是用于指导我们如何做出更好的设计方案，而前面提到的设计原则，其作用也是这样的。那么，设计原则和设计模式，我们该如何选择？<br>有的朋友可能会以为这两个是二选一的关系，要么用设计原则，要么用设计模式。这种理解是错误的，设计原则和设计模式并不是竞争关系，正好相反，它们是互补的关系。<br>设计原则和设计模式互补体现在：<strong>设计原则主要用于指导“类的定义”的设计，而设计模式主要用于指导“类的行为”的设计</strong>，更通俗一点的讲：设计原则是类的静态设计原则，设计模式是类的动态设计原则。</p>
<p>一般情况下，我们是采用“先设计原则，后设计模式”的方法来操作的。</p>
<p>设计模式的相关内容会在后文详细介绍，这里我们以POS机为例，看看如何应用设计模式来优化我们的设计。</p>
<p>通过分析应用设计原则优化后的类，我们发现“信用卡”这个类存在优化的空间，因为国际上存在不同的信用卡，最常见的有中国银联（UnionPay）、Visa、MasterCard这几种，每种信用卡在支付的时候需要接入不同的机构，其接入方式和协议肯定都是有一定差异的。为了封装这种差异以支持后续更好的扩展，我们应用设计模式的Bridge模式，提取出“信用卡处理”这个类，这个类的主要处理“连接、认证、扣款”这样的职责。UnionPay、Visa、MasterCard都继承“信用卡处理”这个类。具体如下：<br><img src="http://upload-images.jianshu.io/upload_images/1985459-b44f326e22cb5cca?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="第三斧（照本宣科）：拆分辅助类"><a href="#第三斧（照本宣科）：拆分辅助类" class="headerlink" title="第三斧（照本宣科）：拆分辅助类"></a><strong>第三斧（照本宣科）：拆分辅助类</strong></h2><p>**经过前面的设计步骤之后，面向对象类的设计工作已经完成，我们输出了完整的类模型，看起来已经可以开始动手编码了，你是否舒了一口气，看着自己的设计作品，不由得产生了一种自豪感呢？</p>
<p>确实值得自豪，毕竟我们一步一个脚印，从最初仅仅存在于客户脑袋中的需求，逐步的推导、演变、设计出了能够付诸实施的类模型了。但在最终实施之前，还有一点小小的动作要完成，这就是我们的拆分辅助类操作。</p>
<p>拆分辅助类的主要目的是为了使我们的类在编码的时候能够满足一些框架或者规范的要求。比如说常见的MVC模式，将一个业务拆分成Control、Model、View三个元素；J2EE模式中，将对象分为PO、BO、VO、DTO等众多对象。</p>
<p>之所以说这是一点小小的动作，是因为这个动作确实很简单，只要将我们设计出来的类，按照规范要求，一 一对应分拆即可。</p>
<p>以POS机为例，假如我们的框架要求提供DAO对象，负责数据库的相关操作，则“购物卡”类就应该拆分为两个：“购物卡”、“购物卡DAO”，其中“购物卡”用于负责提供“支付”功能给“交易”类调用，“购物卡DAO”用于负责从数据库读取购物卡信息，修改数据库中购物卡余额等操作。<br><img src="http://upload-images.jianshu.io/upload_images/1985459-d6d70186aa2290f3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>需要注意的是，拆分设计辅助类仅仅是为了满足框架或者规范的要求，<strong>本身并不是一个设计的步骤，而是实施的一个步骤</strong>，所以我们一般都不需要将拆分的辅助类体现在类模型中，仅仅在编码的时候拆分即可。</p>
<h1 id="第二十七章"><a href="#第二十七章" class="headerlink" title="第二十七章"></a>第二十七章</h1><p>类模型指导我们如何<strong>声明类</strong>，动态模型指导我们如何<strong>实现类</strong>！</p>
<p>动态模型设计一般都是在类模型设计完成后才开始，因为动态模型设计的时候一般都需要用到类模型中的类。相对类模型来说，动态模型要相对简单一些，主要原因在于动态模型设计的时候没有什么设计原则和设计模式需要应用，只需要对照用例模型，根据用例模型的特点，选取一个合适的动态模型将其表述出来即可。</p>
<p>动态模型在实际开发过程中有非常重要的作用，简单来说，如果没有动态模型，那么你虽然完成了类设计，但还是不能编码，或者只能编写类的声明代码（类属性、方法名称），但不能写类的实现代码（方法里面的实现逻辑，即：每个方法的实现）。动态模型就是用来指导我们如何编写具体的方法的。</p>
<p>有的同学可能会有疑问：那些地方要进行动态模型设计呢？<br>还是那句老话，你觉得比较复杂你就设计，简单你就不设计，总之：<strong>你需要你就设计</strong>！<br>像我在实际开发中，基本上一个中等项目就一两个业务设计动态模型（小项目看到需求就编码了 ：） ），其它业务看需求文档就能看出如何编码，这也是有经验和经验不足的差别。</p>
<p>参考UML标准，常见的动态模型如下：<br>【状态模型】<br>状态模型主要用于描述对象的生命周期的状态变化。通过状态图，我们可以了解到对象有哪些状态，状态之间如何转换，转换的触发条件等。当我们发现一个对象的状态比较复杂的时候，就需要设计对象的状态模型。<br>UML中使用状态图来描述状态模型</p>
<p><strong>【活动模型】</strong><br>活动模型主要用于描述一个工作流程或者计算流程。其关注点是在完成某项工作的过程中，系统中的哪些对象承担了什么样的任务、做了什么处理，以及这些对象之间的先后交互关系。当我们发现一个处理流程比较复杂的时候，就需要设计流程的活动模型。<br>UML中使用活动图来描述活动模型</p>
<p><strong>【序列模型】</strong><br>序列模型主要用于描述对象按照时间顺序组织的消息交互过程，其关键特征是强调按照“时间顺序”来组织对象的交互，所以序列图有时又称为“时序图”或者“顺序图”。序列模型是我们最常用的动态模型，特别适合将用例模型或者SSD转换为系统的动态模型。<br>UML中使用序列图来描述序列模型</p>
<p><strong>【协作模型】</strong><br>协作模型主要用于描述按照对象之间的关联来组织的消息交互过程，其关键特征是强调“对象关系”来组织对象的交互。协作模型的作用和序列模型一样，只是强调的点不同，大部分的时候我们都是选择“序列模型”，因为序列模型的时间顺序很多时候和用例模型的步骤不谋而合。<br>UML中使用协助图来描述协作模型</p>
<p>注意：以上模型并不是每个都必须有的，根据实际需要选择即可</p>
<p><strong>建模实践</strong><br>以上这些模型都可以从用例模型推导出来，活动模型、序列模型、协作模型基本上都是和用例模型一一对应的，或者对应用例中的某个分支。一般情况下不推荐一个模型中包含多个分支，因为这样会导致图比较复杂，而且主题不突出。</p>
<p>状态模型和其它模型相比要复杂一些，因为并不能从单个用例或者单个用例分支推导出某个对象的所有状态，而需要综合多个用例模型，从中提取出和某个对象状态相关的内容，再统一设计状态模型。</p>
<p>从用例模型推导出动态模型是一个“分解和分配”的过程，因为在用例模型中，系统是当做一个“黑盒”来看待的，而在动态模型中，系统不再是一个黑盒，而是分解成了一个一个的类。因此我们需要将原来笼统的划分给系统的功能和职责，进一步分解并分配给不同的类。通俗的讲，动态模型就是说：为了完成系统的XXX功能， 先需要类A做任务1，然后需要类B需要做任务2，再由类C做任务3。。。。。。依次分解下去，最终就能够实现将类串起来，相互配合，最后实现了系统的需求。</p>
<p>我们以POS机为例，假设我们基于买单这个用例的正常分支设计“序列模型”，则可以得到如下的“序列模型”：<br><img src="http://upload-images.jianshu.io/upload_images/1985459-7c0007324e8e4a1a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">有了上面这个“序列图”，假设我们要开始写代码，则基本可以按照如下伪码的方式实现（实际的编码肯定不会这么简单，但方法是一样）：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;  </span><br><span class="line">  </span><br><span class="line">    Trade trade = <span class="literal">new</span> Trade();                  </span><br><span class="line">    <span class="built_in">Integer</span> tradeId =trade.makeNewTrade();  <span class="comment">//创建  </span></span><br><span class="line">    trade.addGoods();                       <span class="comment">//增加商品  </span></span><br><span class="line">    trade.cacuMoney();                      <span class="comment">//计算总额  </span></span><br><span class="line">    <span class="attr">...</span><span class="attr">...</span><span class="attr">...</span><span class="attr">...</span><span class="comment">//省略一大段代码  </span></span><br><span class="line">    Receipt receipt = <span class="literal">new</span> Receipt();          </span><br><span class="line">    receipt.print(trade);                   <span class="comment">//打印小票  </span></span><br><span class="line">    <span class="attr">...</span><span class="attr">...</span><span class="attr">...</span>..<span class="comment">//省略一大段代码  </span></span><br><span class="line">    trade.finish();                         <span class="comment">//结束  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/软件笔记/">软件笔记</a>
	</div>


      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面向对象/">面向对象</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
        var yiliaConfig = {
        fancybox: true,
        mathjax: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        open_in_new: false
        }
        </script>
     

  
    <article id="post-pythonの读取excel内容" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/10/pythonの读取excel内容/" class="article-date">
  	<time datetime="2016-05-10T13:58:06.000Z" itemprop="datePublished">2016-05-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/10/pythonの读取excel内容/">pythonの读取excel内容</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h2 id="任务要求：读取excel内数据，并对数据进行校验后返回数据"><a href="#任务要求：读取excel内数据，并对数据进行校验后返回数据" class="headerlink" title="任务要求：读取excel内数据，并对数据进行校验后返回数据"></a>任务要求：读取excel内数据，并对数据进行校验后返回数据</h2>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/软件笔记/">软件笔记</a>
	</div>


      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/excel/">excel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>
	</div>

      
        <p class="article-more-link">
          <a  href="/2016/05/10/pythonの读取excel内容/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
        var yiliaConfig = {
        fancybox: true,
        mathjax: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        open_in_new: false
        }
        </script>
     

  
    <article id="post-pythonの读取oracle数据库字段名类型等" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/05/pythonの读取oracle数据库字段名类型等/" class="article-date">
  	<time datetime="2016-05-05T13:10:20.000Z" itemprop="datePublished">2016-05-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/05/pythonの读取oracle数据库字段名类型等/">pythonの读取oracle数据库字段名类型等</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <blockquote>
<p>完成任务：通过给出的SQL语句，获得所操作表的字段名类型等信息</p>
</blockquote>
<h2 id="安装cx-oracle插件-确定返回值类型"><a href="#安装cx-oracle插件-确定返回值类型" class="headerlink" title="安装cx_oracle插件  确定返回值类型"></a>安装cx_oracle插件  确定返回值类型</h2>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/软件笔记/">软件笔记</a>
	</div>


      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oracle/">oracle</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>
	</div>

      
        <p class="article-more-link">
          <a  href="/2016/05/05/pythonの读取oracle数据库字段名类型等/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
        var yiliaConfig = {
        fancybox: true,
        mathjax: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        open_in_new: false
        }
        </script>
     

  
    <article id="post-pythonのoracle数据库操作" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/30/pythonのoracle数据库操作/" class="article-date">
  	<time datetime="2016-04-30T07:22:27.000Z" itemprop="datePublished">2016-04-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/30/pythonのoracle数据库操作/">pythonのoracle数据库操作</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h2 id="下载cx-Oracle"><a href="#下载cx-Oracle" class="headerlink" title="下载cx_Oracle"></a>下载cx_Oracle</h2><p>　　想用python链接数据库首先需要安装cx_Oracle插件，<br>下载地址：<a href="http://cx-oracle.sourceforge.net/">http://cx-oracle.sourceforge.net/</a></p>
<h2 id="测试是否cx-Oracle安装成功"><a href="#测试是否cx-Oracle安装成功" class="headerlink" title="测试是否cx_Oracle安装成功 "></a>测试是否cx_Oracle安装成功
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/软件笔记/">软件笔记</a>
	</div>


      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Oracle/">Oracle</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>
	</div>

      
        <p class="article-more-link">
          <a  href="/2016/04/30/pythonのoracle数据库操作/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
        var yiliaConfig = {
        fancybox: true,
        mathjax: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        open_in_new: false
        }
        </script>
     

  
    <article id="post-PythonのEclipse+PyDev环境搭建" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/28/PythonのEclipse+PyDev环境搭建/" class="article-date">
  	<time datetime="2016-04-28T02:39:27.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/28/PythonのEclipse+PyDev环境搭建/">PythonのEclipse+PyDev环境搭建</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h2 id="编译器：Eclipse-Pydev插件"><a href="#编译器：Eclipse-Pydev插件" class="headerlink" title="编译器：Eclipse+Pydev插件"></a>编译器：Eclipse+Pydev插件</h2><ol>
<li>Eclipse 功能强大 跨平台</li>
<li>Eclipse 时写Java的IDE，使用方便</li>
<li>PyDev插件让Eclipse支持python代码编写及编译
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/软件笔记/">软件笔记</a>
	</div>


      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Eclipse/">Eclipse</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PyDev/">PyDev</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>
	</div>

      
        <p class="article-more-link">
          <a  href="/2016/04/28/PythonのEclipse+PyDev环境搭建/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
        var yiliaConfig = {
        fancybox: true,
        mathjax: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        open_in_new: false
        }
        </script>
     

  
    <article id="post-SQL" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/15/SQL/" class="article-date">
  	<time datetime="2016-04-15T14:05:50.000Z" itemprop="datePublished">2016-04-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/15/SQL/">SQL入门教程（一）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>　　1、说明：创建数据库</p>
<p>　　CREATE DATABASE database-name</p>
<p>　　2、说明：删除数据库</p>
<p>　　drop database dbname</p>
<p>　　3、说明：备份sql server</p>
<p>　　— 创建 备份数据的 device</p>
<p>　　USE master</p>
<p>　　EXEC sp_addumpdevice ‘disk’, ‘testBack’, ‘c:\mssql7backup\MyNwind_1.dat’</p>
<p>　　— 开始 备份</p>
<p>　　BACKUP DATABASE pubs TO testBack<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/软件笔记/">软件笔记</a>
	</div>


      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Oracle/">Oracle</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL用法/">SQL用法</a></li></ul>
	</div>

      
        <p class="article-more-link">
          <a  href="/2016/04/15/SQL/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
        var yiliaConfig = {
        fancybox: true,
        mathjax: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        open_in_new: false
        }
        </script>
     

  
    <article id="post-小七生日快乐" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/12/小七生日快乐/" class="article-date">
  	<time datetime="2016-03-12T15:18:59.000Z" itemprop="datePublished">2016-03-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/12/小七生日快乐/">小七生日快乐</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="/web/happybirthday/index.html">生日</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/心情笔记/">心情笔记</a>
	</div>


      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/小七/">小七</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生日/">生日</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
        var yiliaConfig = {
        fancybox: true,
        mathjax: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        open_in_new: false
        }
        </script>
     

  
    <article id="post-小七" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/05/小七/" class="article-date">
  	<time datetime="2016-02-05T14:49:19.000Z" itemprop="datePublished">2016-02-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/05/小七/">纪念我和小七在一起</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="/web/love/index.html">纪念日</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
        <div class="article-pop-out tagcloud">
          <a class="">置顶</a>
        </div>
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/心情笔记/">心情笔记</a>
	</div>


      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/小七/">小七</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/纪念日/">纪念日</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
        <script>
        var yiliaConfig = {
        fancybox: true,
        mathjax: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        open_in_new: false
        }
        </script>
     

  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  

</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2016 Phantom
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的静态博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减双栏 Hexo 博客主题">Yelee</a> by MOxFIVE
        </div>
    </div>
    <div class="visit">
	<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1257065196'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1257065196%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));</script>
    </div>
  </div>
</footer>
    </div>
    
	<script>
		var yiliaConfig = {
			fancybox: false,
			mathjax: true,
			animate: true,
			isHome: true,
			isPost: false,
			isArchive: false,
			isTag: false,
			isCategory: false,
			open_in_new: false
		}
	</script>


<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

<script>
  var backgroundnum = 5;
  var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));

  $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
</script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
<a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
<a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<script>
var option = {
  engineKey: '990f4c9c13b06ab1d082'
};
(function(w,d,t,u,n,s,e){
   s = d.createElement(t);
   s.src = u;
   s.async = 1;
   w[n] = function(r){
     w[n].opts = r;
   };
   e = d.getElementsByTagName(t)[0];
   e.parentNode.insertBefore(s, e);
})(window,document,'script','//tinysou-cdn.b0.upaiyun.com/ts.js','_ts');
</script>
  </div>
</body>
</html>