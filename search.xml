<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[产品经理一定要懂得算法（三）]]></title>
      <url>http://i90s.vip/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/2017/08/28/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E4%B8%80%E5%AE%9A%E8%A6%81%E6%87%82%E5%BE%97%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>自己负责的 app 也有热点新闻模块，也一直没搞清楚究竟如何进行个性化推荐，最近看到一篇腾讯 pm 写的文章，收获很多，根据记忆进行下复盘。</p>
</blockquote>
<p>上篇文章讲了前两篇文章讲了热点推荐和基于内容的相关推荐<br>，链接：<br><a href="http://www.toutiao.com/i6450826526601511438/" target="_blank" rel="external">产品经理一定要懂得算法（一）</a><br><a href="http://www.toutiao.com/i6455913366589276686/" target="_blank" rel="external">产品经理一定要懂得算法（二）</a><a id="more"></a></p>
<h2 id="基于用户的协同过滤"><a href="#基于用户的协同过滤" class="headerlink" title="基于用户的协同过滤"></a>基于用户的协同过滤</h2><p>当产品的日活月活较高时，热点推荐和基于内容的推荐已经不能满足产品的需求了，虽然热点算法能够推荐当前的热点事件，基于内容的推荐能够基于他感兴趣的内容推荐他可能感兴趣的内容，但是对于用户来说推荐的内容总是却少一些“不期而遇”的感觉，对于产品来说是缺少发现用户兴趣的能力。</p>
<p>基于用户的协同过滤算法，简单的说就是，根据用户a的兴趣爱好，找到和其兴趣爱好最接近的群体，然后把这个群体里其他人喜欢的文章推荐给a。所以基于用户的系统过滤第一步就是找到用户所属的群体。</p>
<h3 id="一、用户群体划分"><a href="#一、用户群体划分" class="headerlink" title="一、用户群体划分"></a>一、用户群体划分</h3><p>用户的群体划分可以根据从以下三个方面入手：<br><strong>（1）借用外部数据</strong><br>外部数据以借用社交平台的数据居多，比如：微信、QQ、微信、facebook、github等，借用第三方账户有很多优点，例如降低注册门槛、方便传播等。</p>
<p>另外第三方帐号都会授权获取用户的部分信息，一般为性别、年龄、工作或者相关社交关系等，这些基础信息可以将用户进行初步的划分。</p>
<p><strong>（2）产品内主动询问</strong></p>
<p>常见的方式为在产品首次启动时，弹出提示框询问用户的性别、职业、喜好等，比如一些常见的新闻资讯类app，这样可以帮助产品进行冷启动。不过这种方式性价比不高，而且要避免过度打扰用户。</p>
<p><strong>（3）对比用户特征</strong></p>
<p>上篇文章已经提到，新闻的特征加用户的阅读数据能得到用户的特征，然后通过用户的特征划分群体。</p>
<h2 id="二、内容推荐实施"><a href="#二、内容推荐实施" class="headerlink" title="二、内容推荐实施"></a>二、内容推荐实施</h2><p>我们结合一个很小的实例来了解用户协同过滤的原理，包括如何计算用户之间的相似性和如何做出推荐。</p>
<p>假设有 A、B、C、D 和 E 共 5 个用户，他们各自阅读了几篇新闻并做出了阅读，赞，收藏，评论，分享操作，我们对这几种行为赋予的分数分别为 1 分、2 分、3 分、4 分和 5 分，这样用户对每条新闻都有自己的得分，其中 “-” 表示未阅读，得分如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1985459-e7ae208fdb4322e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用户阅读数据"><br>那么问题来了，我们要给用户E推荐4、5、6中的哪一篇？</p>
<p>用户的阅读特征向量由用户的阅读数据决定，我们以用户E阅读过的数据作为参考标准，来找到与E最相似的用户。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1985459-9b2c7865124c02ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>多维向量的距离需要通过欧几里得距离公式来计算，数值越小，向量距离约接近。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1985459-80680a9bd9a7d7d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="三、内容选取"><a href="#三、内容选取" class="headerlink" title="三、内容选取"></a>三、内容选取</h2><p>我们通过阅读特征向量把用户做群体划分后，接下来就是如何获取新闻推荐的优先级。</p>
<p>上面的例子里面只需要选出一个相似用户，并且用户 A,B,C,D 都只阅读 news4,5,6 中的一条，所以比较简单，但现实情况中，同一个用户群体阅读的新闻多且随机，用户交互更是错综复杂，如何得出推荐新闻的优先级呢？</p>
<p>假设用户 X 在系统归属于群体 A，这个群体有 n 个用户，分别为 A0，A1，A2……An，这些用户的集合用 S(X,n) 表示。</p>
<p>1）首先，我们需要把集合中所有用户交互过（阅读，评论等）的新闻提取出来</p>
<p>2）需要剔除掉用户 X 已经看过的新闻，这些就不用再推荐了，剩下的新闻集合有 m 条，用 N（X,m）来表示</p>
<p>3）对余下的新闻进行评分和相似度加权的计算，计算包括两部分，一是用户 X 与 S（X,n） 每一个用户的相似性，二是每个用户对新闻集 N（X,m）中每条新闻的喜好，这样就能得到每条新闻相对于用户 X 的最终得分</p>
<p>4）将 N（X,m）中的新闻列表按照得分高低的顺序推荐给用户</p>
<h2 id="四、优缺点"><a href="#四、优缺点" class="headerlink" title="四、优缺点"></a>四、优缺点</h2><p>相比于基于内容的推荐算法，基于用户的协同过滤同样优缺点明显。</p>
<p>优点主要在于对分词等算法的精确度无太大要求，推荐都是基于用户的行为数据去不断学习和完善；同时能发现用户的潜在阅读兴趣，能 “制造惊喜”。</p>
<p>而缺点则是启动的门槛高，用户量不够时几乎无法开展；并且学习量不够时推荐结果较差。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[产品经理一定要懂得算法（二）]]></title>
      <url>http://i90s.vip/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/2017/08/19/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E4%B8%80%E5%AE%9A%E8%A6%81%E6%87%82%E5%BE%97%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>自己负责的 app 也有热点新闻模块，也一直没搞清楚究竟如何进行个性化推荐，最近看到一篇腾讯 pm 写的文章，收获很多，根据记忆进行下复盘。</p>
</blockquote>
<p>上篇文章讲了热度算法，链接：<a href="http://blog.i90s.vip/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/2017/08/05/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E4%B8%80%E5%AE%9A%E8%A6%81%E6%87%82%E5%BE%97%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89.html" target="_blank" rel="external">产品经理一定要懂得算法（一）</a></p>
<p>热度算法适用与产品的初期，且本身有缺陷，热度算法会导致用户的行为过度集中，当产品的日活月活达到一定的量级的时候，就需要考虑用户的个性化推荐，这样用户不仅可以看到当前的热点内容，也可以读到自己感兴趣的内容。个性化内容推荐，常用的有两种算法：<a id="more"></a><br>  1）基于内容的相关推荐<br>  2）基于用户的协同过滤<br>  基于用户的协同过滤相对基于内容的相关推荐对用户的数量要求较高，并且前期要准备的工作会比较多，所以相比基于用户的协同过滤，基于内容的推荐使用场景更多、范围更广。</p>
<h2 id="基于内容的相关推荐"><a href="#基于内容的相关推荐" class="headerlink" title="基于内容的相关推荐"></a>基于内容的相关推荐</h2><p>这里需要引入一个概念叫做 “新闻特征向量” ，用它来表示新闻的相似度。即把新闻的关键词提取出来，关键词可以看成新闻的特征向量，当两篇新闻的关键词相似度较高时，可以认为这两篇新闻的相关性较高。下面说一下基于内容的相关推荐的实现过程。</p>
<h3 id="1）分词"><a href="#1）分词" class="headerlink" title="1）分词"></a><strong>1）分词</strong></h3><blockquote>
<p>什么叫分词，简单的说就是把一片文章分成一个个的词语，望文生义就好</p>
</blockquote>
<p>分词需要使用是用到两个词库，一个叫正常词库，一个叫停用词库，字如其名（是不是感觉有点废话）。停用词库就是那些常见但是没有任何意义的分词，比如：中文中的“的”，“了”，英文里的“that”，“are”之类的，这类词出现的频率会很高，但是本身对于分词没有任何帮助，所以需要放入停用词库中进行过滤。</p>
<p>常用的分词方法有（敲黑板）</p>
<p>按照分词顺序：正向匹配、逆向匹配<br>按照分词长度：最大匹配、最小匹配</p>
<p>那么常用的中文分词法是什么？常用的中文分词法既不是正向匹配、逆向匹配，也不是最大匹配、最小匹配，而是</p>
<p>a)正向最大匹配（从左到右）<br>b)逆向最大匹配（从右到左）<br>c)双向最大匹配（左右摇摆，忽左忽右·····算法怎么这不不严谨，其实是先正向（反向），再反向（正向）进行两次匹配）<br>d)最短路径法（每一句话的分词数最少）</p>
<p>【小贴士1】正向最大匹配：假设正常词库中最长的词有N个中文字符，则把待处理内容的前 N个字作为匹配字段，查找词库。若词库中存在这样的一个 N字词，则匹配成功，匹配字段被作为一个词切分出来。如果词库中找不到这样的一个 N字词，则匹配失败，按照从左到右，将匹配字段中的<strong>最后一个字去掉</strong>，对剩下的字串重新进行匹配处理，这是个循环，直到匹配成功，即切分出一个词或剩余字串的长度为零为止。</p>
<p>【小贴士2】词库需要不断的维护，否则你的算法看到完全没见过的词会很懵逼</p>
<h3 id="2）特征向量指标"><a href="#2）特征向量指标" class="headerlink" title="2）特征向量指标"></a><strong>2）特征向量指标</strong></h3><p>新闻关键词的集合就是新闻的特征向量，所以特征向量的第一个指标就是“关键词”，两篇新闻的内容是否相关就是比较两篇新闻特征向量的重合度。但是两篇新闻的新闻特征向量重合度较高是否两篇文章就一定相关？<br>既然这样问了，那答案肯定是不一定相关<br>原作者当时举了两个栗子，拿来复用<br>新闻一，“广州近期天气较好，……….，大家可以骑着摩拜单车去春游”<br>新闻二，“摩拜单车进驻广州，……,大家可以在天气好的时候骑着摩拜单车去春游”<br>两篇文章都可以分词出来“广州”，“天气”，“摩拜单车”，“春游”，两篇新闻的关键词虽然一样，但是两篇文章讲的完全是不同的事情，新闻一主要是是讲“广州天气”，新闻二主要是讲“摩拜单车”。<br>所以只看新闻的关键词是不够的，这里给特征向量引入第二个指标叫新闻内频率（ TF：Term Frequency），即衡量每个关键词在新闻中出现的频率。<br>还是上面两个新闻，可以得出新闻一，“广州天气”是个高频词，新闻二，“摩拜单车”是个高频词，引入了TF后，可以一定程度的解决上面的问题，但是两篇文章的关键词一样，出现频率一样，那两篇新闻就一定是强关联么？<br>。<br>。<br>。<br>。<br>。<br>答案是肯定的，当两篇文章的关键词一样，出现频率一样，那两篇新闻就一定是强关联，意不意外，惊不惊喜。<br>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1985459-cf0a6e6f764521c3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>【友情提示】引入TF以后，这个算法就可以去拿出去忽悠了</p>
<p><strong>继续进阶</strong></p>
<p>在日常新闻中还存在一种情况，对于地域性新闻，新闻关联程度本身就会很高，比如上海日报（瞎编的），掐指一算，它的新闻关键词无非是“东方明珠”，“陆家嘴”，“人广”，“世纪大道”，“浦东新区”，但是上海日报的每一篇文章都一样么？肯定不是，每一篇文章的侧重点肯定都是不一样的，那如何在关联度很高的新闻里区分出每篇新闻究竟侧重点是什么？？？</p>
<p>这里需要引入特征向量的第三个指标相反值（IDF：Inverse Document Frequency），即关键词在所有文档中出现的频率的相反值。</p>
<p>为什么要引入相反值，（敲黑板，重点）<strong>当一个关键词在某条新闻出现的频率最大，在所有文档中出现的频率越小，该关键词对这条新闻的特征标识作用越大</strong>（多读两遍，再来一遍，理解了吧），这是一点很容易被忽略的重点。</p>
<p>结合上面的几点，我们就可以把每个关键词对新闻的作用就能被衡量出来即 TFIDF=TF * IDF，这也就是著名的 TF-IDF 模型。</p>
<h3 id="3）相关性算法"><a href="#3）相关性算法" class="headerlink" title="3）相关性算法"></a><strong>3）相关性算法</strong></h3><p>讲过前两步的分词和确定指标后，可以的出新闻的特征向量:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1985459-49b6647c70a87631.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>其中word0，word1…为新闻的关键词，TFIDF0,TFIDF1…为关键词的指标<br>考察知识面的时候到了，根据<strong>高中</strong>的知识，几何中夹角余弦可以用来衡量两个向量的方向的差异性，因此在我们的算法中使用夹角余弦来计算新闻关键词的相似度。夹角越小，相似度越高。</p>
<p>举个栗子：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1985459-6812c46405b76b83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看到两条新闻有 3个重合的关键词：上海，摩拜，学生，因此两条新闻的相关性由这 3个关键词决定，计算方式如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1985459-39bc27e28566d12b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>得出两条新闻的相关性最终值；用同样的方法能得出一条新闻与新闻库里面所有内容的相关性。</p>
<h3 id="4）用户特征"><a href="#4）用户特征" class="headerlink" title="4）用户特征"></a><strong>4）用户特征</strong></h3><p>得到新闻特征以后，还需要得到用户特征才能对两者进行匹配和推荐，那怎么获得用户特征呢？</p>
<p>需要通过用户的行为来获得，用户通过阅读，点赞，评论，分享来表达自己对新闻内容的喜爱；跟热度排名类似，我们对用户的各种行为赋予一定的 “喜爱分”，例如阅读 1 分，点赞 2 分，评论 5 分等，这样新闻特征跟用户行为结合后，就能得到用户的特征分。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1985459-1439a494ce6df7c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1985459-70fbf1329e560953.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>计算公式：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1985459-b7124bab7d1b5cba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>而随着用户阅读的新闻数越来越多，该用户的标签也越来越多，并且越发精准。</p>
<p>从而当我们拿到新闻的特征后，就能与用户的关键词列表做匹配，得出新闻与用户阅读特征的匹配度，做出个性化推荐。</p>
<h3 id="5）其他运用"><a href="#5）其他运用" class="headerlink" title="5）其他运用"></a><strong>5）其他运用</strong></h3><p>除了个性化推荐，基于内容的相关性算法能精准地给出一篇新闻的相关推荐列表，对相关阅读的实现非常有意义。此外，标签系统对新闻分类的实现和提升准确性，也有重要的意义。</p>
<h3 id="6）优缺点"><a href="#6）优缺点" class="headerlink" title="6）优缺点"></a><strong>6）优缺点</strong></h3><p>基于内容的推荐算法有几个明显优点：</p>
<p>对用户数量没有要求，无论日活几千或是几百万，均可以采用；因此个性化推荐早期一般采用这种方式。</p>
<p>每个用户的特征都是由自己的行为来决定的，是独立存在的，不会有互相干扰，因此恶意刷阅读等新闻不会影响到推荐算法。</p>
<p>而最主要的缺点就是确定性太强了，所有推荐的内容都是由用户的阅读历史决定，所以没办法挖掘用户的潜在兴趣；也就是由于这一点，基于内容的推荐一般与其他推荐算法同时存在。</p>
<p><strong>下一篇文章会复盘  基于用户的协同过滤  敬请期待</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[产品经理一定要懂得算法（一）]]></title>
      <url>http://i90s.vip/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/2017/08/05/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E4%B8%80%E5%AE%9A%E8%A6%81%E6%87%82%E5%BE%97%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>自己负责的app也有热点新闻模块，也一直没搞清楚究竟如何进行个性化推荐，最近看到一篇腾讯pm写的文章，收获很多，根据记忆进行下复盘。</p>
</blockquote>
<h2 id="一、基本原理"><a href="#一、基本原理" class="headerlink" title="一、基本原理"></a>一、基本原理</h2><p>新闻热度分=初始分+用户交互热度分-随时间的衰减分<br>换成公式：Score=S0+S（Users）-S（Time）  <a id="more"></a></p>
<h2 id="二、初始分要不要一样"><a href="#二、初始分要不要一样" class="headerlink" title="二、初始分要不要一样"></a>二、初始分要不要一样</h2><p>结论：初始分不要一样<br>原因：<br>1）八卦和娱乐新闻大众用户本身会比较喜欢，历史类新闻喜欢的用户群体较小<br>2）新闻实时性较强，奥运期间用户对体育类新闻比较关注，灾害期间，用户对灾害类相关新闻比较关注<br>3）根据产品不同的属性，对新闻本身的侧重点也不一样，栗子：文化类产品，文化类新闻就会有较高的初始分</p>
<h2 id="三、初始分如何设置"><a href="#三、初始分如何设置" class="headerlink" title="三、初始分如何设置"></a>三、初始分如何设置</h2><p>结论：给不同维度新闻不同的权重，特殊情况下调整维度的权重<br>举个例子：<br>初始权重设置</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1985459-7b352f4b7d458597.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>特殊情况下权重如何调整？手动？太low，举个栗子：可以设置热词库<br>再来个栗子：<br>体育类热词库：奥运会，NBA总决赛，世界杯<br>当有大量新闻触发热词库时，超过一定的阈值时，此时可以触发权重调整机制<br>所以这个权重就变成了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1985459-cef3449be0ce7599.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="四、用户行为分不是固定不变的"><a href="#四、用户行为分不是固定不变的" class="headerlink" title="四、用户行为分不是固定不变的"></a>四、用户行为分不是固定不变的</h2><p>原因：当产品的用户体量较小时，要体现用户的重要性，这时候用户行为分要高；当产品体量较大时，需要对内容进行运营，此时要适当降低用户的行为分</p>
<p>用户的行为：阅读（click），收藏（favor），分享（share），评论（comment）</p>
<p>用户体量较小时，用户行为分：<br>S（Users）=1<em>click+5</em>favor+10<em>share+8</em>comment</p>
<p>用户体量较大时，用户行为分：<br>S（Users）=（1<em>click+5</em>favor+10<em>share+8</em>comment）*C/DAU<br>C:一个常数<br>DAU：传说中的日活，每日活跃用户数</p>
<h2 id="五、热度分随时间衰减不应该是线性的"><a href="#五、热度分随时间衰减不应该是线性的" class="headerlink" title="五、热度分随时间衰减不应该是线性的"></a>五、热度分随时间衰减不应该是线性的</h2><p>原因：新闻都有时效性，随着时间的流逝，热度分必须衰减的越来越快，直致趋近于零<br>换成人话：随着时间的流逝，一个新闻要想维持热度，必须越来越多的人来维护才行</p>
<p>大概就是这样一个图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1985459-4907d6280cbf72fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自己手绘的图，真丑"></p>
<p>下面就是考察知识面的时候了，牛顿曾经在冰块里面想到了一个定理，所以这个定理就叫：牛顿冷却定理<br>所以<br>T（Time）=e^（K*（T1-T0））<br>T0：新闻发布时间<br>T1：新闻当前时间</p>
<h2 id="六、最终结论"><a href="#六、最终结论" class="headerlink" title="六、最终结论"></a>六、最终结论</h2><p>考虑到热度最终要无限趋近于零，所以最终的算法公式就是</p>
<p>最终的公式就是：Score=（S0+S（Users））/T（Time）</p>
<p>晚安，愿世界和平！</p>
<p><img src="//upload-images.jianshu.io/upload_images/1985459-8fec4b9da0bb9ddc.jpg" alt="要坚强"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[APP设计中容易忽略的点]]></title>
      <url>http://i90s.vip/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/2017/07/09/APP%E8%AE%BE%E8%AE%A1%E4%B8%AD%E5%AE%B9%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E7%82%B9.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>app设计可以分为两部分，第一APP整体的设计，第二APP各模块设计，针对这两点分别说一下app设计中容易忽略的点</p>
</blockquote>
<h1 id="APP整体设计"><a href="#APP整体设计" class="headerlink" title="APP整体设计"></a>APP整体设计</h1><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>任何一款软件，用户最常用的配置，往往就是系统的默认配置。使用默认状态用户的学习成本会降低很多。 <a id="more"></a><br><strong>需要默认值的地方</strong>：消息推送、声音、振动、个性化推荐、照相机、话筒等等<br><strong>设置</strong>：根据业务需求以及客户习惯决定默认值</p>
<h2 id="上下限"><a href="#上下限" class="headerlink" title="上下限"></a>上下限</h2><p>任何一个模块的逻辑都需要上下限，从而能够避免产品失控。<br><strong>需要上下限的地方</strong>：模块取值逻辑（牵扯时间等）、文字输入框、文件或者图片上传和下载等<br><strong>设置</strong>：当用户的操作超过上下线时，给予相应的提示</p>
<h2 id="误操作提示"><a href="#误操作提示" class="headerlink" title="误操作提示"></a>误操作提示</h2><p>对于重要模块，需要进行二次确认，以防误操作。<br><strong>需要设置误操作的地方</strong>：删除、清空、黑名单、举报、取消关注等<br><strong>设置</strong>：通过弹框进行二次提示等</p>
<h2 id="网络状况"><a href="#网络状况" class="headerlink" title="网络状况"></a>网络状况</h2><p>网络状况会影响到接口的访问速度，以及用户的体验效果，对于新闻网站、消息推送网站，网络情况是需要认真考虑的，对于工具类app（电子书查看、office）可以依靠缓存，用户可以查看缓存的数据<br><strong>需要设置网络的地方</strong>：<br><strong>设置</strong>：图片提示</p>
<h2 id="权限设计"><a href="#权限设计" class="headerlink" title="权限设计"></a>权限设计</h2><p>对于2B的产品，权限是产品设计中重要的一换，针对不同权限，用户能够查看的模块，执行的操作都不同，即是是能看到相同的模块，看到的数据也可能是不同的，这些都是需要通过权限进行控制。</p>
<h2 id="无响应状态"><a href="#无响应状态" class="headerlink" title="无响应状态"></a>无响应状态</h2><p>部分模块接口访问速度较慢，需要提醒用户耐性等待。<br>常用的解决方法是，设计加载状态or通过弹窗提醒用户耐心等待。</p>
<p>缺图【登录词】<br>缺图【loading状态】</p>
<h2 id="多语言支持"><a href="#多语言支持" class="headerlink" title="多语言支持"></a>多语言支持</h2><p>根据我的经验，如果不是在设计时就要求多语言的，尽量等产品成熟后再去进行多语言支持，否则会占用大量人力，多语言支持不仅是页面更改了语言，还会牵扯到页面展示的修改，另外翻译也是个技术活，不是随便翻译下就行。<br>ps：个人建议，在UI的图上进行修改，这样可以知道你的翻译是否满足页面展示的需求。</p>
<h2 id="后台可控"><a href="#后台可控" class="headerlink" title="后台可控"></a>后台可控</h2><p>在产品设计初期，部分产品习惯把所有规则都写在前端或者后端里面，这样做类似于饮鸠止渴，如果逻辑有变化，就需要上版本去更改，费时费力。<br>一个好的产品能够在产品设计初期，就把规则给想清楚，通过设计权限层或者读取数据库去控制规则。这样前期会耗费产品和开发很大精力，但是对于规则的维护和修改会方便很多。</p>
<h2 id="数据埋点"><a href="#数据埋点" class="headerlink" title="数据埋点"></a>数据埋点</h2><p>产品都知道，一个产品或者功能好还是不好，需要用数据说话，这就牵扯到一个很重要的点，如何对产品进行埋点。<br>简单的说三部分，第一确定产品的功能模块，哪些是比较重要的模块，哪些是需要验证的模块，第二进行合理的埋点，第三也是最重要的部分，进行数据分析。</p>
<h2 id="运营需求"><a href="#运营需求" class="headerlink" title="运营需求"></a>运营需求</h2><p>产品和运营不分家，运营会帮助产品进行更好的宣传，一个好的产品，会在产品内部留下一些运营扩展模块。比如广告位，活动入口等。</p>
<h1 id="APP-单个模块"><a href="#APP-单个模块" class="headerlink" title="APP 单个模块"></a>APP 单个模块</h1><p>以一个模块的页面的生命周期开始分析：<br>1、 初始状态<br>一个模块在用户第一次进来的时候长什么样，就是该模块的初始状态</p>
<p>2、加载状态<br>用户发送请求后，如果接口性能较低，就会需要一个加载状态，该状态可以是弹窗，可以是提示语，可以是loading标志</p>
<p>3、空状态<br>模块可能不存在数据，需要给用户以引导或者提示</p>
<p>4、数据较少<br>即数据较少时，页面展示效果是否友好，是否需要做特别的设计用以辅助展示</p>
<p>5、数据正常<br>需要产品第一个考虑的状态，也是模块应该有的常态</p>
<p>6、 数据过多<br>即，用户操作简单，筛选条件较少，后台返回数据较多时</p>
<p>7、错误状态<br>接口报错，无网络等</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[appium+ios10测试环境搭建]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2017/03/21/appium%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
      <content type="html"><![CDATA[<h1 id="Appium测试环境搭建（ios测试）"><a href="#Appium测试环境搭建（ios测试）" class="headerlink" title="Appium测试环境搭建（ios测试）"></a>Appium测试环境搭建（ios测试）</h1><blockquote>
<p>参考了很多网上的资料，自己也整理了一些，最终写成了这篇文章，感谢那些一直努力研究又乐于分享的测试前辈们。由于本人能力有限，所以肯定会有一些疏漏，还望大家谅解，时间紧任务重，使用的makedown排版。                                 ———— Enzo Chen</p>
</blockquote>
<a id="more"></a>
<h2 id="准备工组"><a href="#准备工组" class="headerlink" title="准备工组"></a>准备工组</h2><p>1）首先要有一台MAC机器，需要能够上网<br>2）MAC系统版本10+ ，Xcode版本8+，一个Apple id帐号（一般帐号or开发者都ok）外加 一款翻墙软件</p>
<h2 id="搭建须知"><a href="#搭建须知" class="headerlink" title="搭建须知"></a>搭建须知</h2><p>1）以下所有操作都是在<strong>‘非root用户’</strong>权限下执行，若在安装过程中出现权限相关问题，根据提示信息，进入root用户，把相应的文件权限修改一下，然后退出root用户，继续执行<br>进入root<br>‘’su root<br>退出root<br> ‘’exit<br>付权限  PathForFile指向相应的文件即可<br> ‘’chmod  -R 775   PathForFile</p>
<h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><p>1.安装brew</p>
<blockquote>
<p>brew 又叫 Homebrew，是 Mac OSX 上的软件包管理工具，能在 Mac 中方便的安装软件或者卸载软件， 只需要一个命令， 非常方便。brew 类似 ubuntu 系统下的 apt-get 的功能<br>安装命令<br>‘’ ruby -e “$(curl -fsSL <a href="https://raw.github.com/mxcl/homebrew/go" target="_blank" rel="external">https://raw.github.com/mxcl/homebrew/go</a>)”</p>
</blockquote>
<p>安装完成后，可以通过以下命令查看安装的版本，若能查看到版本信息则安装成功，若查不到，则表示安装失败<br>‘’ brew -v</p>
<p><img src="http://7xujfx.com1.z0.glb.clouddn.com/WX20170606-075116@2x.png" alt=""></p>
<p>2.安装 libimobiledevice</p>
<blockquote>
<p>在 windows or mac 上大家可以使用 iTunes 来与 iPhone 进行通信，但是 Linux 上没有这类的官方软件，所以一些爱好者就破解了 iTunes 的通信协议，然后在 Linux 上实现了该协议，也就是 libimobiledevice </p>
</blockquote>
<p>安装命令<br>‘’brew install libimobiledevice –HEAD </p>
<p>3.安装carthage</p>
<blockquote>
<p>提到 iOS/OS X 项目的依赖管理，最常用的有两个，CocoaPods和carthage，和CocoaPods相比carthage是一个简单、去集中化的 Cocoa 依赖管理器。说了这么多，其实就是萝卜白菜各有所爱，选那个都可以。</p>
</blockquote>
<p>安装命令<br>‘’ brew install carthage</p>
<p>4.安装node</p>
<blockquote>
<p>因为要用npm 所以要安装node，为什么一定要安装node，因为npm是node的套件管理工具</p>
</blockquote>
<p>最简单的安装方法<br>网站 [<a href="https://nodejs.org/en/download/" target="_blank" rel="external">https://nodejs.org/en/download/</a>] 直接下载相应版本的pkg进行安装</p>
<p>5.安装cnmp </p>
<blockquote>
<p>nmp不好用，存在不知名的网络问题，思考再三决定安装她妹妹cnmp<br>安装命令<br>‘’ npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="external">https://registry.npm.taobao.org</a></p>
</blockquote>
<p>6.安装ios-deploy</p>
<blockquote>
<p>ios-deploy 字如其名，是用来部署iOS的<br>‘’ cnpm install -g ios-deploy</p>
</blockquote>
<p>7.安装xcpretty</p>
<blockquote>
<p>xcpretty用于对 xcodebuild 的输出进行格式化。并包含输出 report 功能<br>‘’gem install xcpretty</p>
</blockquote>
<p>8.安装appium</p>
<blockquote>
<p>努力了这么久 终于可以安装appium了 根据当前最新版本号，更改安装命令后面的版本就行，截至本文写的时间目前最新的是1.6.3 （由于网络等原因，这一步耗时较长，且极容易报错，一定要多次尝试，革命刚开始，同志们需多努力）<br>‘’ cnpm install -g appium@1.6.3</p>
</blockquote>
<p>9.安装appium-xcuitest-driver依赖</p>
<blockquote>
<p>若你走到这一步，表示你终于走上了万里长征路的第一步</p>
</blockquote>
<p><img src="http://7xujfx.com1.z0.glb.clouddn.com/IMG_0756.JPG" alt=""></p>
<p>进入WebDriverAgent目录（你的路径可能和我的不一样，自己去找到它就好了）<br>‘’ cd  /usr/local/lib/node_modules/appium/node_modules/appium-xcuitest-driver/WebDriverAgent<br>‘’ mkdir -p Resources/WebDriverAgent.bundle<br>运行bootstrap    注意 此处需要翻墙，开启VPN<br>‘’sh ./Scripts/bootstrap.sh -d</p>
<p>10.使用xcode编译WebDriverAgent</p>
<blockquote>
<p>这里后面的步骤需要用到苹果帐号，如果有开发者帐号最好，不过我没有，开发者帐号是要钱的，但我穷。没有开发者帐号也没关系，xcode7之后苹果已经开始支持真机调试了，</p>
</blockquote>
<p>同步骤9，进入WebDriverAgent目录，使用鼠标轻轻的双击WebDriverAgent.xcodeproj 这个项目，不出意外的就会用xcode打开项目<br>1）编译 WebDriverAgentLib<br>步骤如下图，选中1打开编辑框，2中的bundle identifier默认是Facebook，但是需要改成自己的，随便改个就好，当然也最好不要和我的一样，万一咱俩冲突了也不好办，需要把3中的auto打开，xcode会提示你输入苹果帐号，你输入就好了，4中的team选择自己的帐号即可，需要注意的是5这里要保证signing这块没有报错。6这里选择最小的就好ios版本，个人感觉其实选9.0也是可以的，至少我这边是可以的。</p>
<p><img src="http://7xujfx.com1.z0.glb.clouddn.com/WX20170606-070607@2x.png" alt=""></p>
<p>2）编译 WebDriverAgentRunner<br>步骤1如下图，选中1打开编辑框，把2中的auto打开，在3中选择自己的帐号，4没有报错</p>
<p><img src="http://7xujfx.com1.z0.glb.clouddn.com/WX20170606-071604@2x.png" alt=""></p>
<p>步骤2如下图，选中1打开编辑框，2切换tab，切换到bulid settings，3选择这里的最小版本，我是后续补的截图，所以不要按照我截图去做，按照我说的去做，还是选择9.0吧，4修改bundle identifier成自己的</p>
<p><img src="http://7xujfx.com1.z0.glb.clouddn.com/WX20170606-071947@2x.png" alt=""></p>
<p>然后就可以编译了，正常情况下编译是没有错误，如果有错误，如果有错误应该是第10步哪出现了错误，根据错误提示信息自行修改就好了，祝好</p>
<p><img src="http://7xujfx.com1.z0.glb.clouddn.com/WX20170606-072407@2x.png" alt=""></p>
<ol>
<li>建立服务 WebDriverAgent </li>
</ol>
<p>此时需要把你心爱的iphone手机和心爱的mac电脑通过一只数据线连接起来<br>1）进入WebDriverAgent<br>‘’ cd  /usr/local/lib/node_modules/appium/node_modules/appium-xcuitest-driver/WebDriverAgent </p>
<p>2）执行测试语句<br>‘’xcodebuild -project WebDriverAgent.xcodeproj -scheme WebDriverAgentRunner -destination ‘id=真机的udid’ test</p>
<p>执行这个语句不出意外的话，你就会得到一个<strong>失败</strong>的提示，哈哈哈哈，惊不惊喜，意不意外</p>
<p><img src="http://7xujfx.com1.z0.glb.clouddn.com/FullSizeRender 9.jpg" alt=""></p>
<p>错误如下，</p>
<p><img src="http://7xujfx.com1.z0.glb.clouddn.com/WX20170606-080133@2x.png" alt=""></p>
<p>其实他的意思就是，你手机么有信任这个应用，这个时候进入手机的<strong>设置</strong>——<strong>通用</strong>——<strong>设备管理</strong> 然后信任你的帐号就可以了</p>
<p>完成上述操作后，你在执行2）语句，就会得到这样的界面，</p>
<p><img src="http://7xujfx.com1.z0.glb.clouddn.com/FullSizeRender 10.jpg" alt=""></p>
<p>恩，不要怀疑了，这就是正常执行的界面，代表你已经小小的成功了，这时候就可以晒图发朋友圈了。<br>闹，这就是我的朋友圈截图，哈哈哈哈哈</p>
<p><img src="http://7xujfx.com1.z0.glb.clouddn.com/IMG_2028.PNG" alt=""></p>
<p>12.运行appium</p>
<p>没什么好说的，一个语句<br>‘’ appium -p 4723<br>启动时间有点长，不过这点时间和安装时间相比是没什么的</p>
<p>13.桌面版appium-desktop</p>
<p>在安装appium的时候，偶然发现了appium-desktop这个，目前还是1.0.0版本，不过经过我的试用感觉还是不错的，已经给电脑装上了，也写了一个小栗子，具体使用方式可以自行研究，毕竟我只是个过客</p>
<p><img src="http://7xujfx.com1.z0.glb.clouddn.com/WX20170606-074425@2x.png" alt=""><br><img src="http://7xujfx.com1.z0.glb.clouddn.com/WX20170606-074434@2x.png" alt=""><br><img src="http://7xujfx.com1.z0.glb.clouddn.com/WX20170606-074510@2x.png" alt=""></p>
<p>14.运行appium-desktop可能会出现的一个问题，<strong>编号65</strong><br>‘’ Unable to launch WebDriverAgent because of xcodebuild failure: xcodebuild failed with code 65</p>
<p>解决方法<br>重新在你的真机上编译 WebDriverAgent<br>重新编译还会遇到问题可以尝试下：</p>
<pre><code>1.    到 webdriverAgent 目录下
2.    运行 sh ./Scripts/bootstrap.sh
3.    再使用 xCode build 一次。
</code></pre><p>我能给的不多，但能给的我都给了~</p>
<p><img src="http://7xujfx.com1.z0.glb.clouddn.com/WechatIMG62.jpeg" alt=""></p>
<p>自动化测试不是一时就可以学会，需要花费很长的时间去不断的学习和练习，希望大家多练习，遇到问题多百度，多谷歌，当然还要多github和stackoverflow。<br>啥，你不知道github和stackoverflow~~~<br><img src="http://7xujfx.com1.z0.glb.clouddn.com/IMG_1597.JPG" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[企查查产品研习]]></title>
      <url>http://i90s.vip/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/2017/03/12/%E4%BC%81%E6%9F%A5%E6%9F%A5%E4%BA%A7%E5%93%81%E7%A0%94%E4%B9%A0.html</url>
      <content type="html"><![CDATA[<h2 id="产品简介"><a href="#产品简介" class="headerlink" title="产品简介"></a>产品简介</h2><hr>
<p>产品名称：<br>slogan：<br>成立时间：<br>支持平台：<br>产品介绍：</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信产品设计原则——Genie访谈记录]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2017/03/08/%E5%BE%AE%E4%BF%A1%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.html</url>
      <content type="html"><![CDATA[<p><img src="http://7xujfx.com1.z0.glb.clouddn.com/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95.jpeg" alt=""></p>
<p>Genie是腾讯唯一一个p4（专家级）女产品经理，也是我知道的唯一一个p4产品经理，是从无到有搭建出微信的产品负责人，如果张小龙是上帝，那genie就是为上帝造人的那个人，坊间称之为“天朝第一产品经理”，这是第一次genie和大家系统的讲述微信的产品原则吧，这要感谢“产品＋”这个课程，不仅都是干货，而且都是高品质的精华。</p>
<p>最难的是大概道理我们都懂，但没抽离出来形成自己的产品原则，更难的是，你都知道，但是没消化成自己的东西，在做产品策划的时候还在不断犯这些错误。</p>
<p>废话不说，直接来吧。<a id="more"></a></p>
<p>对于熟人社交而言，三个价值导向：</p>
<p>根据这三条，在创建产品时很多产品逻辑和后台算法就能清晰的做出权重分配排序了。</p>
<h1 id="微信十条产品原则"><a href="#微信十条产品原则" class="headerlink" title="微信十条产品原则"></a>微信十条产品原则</h1><h2 id="隐私vs便利"><a href="#隐私vs便利" class="headerlink" title="隐私vs便利"></a>隐私vs便利</h2><blockquote>
<p>隐私重要性大于便利</p>
</blockquote>
<p>案例：常有用户抱怨为什么换一台手机所有聊天记录都没了，为什么登陆网页版每次聊天记录都是从零开始，为什么聊天记录不能每次同步存储，因为一旦换设备/微信网页版每次登陆都显示之前的聊天记录，很可能别人在其他设备登陆你微信，所有记录都看到了，这种隐私泄漏给你带来的风险比聊天记录清零带来的伤害大得多，基于隐私性大于便利性原则，即使聊天记录清零可能带来不便利，依旧优先隐私性。所以微信在手机本地聊天记录不保存，宁可不够便利，也不牺牲隐私体验；</p>
<h2 id="发送方vs接收方"><a href="#发送方vs接收方" class="headerlink" title="发送方vs接收方"></a>发送方vs接收方</h2><blockquote>
<p>你觉得发送方和接收方哪个更重要？保护两端感受，但当两方有冲突时，更保护的是接收方，微信的产品理念认为接收方体验大于发送方。</p>
</blockquote>
<p>案例：</p>
<p>a.因为这个产品原则，所以微信到现在没做已读体验。而阿里做社交的产品理念认为发送方比接收方重要，所以之前阿里的叮叮（不确定来往是不是）每发一条信息都会告知你已读未读状态，这让发送方很爽，我希望知道你是否看到了我的信息，但让接收方很有压力，因为我看到了不代表我现在想回你，但你知道我看到了，我不回你就显得没礼貌了，所以，用的时候压力很大，老板喜欢这样的功能，员工用的很受罪。所有产品体验都是基于产品原则作出的决策，对于从无到有创造一个产品，需要先建立起自己的产品原则。</p>
<p>b.接收方体验优于发送方第二个细节：白底黑字比绿底黑字更清楚，所以微信里白底黑字展示给了好友发的信息，而自己发的话自己本来就清楚，所以自己发的文字底色是绿底黑字。</p>
<p>c.接收方体验优于发送方第三个细节：很多人提为什么短视频不支持自拍功能，因为自拍需求大多是女生的需求，这让自拍的人挺爽，但试想一下当朋友圈被各种妹子自拍占领，就一个头，还会动，对于接收方而言，其实看的没那么爽，而且还挺恐怖，所以考虑到接收方体验没有做小视频自拍</p>
<h2 id="缺乏价值支撑的流量，事倍功半"><a href="#缺乏价值支撑的流量，事倍功半" class="headerlink" title="缺乏价值支撑的流量，事倍功半"></a>缺乏价值支撑的流量，事倍功半</h2><p>这句话需要很深入的去理解，因为我们经常犯这样的错误，现在大多数app的思路还是引流，拉下载，框用户，流量是一千万有1%的用户转化，就有10万真实用户，所以不断找流量，而大多流量被浪费了，如果将思路放在提高被浪费的99%的转化，走精准路线，或许100万流量就能达到10万用户了；除此外，会员增值／游戏付费／谈n个风投也是一样的道理，基于拉过来的人多了，里面总有愿意掏钱的，走的都是海量流量低转化率的思路，这种就是缺乏价值支撑的流量，太浪费了，而小而精的模式就是公测1000人，500人活跃，200人愿意付费，这种就是现在越来越多人走的垂直化精细化的运营方式，不需要买那么多没用的流量，保证高转化就行。</p>
<h2 id="对用户而言固定路径是最近路径"><a href="#对用户而言固定路径是最近路径" class="headerlink" title="对用户而言固定路径是最近路径"></a>对用户而言固定路径是最近路径</h2><p>案例：很多人在问为什么不能让最近发送的表情在最近的位置；原因是每次发表情都会改变表情顺序，每次打开表情顺序都被改动，反而会延迟找到想要表情的时间，觉得表情不好用。最快的路径永远是固定的路径。</p>
<h2 id="不一定按数据说话，按用户需求和价值说话"><a href="#不一定按数据说话，按用户需求和价值说话" class="headerlink" title="不一定按数据说话，按用户需求和价值说话"></a>不一定按数据说话，按用户需求和价值说话</h2><blockquote>
<p>这条我是真的很佩服微信，是微信很牛的地方，也是绝大部分产品很难做到的地方 我们习惯了一切按数据说话，数据不好的产品就下线，数据不好的功能就下架，不赚钱的东西就撤掉，也是因为这么浮躁的心态，让极致的好产品出不来。</p>
</blockquote>
<p>案例：小视频发送入口有两个：一个是顶上下拉发小视频，另一个是朋友圈右上角发小视频，请问你认为哪个入口使用人数更多呢？停顿两秒让自己思考下吧。</p>
<p>答：朋友圈右上角?占95%，上方下拉只占了5%，朋友圈右上角加号入口虽然更深，但用户已形成通过右上角加号发新内容的操作体验，而下拉体验用户没有形成习惯</p>
<p>那么，为什么只有5%的用户通过下拉来拍摄小视频，还没把这个入口干掉，如果按数据说话应该干掉这个入口，那为什么没干掉？ 答：因为我们不是完全按数据说话的产品，更重视用户体验：主界面快捷方式对于要拍摄稍纵即逝的瞬间，需要最短路径马上拍摄，如果撤掉，当遇到非常好瞬间要拍摄的时候，拍摄路径太长会导致错过很多好的瞬间，并且这些稍纵即逝的瞬间的内容价值可能远高于慢慢从固定路径录制的内容价值。</p>
<h2 id="清醒地知道产品每个功能的价值"><a href="#清醒地知道产品每个功能的价值" class="headerlink" title="清醒地知道产品每个功能的价值"></a>清醒地知道产品每个功能的价值</h2><blockquote>
<p>数据只是反应现状的参考指标，而不是结果本身效率价值对大化value/time（单位时间内的信息量）：文字图片 url视频哪个性价比最高，哪个信息量最大：url信息量最大，图片性价比最高，视频的信息量很大但性价比最低。</p>
</blockquote>
<p>微信里体现价值信息最大化原则案例：1.朋友圈点赞没有头像，2.小视频自动播放，3.url的弱化，4.文字太长时折叠，5.单图vs多图：单图缩略图很大，最高效率，不用点开大图也可以看清楚，而多图的时候会变成小的缩略图，这时候接收方的诉求是要第一时间知道这九张图核心要说的信息是什么，点开大图再看具体内容。</p>
<h2 id="不同很易，更好很难"><a href="#不同很易，更好很难" class="headerlink" title="不同很易，更好很难"></a>不同很易，更好很难</h2><p>案例1：当时apple watch邀请微信做一个适合watch的产品，第一个版本微信做了雷达加好友，放在watch上看很创新又帅气，但apple没有采用雷达加好友这个方案，why?</p>
<p>答：1.附近没几个人带手表，2.在手机上都没几个人用雷达加好友，何况手表上呢，这个属于然并卵的功能。比如新浪微博做的watch版app的功能是跑步记步功能，但微博属于信息类的，做个计步器和微博有啥关系，无法体现产品核心价值；所以最后还是选择把收发消息，看朋友圈，赞等基础核心功能发上去，做实用性的东西比做帅气不同的东西更有价值，不为创新而创新，不为不同而不同。</p>
<p>案例2:为什么要做小视频：1.视频信息含量是最高的，是文字和图片无法比拟的；2.有些场景是很难用文字描述的，视频可以解决；而做小视频是因为大视频信息量很大，收看时间长，信息价值不高，所以用6秒小视频来做到既有信息量，又保证信息价值。反例是qq空间，空间一直有长视频，看到微信出了短视频，也把自己的长视频改成短视频，结果被用户投诉的要死，这就是产品经理没有想清楚自己的产品定位，一味模仿追随，空间最擅长的是沉淀，长视频是最好的沉淀形式之一，更别说空间还有pc阅读特性等差别。不同很易，更好很难。</p>
<p>微信最大的价值是有关系链有朋友，不用通过和同类产品比内容价值来凸显自己：我不是为了拍一个有趣的视频给你，而是告诉你我在哪在干嘛。如果微信要做小视频，要做的是信息，而不是内容，不是视频美化。很清晰的看到自己的位置，不盲目的和同类产品攀比，从来不是与外部赛跑，而是与自己pk的过程。</p>
<h2 id="简洁的原则"><a href="#简洁的原则" class="headerlink" title="简洁的原则"></a>简洁的原则</h2><blockquote>
<p>简洁不是简单，简洁不是简单的把功能裁掉。</p>
</blockquote>
<p>案例：为什么iPhone刚开始的icon是拟物设计，这种设计实际是很复杂的，在一个图标上每个角度纹理都要处理，但对于用户而言拟物很真实，学习成本更低，在智能手机刚面世的时候可以降低学习成本。</p>
<p>为什么现在的iPhone要做扁平化，不再坚持拟物：因为智能机的普及，每个icon是做什么的，用户已经都理解了，不需要再用拟物的方式去普及，而扁平的icon并没有比拟物的简单，反而在设计上可能是更复杂了，需要用更简洁的方式让用理解icon。</p>
<h2 id="逻辑原则vs线性原则"><a href="#逻辑原则vs线性原则" class="headerlink" title="逻辑原则vs线性原则"></a>逻辑原则vs线性原则</h2><blockquote>
<p>避免用tabs，保持一个入口。如果你有两个tab的话，就会有一个主tab，按已有的数据显示2个tab会二八分配，80%的流量在主tab，只剩下20%的流量到第二个tab。如果你已经能决定哪个tab是核心，那为什么还需要第二个tab，如果你没办法决定哪个最重要，那分tab也没办法为你决定，还是会二八分流，专注主要功能，把所有流量聚焦在一个tab，不作无谓分流。不用多tab展示，一个地方不要两个按钮。（这点很多app都在犯这个错误）。</p>
</blockquote>
<p>在逻辑原理和线性原则相冲突的时候，优先线性原则：</p>
<p>案例：微信的搜索原本是放在顶上加号旁边放一个放大镜的icon，但最后还是把搜索框直接加在聊天记录顶部的搜索框，而不是右上角放一个?一个搜索两个icon（抗拒两个icon，坚持线性原则）</p>
<h2 id="真实vs噱头"><a href="#真实vs噱头" class="headerlink" title="真实vs噱头"></a>真实vs噱头</h2><blockquote>
<p>真实性大于噱头，真实的内容才有生命力，噱头往往是对信息的破坏。</p>
</blockquote>
<p>案例：美拍等视频拍摄工具都有配音，加特效等功能，美化后让整个视频变的很好看，但微信不会做这些，因为美化后的视频，去掉了声音等，无法还原给朋友传递信息的真实现场。真实性还体现在微信的所有数据，各种对外的方式都秉持真实性。 精品打磨</p>
<p>注重细节：收到多条语音，会自动播放语音；语音可以上滑取消等</p>
<p>极致的细节分享：</p>
<p>细节1:小视频播放完后从最后一秒到第一秒循环时直接切换会导致视觉上闪过一下，脑子里会闪过一条白线，为了让这个闪不那么不舒服，在小视频最后一秒做了颜色渐弱，通过一秒弱化让用户视觉舒服地过渡。绝大部分用户是不会感知到微信做了这个体验优化的，好的产品让人用的爽，而不需要让人知道他们为什么爽。</p>
<p>细节2:视频和照片的夜视效果在爱疯上不是特别好，所以微信的小视频和照片在监测到光线比较暗时，会提示加亮效果（为了这个小细节微信团队找过世面上所有产品比对各种相机产品，将加亮模式做到极致）</p>
<h1 id="常见的坑和注意事项"><a href="#常见的坑和注意事项" class="headerlink" title="常见的坑和注意事项"></a>常见的坑和注意事项</h1><h2 id="从目标倒推方案"><a href="#从目标倒推方案" class="headerlink" title="从目标倒推方案"></a>从目标倒推方案</h2><blockquote>
<p>比如我们要50万用户，那倒推要三件事每件事引流10万 20万 20万，按此方式可能会达到kpi目标，但很可能会背离你设计这个产品的初衷，用手段而不是产品功能达到目标，但这不是真的解决问题的方法</p>
</blockquote>
<p>案例：提升海外活跃度：发现当用户好友数超过15个时，活跃度会增加很多；所以当时的做法是引导加好友，然后又引导加陌生人，好友数还不够，就改版附近的人，这种就是按目标倒推数据方案的反例。数据可以帮助你了解原因，但不会告诉你原因。一个成功的决策，不知道原因，比一个失败的决策更危险。（这点非常重要，很多团队觉得达到kpi了就万事大吉，而不去分析是用的牺牲未来的短期营销达到的，还是真的是产品优质达到的；这个错误是每天每个产品，团队都在犯的，能意识到这点的存在本身已经很不容易。）</p>
<h2 id="关于AB-test（分组测试）"><a href="#关于AB-test（分组测试）" class="headerlink" title="关于AB test（分组测试）"></a>关于AB test（分组测试）</h2><blockquote>
<p>AB test可以用来对比效果，而不是选择方案，用的越多，表明产品经理判断力越弱</p>
</blockquote>
<p>使用AB test时要有很明确的选择，并且知道影响因素是不可控的。</p>
<h2 id="普通用户没法告诉你他们自己还不知道的需求，需求是产品经理去观察发现的。"><a href="#普通用户没法告诉你他们自己还不知道的需求，需求是产品经理去观察发现的。" class="headerlink" title="普通用户没法告诉你他们自己还不知道的需求，需求是产品经理去观察发现的。"></a>普通用户没法告诉你他们自己还不知道的需求，需求是产品经理去观察发现的。</h2><p>不要去问用户你觉得我怎么做会比较好，因为他不知道，或者只是他以为他知道。很多人用mac觉得很好用，但在mac出来前你会知道你需要的好用的电脑是酱紫的么？比如很多用户使用任务软件时，主动设置很多任务，并且都加上了提醒，当用户主动加提醒时觉得自己想要被提醒，但当每天都被提醒n次时就开始烦了，关掉提醒甚至直接删除这个app。</p>
<h2 id="能用标准方法／标准控件解决问题就不要用特殊处理"><a href="#能用标准方法／标准控件解决问题就不要用特殊处理" class="headerlink" title="能用标准方法／标准控件解决问题就不要用特殊处理"></a>能用标准方法／标准控件解决问题就不要用特殊处理</h2><p>以上是一整个下午听genie分享产品原则记录下来的笔记和心得，也是在听过的众多产品课程里最有收获和启发的一场，有的产品是被抬到神坛的，而有的产品是靠实力走上去的，我从不搞什么个人崇拜，但觉得genie以及微信在产品设计上做出的每个决策都有自己的产品原则作为方向标，是非常值得欣赏的，不是微信从没决策失误过，而是每个精良的产品都是在不断试错中越来越完美的，对于创建一个新产品亦是如此，不怕一遍遍试错，就怕不思考不知道错。很感谢genie和如此好的产品精品课程，受益良多。</p>
<p>上述产品原则和体验就我自己而言感悟很深，很多原则需要再多次反复消化，对未来做产品很有启发，被提炼出的真理难的是在从无到有的提炼过程，而享受前人成果时，我们太容易因为理所当然，而忽略了每个真理对于现实运用的意义。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如花谢花开——《思悼》观后感]]></title>
      <url>http://i90s.vip/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/2017/02/23/%E5%A6%82%E8%8A%B1%E8%B0%A2%E8%8A%B1%E5%BC%80.html</url>
      <content type="html"><![CDATA[<p><img src="http://7xujfx.com1.z0.glb.clouddn.com/%E6%80%9D%E6%82%BC.jpg" alt=""><br>一部两小时电影断断续续看了四天才看完<br>《思悼》虽然描写的皇宫内权利的斗争 用宫斗剧是解释它并不准确  我感觉更像是一部家庭伦理片<br>一个只想当王的父亲<br>一个只想当儿子的储君<a id="more"></a><br>父子情在影片中表现的淋漓尽致<br>英祖希望世子能早日即位 又不甘心交出权力<br>世子相比王位 更愿得到世祖的爱<br>帝王之家 非比寻常人家 有太多的不可以<br>有时候越是简单的 越无法得到<br>英祖自己的登基有着太多不可细说的过去<br>他一直严格要求世子 让他读书 教他如何权衡庙堂之上的各方势力 但他又无意完全放下权利 父亲的制衡 让世子事事无法得愿<br>被嫌弃的松子的一生啊<br>父子俩虽然彼此并不认同 但仍维持着这微妙的平衡 世孙的出现  让英祖看到了另外一种可能 找到了更适合王位的人 这种微妙的平衡随即被打破<br>第七日父子阴阳相隔的对话 将父子俩内心的纠结表现的淋漓尽致 也将全剧感情推向了高潮<br>第八日 英祖用手去摸米缸里的世子 摸到鼻子时发现世子已经没了呼吸 又赶快用手去摸颈部 英祖当时肯定很纠结吧 即不想让儿子死 又不想让他活着  当他确认儿子已经死掉的时候 瞬间崩溃 嚎啕大哭  哭完 让乐队又奏着凯旋曲回宫<br>高墙华锦为君臣 来生麻衣愿父子<br>世孙从小就知道忍耐 也知道要讨好英祖<br>世子在射箭时和世孙的对话 也暗示了全剧的结局<br>世孙说 我也不喜欢这样的我<br>特别是在他登基后给母亲过花甲时 说 我从小就没玩过 今天就让我尽兴的玩一次吧<br>世孙的扇子舞配上片尾曲 如花谢花开<br>将沉默克制的全片基调打破  让众人能够毫无顾忌的流泪发泄内心的感情</p>
<h2 id="附上片尾曲-《如花谢花开》-歌词"><a href="#附上片尾曲-《如花谢花开》-歌词" class="headerlink" title=" 附上片尾曲 《如花谢花开》 歌词 "></a><strong> 附上片尾曲 《如花谢花开》 歌词 </strong></h2><p>如今吾欲去<br>独留伤悲于世<br>纵有千语 未能与君诉<br>托付浮云 就此别去<br>难了却 君之所愿<br>泪如雨 潜然落<br>空留歉疚 孑然离<br>如花开花谢<br>虚空飘荡浮游<br>委身清风别过<br>曾空虚凌晨时分 与星做伴<br>如今吾亦别过<br>纵彼此念念不忘<br>纵然相对 仍难触碰<br>缘何未能相见<br>兴许君心深处一隅<br>吾之体温仍残留<br>清风吹 消散前<br>就此一次 轻抚吾之脸庞<br>此文章为 不知名的工程师 原创，特此声明！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[风控与征信]]></title>
      <url>http://i90s.vip/%E4%BA%A7%E5%93%81%E7%AC%94%E8%AE%B0/2017/02/12/%E9%A3%8E%E6%8E%A7%E4%B8%8E%E5%BE%81%E4%BF%A1.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Jmeter使用随笔-4]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2017/01/04/Jmeter%E4%BD%BF%E7%94%A8%E9%9A%8F%E7%AC%94-4.html</url>
      <content type="html"><![CDATA[<h2 id="Jmeter启动报错"><a href="#Jmeter启动报错" class="headerlink" title="Jmeter启动报错"></a>Jmeter启动报错</h2><p>　　前段时间电脑重装系统，习惯性的解压了Jmeter压缩包开始修改脚本，但是竟然神奇的报错了····<br>　　报错内容是”Not able to find Java executable or version. Please check your Java installation”，感觉应该是环境变量没有配置，上网查了下配置方法 <a id="more"></a></p>
<p>网上查的解决方法大部分是在环境变量PATH中添加： %SystemRoot%/system32;%SystemRoot%<br>但是添加了之后发现还是无法正常启动，又查找了一些网页，找到了另外一个方法<br>解决方法：在环境变量PATH里加%JAVA_HOME%\bin；<br>添加之后，就可以正常启动了</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Jmeter链接Oracle数据库]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2017/01/03/Jmeter%E9%93%BE%E6%8E%A5Oracle%E6%95%B0%E6%8D%AE%E5%BA%93.html</url>
      <content type="html"><![CDATA[<h2 id="JmeterのJDBC-Request"><a href="#JmeterのJDBC-Request" class="headerlink" title="JmeterのJDBC Request"></a>JmeterのJDBC Request</h2><blockquote>
<p>JDBC Request：这个sqmpler可以向数据库发送一个jdbc请求（SQL语句），并获取返回的数据库数据的操作，它经常需要和JDBC Connertion Configuration配置原件一起使用，主要是配置数据库的相关属性，比如ip，帐号，密码，链接数等。</p>
</blockquote>
<ol>
<li>添加数据库jar包</li>
</ol>
<p>不同的数据库，需要添加的jar包不同，需要根据需求下载自己需要的jar包。<br>下载完成后，可以通过以下两种方式安装jar包<a id="more"></a><br>1）直接将jar包复制到jmeter的lib目录下（推荐）<br>2）通过Tset Plan添加<br>在’add directory or jar to classpath’里面把jar包的路径添加进去</p>
<ol>
<li>配置JDBC Connection Configuration</li>
</ol>
<p>参数含义;<br>. Variable Name:数据库连接池的名称，可以添加多个JDBC Connection Configuration，每个可以七个不同的名称，再jdbc request中可以通过这个名字选择不同的连接池<br>. Database URL：数据库url，具体配置如下<br>. JDBC Driver class:JDBC驱动<br>. username：数据库登录用户名<br>. password：数据库登录密码</p>
<p>不同数据库填写表格：</p>
<table>
<thead>
<tr>
<th>Database</th>
<th>Driver calss</th>
<th>Database URL</th>
</tr>
</thead>
<tbody>
<tr>
<td>MySQL</td>
<td>com.mysql.jdbc.Driver</td>
<td>jdbc:mysql://host:port/{dbname}</td>
</tr>
<tr>
<td>PostgreSql</td>
<td>org.postgresql.Driver</td>
<td>jdbc:postgresql:{dbname}</td>
</tr>
<tr>
<td>Oracle</td>
<td>oracle.jdbc.driver.OracleDriver</td>
<td>jdbc:oracle:thin:user/pass@//host:port/service</td>
</tr>
<tr>
<td>ingres(2006)</td>
<td>ingres.jdbc.IngresDriver</td>
<td>jdbc:ingres://host:port/db[;attr=value]</td>
</tr>
<tr>
<td>MSSQL</td>
<td>com.microsoft.sqlserver.jdbc.SQLServerDriver</td>
<td>jdbc:sqlserver://ip:1433;databaseName=DBname</td>
</tr>
</tbody>
</table>
<ol>
<li>配置JDBC Request</li>
</ol>
<p>参数含义：<br>. variable Name：数据连接池名字，需要和JDBC Connection Configuration的Variable Name保持一致<br>. Query：填写的SQL语句，末尾不需要加‘;‘<br>. Parameter values：参数值<br>. Parameter types:参数类型，可参考 ：javadoc for java.sql。types<br>. variable names：保存sql语句返回结果的变量名<br>. Result variable name: 创建一个对象变量，保存所有返回的结果<br>. Query timeout：查询超时时间<br>. Handle result set：定义如何处理由callable statements语句返回的结果</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RF使用笔记-2]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/12/27/RF%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0-2.html</url>
      <content type="html"><![CDATA[<h2 id="第一个RF脚本"><a href="#第一个RF脚本" class="headerlink" title="第一个RF脚本"></a>第一个RF脚本</h2><ol>
<li><p>启动RF</p>
<p>安装好RF后，桌面会生成一个图标，双击图标启动，界面如下 <a id="more"></a><br><img src="启动页面" alt=""></p>
</li>
<li><p>创建项目</p>
<p>选择菜单栏file-&gt;new project(快捷键ctrl+N)<br>Name：项目名称（例如：test测试项目，可以是中文）<br>Parent Directory：项目路径（尽量是英文路径，以防出现各种乱七八糟的错误）<br>Type：<strong>需要选择Directory</strong><br><img src="创建项目" alt=""></p>
</li>
<li><p>创建测试套件</p>
<p>右键点击’测试项目’选择new Suite<br>Name：输入测试模块名称（例如：百度首页模块）<br>Type：选择File<br><img src="测试套件" alt=""></p>
</li>
<li><p>创建测试用例</p>
<p>右键点击’百度首页模块’选择new Test Case<br>name：测试用例的名字（名字主要是测试的功能点）<br><img src="测试案例" alt=""></p>
</li>
<li><p>导入seleniumslibrary库</p>
<p>左键点击测试套件’百度首页模块’，在其’edit’的tab页上，点击右边的’library’，再弹出框「name」内输入’Selenium2Library’，注意大小写，点击’ok’</p>
<blockquote>
<p>使用RF编写web的测试用例，需要selenium库的支持，所以需要加载Selenium2Library库<br>点击OK后，若Selenium2Library显示为黑色表示导入成功，若是红色表示没有查找到这个库<br>![]（倒库）</p>
</blockquote>
</li>
<li><p>查询脚本关键字<br>在写测试用例的时候，需要用到很多关键字，可以使用F5查询关键字，点击F5，弹出如下页面，<br>可在search term框里输入关键字</p>
<p><img src="关键字" alt=""></p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RF使用笔记-1]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/12/19/RF%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0-1.html</url>
      <content type="html"><![CDATA[<h2 id="安装chromeDriver"><a href="#安装chromeDriver" class="headerlink" title="安装chromeDriver"></a>安装chromeDriver</h2><p>　　RF默认的是FireFox和IE浏览器，鉴于目前chrome市场占有率及良好的开发环境，RF测试建议使用chrome进行测试</p>
<p>1、ChromeDriver下载地址<br><a id="more"></a><br><a href="https://chromedriver.storage.googleapis.com/index.html?path=2.26/" target="_blank" rel="external">ChromeDriver下载地址</a></p>
<blockquote>
<p>chrome驱动并不是指在电脑上安装chrome浏览器就可以，而是chrome驱动</p>
</blockquote>
<p>2、ChromeDriver.exe 放置地址</p>
<p>ChromeDriver的安装地址需要<strong>添加到系统的环境变量里</strong>，只有这样在运行RF时候才能找到ChromeDriver</p>
<blockquote>
<p>我是直接把ChromeDriver.exe放到了 C:\python27\Scripts 路径下。</p>
</blockquote>
<p>3、Chrome 闪退</p>
<p>完成以上动作之后，在运行RF时发现chrome闪退，网上搜索了下，发现并没有比较好的解决方法，看到一篇文章里面说是chrome版本的问题，看了下自己当前的版本是49，然后升级成了53，再运行RF后发现chrome不再闪退，如果大家也有闪退情况，可以升级或者降级下chrome版本试试</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Jmeter使用随笔（3）]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/12/05/Jmeter%E4%BD%BF%E7%94%A8%E9%9A%8F%E7%AC%94-3.html</url>
      <content type="html"><![CDATA[<p>使用Jmeter的过程中发现，当Jmeter运行一个小时左右，就会报Out of memory error的错误。<br>网上查了下解决该问题的方法，需要两步<a id="more"></a><br>1）修改配置</p>
<p>使用 jmeter 进行压力测试时遇到一段时间后报内存溢出 outfmenmory 错误，导致 jmeter 卡死了，先尝试在 jmeter.bat 中增加了 JVM_ARGS=”-Xmx2048m -Xms2048m -Xmn256m -XX:PermSize=128m -Xss256k”，但结果运行时间增加了，但最终还是报内存溢出，百度后按照网友的建议更改了如下设置后 jmeter 就没有再卡了：<br>windows 环境下，修改 jmeter.bat：</p>
<p>set HEAP=-Xms256m -Xmx256m<br>set NEW=-XX:NewSize=128m -XX:MaxNewSize=128m<br>改为：<br>set HEAP=-Xms256m -Xmx1024m<br>set NEW=-XX:NewSize=128m -XX:MaxNewSize=512m</p>
<p>linux 环境下，修改 jmeter.sh：<br>java $JVM_ARGS -Xms1G -Xmx5G -XX:MaxPermSize=512m -Dapple.laf.useScreenMenuBar=true -jar <code>dirname $0</code>/ApacheJMeter.jar “$@”</p>
<p>2）修改脚本监控<br>在Jmeter脚本中，由于’查看结果树’等监控一直在消耗内容，在前期判断脚本正常后，后期跑长时间高并发时，需要去掉’查看结果树’监控</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[为什么有些人开车到家后会独自坐在车中发呆]]></title>
      <url>http://i90s.vip/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/2016/10/31/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%9B%E4%BA%BA%E5%BC%80%E8%BD%A6%E5%88%B0%E5%AE%B6%E5%90%8E%E4%BC%9A%E7%8B%AC%E8%87%AA%E5%9D%90%E5%9C%A8%E8%BD%A6%E4%B8%AD%E5%8F%91%E5%91%86.html</url>
      <content type="html"><![CDATA[<p>关于一个问题和这个问题的答案</p>
<p>最近看到知乎网上有人提问了一个问题，觉得很值得分享给大家：</p>
<p>问题是：为什么有些人开车到家后会独自坐在车中发呆？</p>
<p>回答的人有很多，有人说因为车里好安静，有种小时候看树下蚂蚁搬家时的平静。</p>
<p>还有人说，是因为车里那首歌没听完 <a id="more"></a></p>
<p>有个朋友说，他不仅喜欢把车开到家门口停一会儿，有时候他甚至绕过家门口掉个头奔快环，有无数个想不明白的夜晚，他一个人开着音响在高速上兜圈。 他的最高纪录是开着暖气熄了灯坐在车里静静的看着人们在楼下银行的 atm 机里取钱，来来往往，看了一个小时。</p>
<p>很难理解对不对？</p>
<p>好好的家不回</p>
<p>车里又没有志玲姐姐</p>
<p>为啥喜欢待在车里？</p>
<p>后来<br>回答的人越来越多<br>…<br>…<br>直到有个人说——<br>很多时候我也不想下车，因为那是一个分界点。推开车门你就是柴米油盐、是父亲、是儿子、是老公，唯独不是你自己；在车上，一个人在车上想静静，抽颗烟，这个躯体属于自己。</p>
<p>这个答案迅速获得了超过 4000 人的赞同。</p>
<p>是啊，活着真的太累。每天带着各种面具忍着各种脾气面对着各种人。不断对自己灌输 “成年人”“成熟” 的行为准则，就算回到家也要小心面对自己的父母妻子，照顾他们的情绪，得不到半点轻松。可我有时候也是会想任性的啊！只有在车里，一个幽暗狭小的空间，一支忽明忽灭的香烟，晚上 fm 主持人轻柔的话语，才会让你有种与世隔绝的感觉，也才会让你意识到 “自我” 的存在，那种感觉实在太好。</p>
<p>当然，并非只有男士才有这种喜欢在车里发呆的习惯，有些女性也有相同的感觉。还有人发自内心的建议姑娘们稍微有点实力就买个小车，真的是既私密又体贴。吵架了伤心了难过了不怕没有去处，油门一蹬四处晃荡，哭一场可以撑半年，然后补个妆回去，厚着脸皮嬉皮笑脸继续把游戏玩下去。</p>
<p>我们每天扮演着各种各样的角色：</p>
<p>在公司，你或是下属，或是上司；</p>
<p>在学校，你或是学生，或是老师；</p>
<p>在家里，你或是丈夫，或是妻子；</p>
<p>甚至走在大街上，你也或是男神女神，或是屌丝女汉子，再不济也是个路人。</p>
<p>唯独在车里的那么一小会儿，你就是你自己。</p>
<p>听着没有放完的曲子，感受此时此刻无需伪装，没有杂质的纯净。</p>
<p>心里想着：“还好有这样一个时刻，我什么也不是，就是我自己。还好。”</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Jmeter使用随笔(2)]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/09/21/Jmeter%E4%BD%BF%E7%94%A8%E9%9A%8F%E7%AC%94-2.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>现在好多网站再用户成功登录时会返回一个登录凭证，在之后的操作上都要带上这个凭证。在使用Jmeter测试的过程中我们需要获取这个凭证。<br>jmeter提供了正则表达式提取器，用变量提取参数，后续通过${变量名}引用参数。</p>
</blockquote>
<h2 id="sessionKey值"><a href="#sessionKey值" class="headerlink" title="sessionKey值"></a>sessionKey值</h2><p>添加方式 线程组-后置处理器-正则表达式提取器<a id="more"></a></p>
<p><img src="http://ww1.sinaimg.cn/large/666cc9e3gw1fafxrg4xmwj21kw0zdqar.jpg" alt=""></p>
<p>. 引用名称：其他地方引用提取值的变量名称，如填写的是sessionKey,具体引用方式是${sessionKey}<br>. 正则表达式：提取内容的正则表达式【需要注意：（）表示提取，对于你要提取的内容需要用小括号括起来】<br>. 模板：用$$引用起来，如果在正则表达式中有多个提取表达式（多个括号括起来的），则可以是$1$,$2$等，表示解析到的第一个值给sessionKey，正则表达式的提取模式，值从1开始，值0对应的是整个匹配的表达式<br>. 匹配数字：0表示随机，-1表示所有，其余正整数代表将在已提取的内容中，第几个匹配的内容<br>. 缺省值：正则表达式匹配失败时，取的值</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Jmeter 使用随笔(1)]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/09/19/Jmeter-%E4%BD%BF%E7%94%A8%E9%9A%8F%E7%AC%94.html</url>
      <content type="html"><![CDATA[<h2 id="HTTP信息头管理器-Content-type"><a href="#HTTP信息头管理器-Content-type" class="headerlink" title="HTTP信息头管理器 Content-type"></a>HTTP信息头管理器 Content-type</h2><p>Content-type：在Request Hearder里，告诉服务器我们发送的请求信息是那种格式的。</p>
<p>1 默认值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-type：application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>
<p>参数格式：key1=value1 &amp; key2=value2</p>
<p>jmeter参数使用方法<br>(1)Paramenters<br><img src="http://ww1.sinaimg.cn/large/666cc9e3gw1f7yzjihid6j21g711lag9.jpg" alt=""><a id="more"></a><br>(2)Body Data<br><img src="http://ww4.sinaimg.cn/large/666cc9e3gw1f7zw1flrz2j21gd12pq8v.jpg" alt=""></p>
<p>2 Json格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-type:application/json</span><br></pre></td></tr></table></figure>
<p>参数格式：<br>{<br>    “key1”:”value1”,<br>    “key2”:”value2”<br>}</p>
<p>jmeter参数使用方法<br>(1)添加HTTP信息头管理器<br><img src="http://ww4.sinaimg.cn/large/666cc9e3gw1f7zw6hlpapj21g30h8mz4.jpg" alt=""><br>(2)Body Data输入参数<br><img src="http://ww1.sinaimg.cn/large/666cc9e3gw1f7zw4o86zxj21fh11qn35.jpg" alt=""></p>
<p>3 传输文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-type:multipart/form-data</span><br></pre></td></tr></table></figure>
<p>(1)HTTP请求页面，勾选Use multipart/form-data for POST<br>(2)Paramenters中输入除了要上传的文件以外的参数<br><img src="http://ww1.sinaimg.cn/large/666cc9e3gw1f7zw940lqgj21fd10zq8p.jpg" alt=""><br>(3)File Upload中上传文件，填写参数名和MIME类型<br><img src="http://ww1.sinaimg.cn/large/666cc9e3gw1f7zwbfcq90j21fe0zdgsi.jpg" alt=""></p>
<h2 id="返回值中文乱码"><a href="#返回值中文乱码" class="headerlink" title="返回值中文乱码"></a>返回值中文乱码</h2><p>（1）再jmeter安装文件夹中找到bin文件夹，用记事本打开jmeter.properties文件<br>（2）修改sampleresult.default.encoding=UTF-8</p>
<blockquote>
<p>注意去掉sampleresult.default.encoding=UTF-8前面的#号</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac下安装Jmeter]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/09/04/Mac%E4%B8%8B%E5%AE%89%E8%A3%85Jmeter.html</url>
      <content type="html"><![CDATA[<h2 id="下载Jmeter"><a href="#下载Jmeter" class="headerlink" title="下载Jmeter"></a>下载Jmeter</h2><p><a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="external">Apache JMeter 3.0</a><br>将压缩包解压</p>
<h2 id="配置Jmeter环境"><a href="#配置Jmeter环境" class="headerlink" title="配置Jmeter环境"></a>配置Jmeter环境</h2><p>JMeter 是基于 Java 的框架，所以要求系统必须安装JDK。<a id="more"></a></p>
<p><strong>查看mac是否已经安装JDK</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/666cc9e3jw1f7ho5ekughj214d0d0q7i.jpg" alt=""></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -<span class="built_in">version</span></span><br></pre></td></tr></table></figure>
<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">JDK下载地址</a></p>
<h2 id="运行Jmeter"><a href="#运行Jmeter" class="headerlink" title="运行Jmeter"></a>运行Jmeter</h2><p>进入apache-jmeter-3.0的bin目录下<br>运行 sh jmeter 即可打开jmeter软件</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd apache-<span class="keyword">jmeter-3.0/bin</span><br><span class="line"></span><span class="keyword">sh </span><span class="keyword">jmeter</span></span><br></pre></td></tr></table></figure>
<p><img src="http://ww3.sinaimg.cn/large/666cc9e3gw1f7hola8tkkj21kw0zkgrz.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于CS,一些你不知道的事]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/09/03/%E5%85%B3%E4%BA%8ECS-%E4%B8%80%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>偶然间在论坛上看到的一篇文章，值得思考<br>非常感谢<a href="http://bbs.gter.net/thread-1717877-1-1.html" target="_blank" rel="external">irvine666</a></p>
</blockquote>
<p>　　为了增加可信度，先介绍一下自己。我本科毕业于上海交通大学计算机系，后在上海从事 IT2 年，期间曾经试图创业但失败。然后申请美国大学硕士拿到半奖出国，毕业后到加州硅谷一家超大型公司从事 IT 工作。后因为一些原因跳槽到总部在波士顿的另一家超大型公司接着做 IT 到现在。所以我可以保证：看一下这篇文章并不会浪费我们共同的时间。</p>
<p>　　首先必须承认，CS 是最近 10 年来在美国最好找工作的职业，这点各位差不多都已经知道了，但是接下来的一些东西会让你们知道为什么宣传转 CS 的都是一些非 CS 专业的人，真正的 CS 从业者很少会劝人转 CS。<br><a id="more"></a><br>1、  程序员并不是一个能够长期从事的职业</p>
<p>　　按照业内人士的话来讲，CS 这个行业：越老越不值钱。原因很简单，CS 的技术每天都在更新换代，速度之快已经到了你如果 2 个月不碰它，那么就很难赶上进度。真正的 CS 工作是这样的：每 1-2 周，你会负责把一整个模块搭建起来，在计划书当中包括了好几个你根本没有听说过的东西。你的任务就是在 1-2 周之内，把这些东西全部学懂，然后应用到你的模块当中，并调试通过保证没有任何的漏洞。这个需要很强的学习和应用能力以及很强的熬夜能力。在年纪大了以后，很难比拼过刚毕业 1-2 年的员工。试想一下，你如果作为老板，是愿意聘用每年 12-15 万的 40 岁的有老婆孩子身体也不太好老请病假的老员工，还是 8-10 万一年的能熬夜干劲足没有家庭牵挂的小青年呢？</p>
<p>2、 程序员意味着私人和家庭生活的匮乏</p>
<p>　　除了少数几个养老公司以外（比如：IBM，Salesforce，以及 3 年前的微软），我所了解的绝大部分 IT 公司加班乃至昼夜颠倒是非常正常的事情。如果你能够晚上 7 点下班，并保证回家不加班，那么说明你是非常非常厉害的一个人。过度的加班往往意味着只能牺牲自己的私人和家庭时间。如果你是单身青年，你不会有时间去好好谈恋爱，挑选人生的伴侣；如果你结婚了，你会发现除非配偶不工作，你很难有时间和精力生孩子；如果你有家庭，你的老婆孩子甚至不会感觉到你的存在，你面对电脑的时间会远远超过陪伴他们的时间，而这个，在 5-20 年会有很严重的后果，具体的后果包括家庭破裂，子女叛逆不孝等等。我不止一次听我们的各个老程序员抱怨后悔年轻时没有时间陪伴家人。</p>
<p>3、  程序员的工作对身体伤害很大</p>
<p>　　还是那句话，长期加班 + 心里孤独，会导致很多问题。30 岁左右就脊椎扭曲甚至心态不正常的程序员不在少数，更多数的会带有一生的病痛，手指痉挛，背痛得无法躺下，腿部供血不足，头痛欲裂等等现象会伴随你度过每一个晚上。</p>
<p>4、  程序员的前景并不明朗</p>
<p>　　看待一个行业，并不能够只看它辉煌的时期，而是应当从一生的角度来选择。举个典型的例子，记得我在刚进大学的时候，信息保护和光伏工程这两个专业是最火的，因为所有毕业生都被各大公司疯抢。但是在我毕业的时候，甚至都没有听说过有几个学校还在开办这些专业。就是因为那几年所有的学校都在开办，毕业生的人数迅速超过了社会的需求，同时由于新的技术出现，导致原来的公司迅速被淘汰，就业需求大大减少。从目前来看，CS 这个行业已经充斥着很多泡沫，如果你们能去搜索一下各个 IT 上市公司的 P/E 数据就会发现，整个 tech 板块都充斥着不理性的投资，这个泡沫能吹多大或者还能持续几年？我不知道，但是我知道一旦泡泡破了，大量的 CS 从业人员将会受到影响，裁员失业是不可避免的事情。从目前来看，NASDAQ 已经出现了一些崩盘的征兆，在过去的几周当中，所有的 IT 公司股票都下跌了 25% 左右。</p>
<p>5、  程序员这个行业竞争已经过于激烈</p>
<p>　　虽然大部分 IT 公司还在招人，但是请记住他们只要 “最好” 的人，并不是所有的程序员都能被他们看上。由于人才市场的爆满，合格的 candidate 会获得非常高的报酬，但也意味着即使你成功获得 offer，你所面临的压力会更大。我举 Facebook 为例，它给出的报酬在业内也是算 1，2 名了，但是当你接受 offer 开始，你便面临这残酷的竞争。所有 facebook 的新员工必须经过一个为期 6 周的训练营，在这个期间，你必须学会 facebook 的开发，调试，搭配环境并自己写出一些东西来证明自己。训练营的淘汰率为 10%，也就是说，所有合格拿到 offer 的人（已经很厉害了）当中，10% 的人入职不会超过六周就被 fire。即使你成功通过训练营，每个季度会考核你的 performance，最后 5%-10% 的人将被 fire 掉。这些被裁掉的人的位置，将由更优秀的人来填补。在硅谷，绝大多数公司可能没有训练营淘汰制，但是他们都会有每个季度或者每年的淘汰制。所以拿到 OFFER 才是痛苦的开始。要留下来，只能玩命。</p>
<p>6、  程序员的绿卡之路并不会比别的职业顺利多少</p>
<p>　　首先，程序员的绿卡排期和其他专业是一样的。其次，大家可能还不知道美国政府有一个特别坑爹的规定：“如果一个公司出现 layoff 性质的裁员，那么这个公司所有的绿卡程序将会被拖延半年”。这个规定使得在一些 IT 公司，那绿卡成为 IMPOSSIBLE。比如 ECM。这种公司的宗旨就是业绩说话，他们每年会新建很多的 team，但是到了年底，表现一般的 team 就会被整个裁掉，这样来保证自己整个公司的业绩始终是上升的。在这种公司，每个月都会裁员，即使给你开始办绿卡了，你也永远看不到被批准的一天。相比起来，其他的行业比 IT 稳定多了，一旦开始排期，拿绿卡也会更为顺利。而如果能做到博士或者博后，甚至能够凭借文章申请杰出人才绿卡，在几个月内被批准。</p>
<p>　　所以说，程序员这个职业并不是像外界评论的一样无可匹敌 。它有自己的优势也会有劣势。我想更准确的说法是，如果你决定从事 CS，那么你必须：1. 非常感兴趣，喜欢这个行业；或者 2. 你不喜欢这个行业，但是你愿意用自己的青春，健康，自己未来的私人和家庭生活去换取一些金钱或者短期的荣耀。 </p>
<p>　　最后，我想说任何行业都有成功的人，任何成功的人都具有的一个特点就是几十年如一日的坚持。我希望每个人都有自己的坚持，如果只是听别人说说就决定转这个转那个，那永远不会有成功的一天。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[和软件测试有关的那些事]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/07/11/%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.html</url>
      <content type="html"><![CDATA[<h2 id="1-什么是软件测试？"><a href="#1-什么是软件测试？" class="headerlink" title="1. 什么是软件测试？"></a>1. 什么是软件测试？</h2><p>软件测试是为了发现错误而执行程序的过程。或者说，软件测试是根据软件开发各阶段的规格说明和程序的内部结构而精心设计一批测试用例(即输入数据及其预期的输出结果)，并利用这些测试用例去运行程序，以发现程序错误的过程。</p>
<h2 id="2-软件测试的目的"><a href="#2-软件测试的目的" class="headerlink" title="2.  软件测试的目的?"></a>2.  软件测试的目的?</h2><p>测试的目的是想以最少的人力、物力和时间找出软件中潜在的各种错误和缺陷，通过修正种错误和缺陷提高软件质量，回避软件发布后由于潜在的软件缺陷和错误造成的隐患带来的商业风险。<a id="more"></a></p>
<h2 id="3-什么是需求文档测试？"><a href="#3-什么是需求文档测试？" class="headerlink" title="3. 什么是需求文档测试？"></a>3. 什么是需求文档测试？</h2><p>主要测试需求中是否存在逻辑矛盾以及需求在技术上是否可以实现。</p>
<h2 id="4-什么是设计文档测试"><a href="#4-什么是设计文档测试" class="headerlink" title="4. 什么是设计文档测试?"></a>4. 什么是设计文档测试?</h2><p>测试设计是否符合全部需求以及设计是否合理。</p>
<h2 id="5-什么是α测试"><a href="#5-什么是α测试" class="headerlink" title="5. 什么是α测试?"></a>5. 什么是α测试?</h2><p>Alpha测试(α测试)是由<strong>一个用户在开发环境下进行的测试</strong>，也可以是公司内部的用户在模拟实际操作环境下进行的受控测试，Alpha测试不能由程序员或测试员完成。Alpha测试发现的错误，可以在测试现场立刻反馈给开发人员，由开发人员及时分析和处理。目的是评价软件产品的功能、可使用性、可靠性、性能和支持。尤其注重产品的界面和特色。Alpha测试可以从软件产品编码结束之后开始，或在模块(子系统)测试完成后开始，也可以在确认测试过程中产品达到一定的稳定和可靠程度之后再开始。有关的手册(草稿)等应该在Alpha测试前准备好。</p>
<h2 id="6-什么是β测试"><a href="#6-什么是β测试" class="headerlink" title="6. 什么是β测试?"></a>6. 什么是β测试?</h2><p>Beta测试(β测试)是软件的<strong>多个用户在一个或多个用户的实际使用环境下</strong>进行的测试。开发者通常不在测试现场，Beta测试不能由程序员或测试员完成。因而，Beta测试是在开发者无法控制的环境下进行的软件现场应用。在Beta测试中，由用户记下遇到的所有问题，包括真实的以及主管认定的，定期向开发者报告，开发者在综合用户的报告后，做出修改，最后将软件产品交付给全体用户使用。Beta测试着重于产品的支持性，包括文档、客户培训和支持产品的生产能力。只有当Alpha测试达到一定的可靠程度后，才能开始Beta测试。由于Beta测试的主要目标是测试可支持性，所以Beta测试应该尽可能由主持产品发行的人员来管理。</p>
<h2 id="7-什么是驱动模块？"><a href="#7-什么是驱动模块？" class="headerlink" title="7. 什么是驱动模块？"></a>7. 什么是驱动模块？</h2><p>驱动模块在大多数场合称为”主程序”，它接收测试数据并将这些数据传递到被测试模块.单元测试一个函数单元时，被测单元本身是不能独立运行的，需要为其传送数据，为此写驱动<br>驱动模块主要完成以下事情：<br>1、接受测试输入;<br>2、对输入进行判断;<br>3、将输入传给被测单元，驱动被测单元执行;<br>4、接受被测单元执行结果，并对结果进行判断;<br>5、将判断结果作为用例执行结果输出测试报告。</p>
<h2 id="8-什么是桩模块"><a href="#8-什么是桩模块" class="headerlink" title="8. 什么是桩模块?"></a>8. 什么是桩模块?</h2><p>比如对函数A做单元测试时，被测的函数单元下还包括了一个函数B，为了更好的错误，定位错误，就要为函数B写桩，来模拟函数B的功能，保证其正确。</p>
<h2 id="9-什么是白盒测试"><a href="#9-什么是白盒测试" class="headerlink" title="9. 什么是白盒测试?"></a>9. 什么是白盒测试?</h2><p>:白盒测试(White-box Testing，又称逻辑驱动测试,结构测试),它是知道产品内部工作过程，可通过测试来检测产品内部动作是否按照规格说明书的规定正常进行，按照程序内部的结构测试程序，检验程序中的每条通路是否都有能按预定要求正确工作，而不顾它的功能，白盒测试的主要方法有逻辑驱动、基路测试等，主要用于软件验证。对开发语言的支持：白盒测试工具是对源代码进行的测试，测试的主要内容包括词法分析与语法分析、静态错误分析、动态检测等。目前测试工具主要支持的开发语言包括：标准C、C++、Visual C++、Java、Visual J++等。</p>
<h2 id="10-什么是静态测试"><a href="#10-什么是静态测试" class="headerlink" title="10. 什么是静态测试?"></a>10. 什么是静态测试?</h2><p>通过运行程序测试软件称为测试.通过评审文档、阅读代码等方式测试软件称为静态测试,在动态测试中,通常使用白盒测试和黑盒测试从不同的角度设计测试用例,查找软件代码中的错误.<br>     <strong>静态测试方法是指不运行被测程序本身</strong>，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性。对需求规格说明书、软件设计说明书、源程序做结构分析、流程图分析、符号执行来找错。静态方法通过程序静态特性的分析，找出欠缺和可疑之处，例如不匹配的参数、不适当的循环嵌套和分支嵌套、不允许的递归、未使用过的变量、空指针的引用和可疑的计算等。静态测试结果可用于进一步的查错，并为测试用例选取提供指导。</p>
<h2 id="11-什么是回归测试"><a href="#11-什么是回归测试" class="headerlink" title="11. 什么是回归测试?"></a>11. 什么是回归测试?</h2><p>回归测试的目的是在程序有修改的情况下，保证原有功能正常的一种测试策略和方法。说白了就是，我们测试人员在对程序进行测试时发现bug，然后返还程序员修改，程序员修改后发布新的软件包或新的软件补丁包给我们测试人员，我们就要重新对这个程序测试，已保证程序在修正了以前bug的情况下，正常运行，且不会带来新的错误的这样一个过程。 一般情况下是不需要全面测试的，而是根据修改的情况进行有效的测试。</p>
<h2 id="12-白盒测试有哪几种方法"><a href="#12-白盒测试有哪几种方法" class="headerlink" title="12. 白盒测试有哪几种方法?"></a>12. 白盒测试有哪几种方法?</h2><p>白盒测试也称结构测试或逻辑驱动测试，它是知道产品内部工作过程，可通过测试来检测产品内部动作是否按照规格说明书的规定正常进行，按照程序内部的结构测试程序，检验程序中的每条通路是否都有能按预定要求正确工作，而不顾它的功能，白盒测试的主要方法有逻辑驱动、基路测试等，主要用于软件验证。“白盒”法全面了解程序内部逻辑结构、对所有逻辑路径进行测试。“白盒”法是穷举路径测试。</p>
<h2 id="13-软件的缺陷等级应如何划分"><a href="#13-软件的缺陷等级应如何划分" class="headerlink" title="13. 软件的缺陷等级应如何划分?"></a>13. 软件的缺陷等级应如何划分?</h2><p>1）致命错误，可能导致本模块以及其他相关模块异常，死机等问题;<br>2）严重错误，问题局限在本模块，导致模块功能失效或异常退出<br>3）一般错误，模块功能部分失效;<br>4）建议问题，由问题提出人对测试对象的改进意见;</p>
<h2 id="14-如果能够执行完美的黑盒测试，还需要进行白盒测试吗-白盒与黑盒的区别"><a href="#14-如果能够执行完美的黑盒测试，还需要进行白盒测试吗-白盒与黑盒的区别" class="headerlink" title="14. 如果能够执行完美的黑盒测试，还需要进行白盒测试吗?(白盒与黑盒的区别)"></a>14. 如果能够执行完美的黑盒测试，还需要进行白盒测试吗?(白盒与黑盒的区别)</h2><p>任何工程产品(注意是任何工程产品)都可以使用以下两种方法之一进行测试。<br>黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。 白盒测试：已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否以经过检查。<br>软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试或数据驱动测试。黑盒测试主要是为了发现以下几类错误：<br>1、是否有不正确或遗漏的功能?<br>2、在接口上，输入是否能正确的接受?能否输出正确的结果?<br>3、是否有数据结构错误或外部信息(例如数据文件)访问错误?<br>4、性能上是否能够满足要求?<br>5、是否有初始化或终止性错误?<br>软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试或逻辑驱动测试。白盒测试主要是想对程序模块进行如下检查：<br>1、对程序模块的所有独立的执行路径至少测试一遍。<br>2、对所有的逻辑判定，取“真”与取“假”的两种情况都能至少测一遍。<br>3、在循环的边界和运行的界限内执行循环体。<br>4、测试内部数据结构的有效性，等等。<br>以上事实说明，软件测试有一个致命的缺陷，即测试的不完全、不彻底性。由于任何程序只能进行少量(相对于穷举的巨大数量而言)的有限的测试，在未发现错误时，不能说明程序中没有错误。</p>
<h2 id="15-软件测试应该划分几个阶段-简述各个阶段应重点测试的点-各个阶段的含义"><a href="#15-软件测试应该划分几个阶段-简述各个阶段应重点测试的点-各个阶段的含义" class="headerlink" title="15. 软件测试应该划分几个阶段?简述各个阶段应重点测试的点?各个阶段的含义?"></a>15. 软件测试应该划分几个阶段?简述各个阶段应重点测试的点?各个阶段的含义?</h2><p>大体上来说可分为单元测试,集成测试,系统测试,验收测试,每个阶段又分为以下五个步骤: 测试计划，测试设计，用例设计，执行结果，测试报告初始测试集中在每个模块上，保证源代码的正确性，该阶段成为单元测试，主要用白盒测试方法。 接下来是模块集成和集成以便组成完整的软件包。集成测试集中在证实和程序构成问题上。主要采用黑盒测试方法，辅之以白盒测试方法。软件集成后，需要完成确认和系统测试。确认测试提供软件满足所有功能、性能需求的最后保证。确认测试仅仅应用黑盒测试方法。</p>
<h2 id="16-什么是单元测试？"><a href="#16-什么是单元测试？" class="headerlink" title="16. 什么是单元测试？"></a>16. 什么是单元测试？</h2><p>单元测试是对软件中的基本组成单位进行的测试，如一个模块、一个过程等等。它是软件动态测试的最基本的部分，也是最重要的部分之一，其目的是检验软件基本组成单位的正确性。</p>
<h2 id="17-什么是集成测试？"><a href="#17-什么是集成测试？" class="headerlink" title="17. 什么是集成测试？"></a>17. 什么是集成测试？</h2><p>集成测试是在软件系统集成过程中所进行的测试，其主要目的是检查软件单位之间的接口是否正确。</p>
<h2 id="18-什么是系统测试？"><a href="#18-什么是系统测试？" class="headerlink" title="18. 什么是系统测试？"></a>18. 什么是系统测试？</h2><p>系统测试是对已经集成好的软件系统进行彻底的测试，以验证软件系统的正确性和性能等满足其规约所指定的要求，检查软件的行为和输出是否正确并非一项简单的任务，它被称为测试的“先知者问题”。</p>
<h2 id="19-什么是验收测试？"><a href="#19-什么是验收测试？" class="headerlink" title="19. 什么是验收测试？"></a>19. 什么是验收测试？</h2><p>收测试旨在向软件的购买者展示该软件系统满足其用户的需求。它的测试数据通常是系统测试的测试数据的子集.</p>
<h2 id="20-针对缺陷采取怎样的管理措施"><a href="#20-针对缺陷采取怎样的管理措施" class="headerlink" title="20. 针对缺陷采取怎样的管理措施?"></a>20. 针对缺陷采取怎样的管理措施?</h2><p>1）要更好的管理缺陷，必须引入缺陷管理工具，商用的或者开源的都可。<br>2）根据缺陷的生命周期，考虑缺陷提交的管理、缺陷状态的管理和缺陷分析的管理。<br>3） 所有发现的缺陷(不管是测试发现的还是走读代码发现的)都必须全部即时的、准确的提交到缺陷管理工具中，这是缺陷提交的管理。<br>4）缺陷提交后，需要即时的指派给相应的开发人员，提交缺陷的人需要密切注意缺陷的状态， 帮助缺陷的尽快解决。缺陷解决后需要即时对缺陷的修复进行验证。这样的目的有两个：一个是让缺陷尽快解决;二是方便后面缺陷的分析(保证缺陷相关的信息准确，如龄期等)，这是缺陷状态的管理。<br>5）为了更好的改进开发过程和测试过程，需要对缺陷进行分析，总结如缺陷的类别、缺陷的龄期分布等信息，这是缺陷分析的管理。</p>
<h2 id="21-单元测试、集成测试、系统测试的侧重点是什么"><a href="#21-单元测试、集成测试、系统测试的侧重点是什么" class="headerlink" title="21.单元测试、集成测试、系统测试的侧重点是什么?"></a>21.单元测试、集成测试、系统测试的侧重点是什么?</h2><p>单元测试是在软件开发过程中要进行的最低级别的测试活动，在单元测试活动中，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试，测试重点是系统的模块，包括子程序的正确性验证等。 集成测试，也叫组装测试或联合测试。在单元测试的基础上，将所有模块按照设计要求，组装成为子系统或系统，进行集成测试。实践表明，一些模块虽然能够单独地工作，但并不能保证连接起来也能正常的工作。程序在某些局部反映不出来的问题，在全局上很可能暴露出来，影响功能的实现。测试重点是模块间的衔接以及参数的传递等。系统测试是将经过测试的子系统装配成一个完整系统来测试。它是检验系统是否确实能提供系统方案说明书中指定功能的有效方法。测试重点是整个系统的运行以及与其他软件的兼容性。</p>
<h2 id="22-描述使用bugzilla缺陷管理工具对软件缺陷-BUG-跟踪的管理的流程"><a href="#22-描述使用bugzilla缺陷管理工具对软件缺陷-BUG-跟踪的管理的流程" class="headerlink" title="22.描述使用bugzilla缺陷管理工具对软件缺陷(BUG)跟踪的管理的流程"></a>22.描述使用bugzilla缺陷管理工具对软件缺陷(BUG)跟踪的管理的流程</h2><p>1) 测试人员或开发人员发现bug后，判断属于哪个模块的问题，填写bug报告后，系统会自动通过Email通知项目组长或直接通知开发者。<br>2) 经验证无误后，修改状态为VERIFIED.待整个产品发布后，修改为CLOSED.<br>3) 还有问题，REOPENED，状态重新变为“New”，并发邮件通知。<br>4) 项目组长根据具体情况，重新reassigned分配给bug所属的开发者。<br>5) 若是，进行处理，resolved并给出解决方法。(可创建补丁附件及补充说明)<br>6) 开发者收到Email信息后，判断是否为自己的修改范围。<br>7) 若不是，重新reassigned分配给项目组长或应该分配的开发者。<br>8) 测试人员查询开发者已修改的bug，进行重新测试。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[五分钟战胜 Python 字符编码]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/06/28/%E4%BA%94%E5%88%86%E9%92%9F%E6%88%98%E8%83%9C-Python-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81.html</url>
      <content type="html"><![CDATA[<p>对于很多接触 Python 的人而言，字符的处理和语言整体的温顺可靠相比显得格外桀骜不驯难以驾驭。</p>
<p>本文不谈复杂的理论，就经验教你字符处理八字真言：确定编码，同类交互。</p>
<p>文章针对 Python 2.7 ，主要因为 3 对的编码已经有了很大的改善并且实际原理一样，更改一下操作命令即可。</p>
<p>了解完本文，你可以轻松解决文字处理，特殊平台（ Windows?）下的编码，爬虫编码等问题。</p>
<p>阅读建议 <a id="more"></a></p>
<p>本文分为如下几个部分：</p>
<blockquote>
<p>原理<br>具体操作<br>建议的使用习惯<br>疑难问题解答</p>
</blockquote>
<p>如果想要了解我给出的使用习惯，可以直接跳到建议的使用习惯。</p>
<p>如果只想要解决相关问题可以直接跳到疑难问题解答。</p>
<p>希望本文能够帮到你。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>为了理解方便，这里不谈理论只做类比，具体想要进一步了解各种编码的理论的搜狗一下好了。</p>
<p>首先说一下我们为什么会碰到各式各样的编码问题：</p>
<p>因为我们没有统一编码<br>因为我们没有用对命令（传对数据）<br>再说一下编码是什么， Python 的编码看似复杂，实际上可以看做只有两类编码： Unicode ，二进制</p>
<p>Unicode 相信都很熟悉：，就是\u0000这样的<br>二进制编码也很简单，就是\x00\x00这样的，平常看到的utf-8,cp936都是二进制编码<br>二进制编码是具象的，10001100原样就可以存储，而 Unicode 是抽象的，不能这样存<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Unicode 编码演示</span></span><br><span class="line">print(<span class="string">'Unicode:'</span>)</span><br><span class="line">print(repr(<span class="string">u'Unicode 编码'</span>))`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二进制编码演示</span></span><br><span class="line">print(<span class="string">u'二进制编码:'</span>)</span><br><span class="line">print(repr(<span class="string">'Unicode 编码'</span>))`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只是看个样子，代码不必去深究</span></span><br></pre></td></tr></table></figure></p>
<p>再说怎么做，就是只有同种编码之间才可以操作</p>
<p>举个简单的类比<br>就把一串数据比为烤鸭，我们作为人和鸭子不同种看待烤鸭的态度完全不一样。<br>我们看到的是晚上的配菜，鸭子看到的是自己二舅。<br>那么我在逛烤鸭店的时候用错编码就会报错。<br>因为我在烤鸭店看到了满世界的二舅。<br>这里说的同种就是我们熟悉的各种编码方式：utf-8,unicode,ucs-bom<br>这也就是编码问题的核心，非常重要。<br>最后说一下 Python 的环境</p>
<p>本身代码是用 Ascii 解码的，文件里有 Ascii 无法解码的内容的话要告知 Python 怎么解码<br>内部大量命令都是默认接受 Unicode<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 告知的命令就是下面这一行，删掉就会报错</span></span><br><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line">print(<span class="string">u'测试编码'</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>拿到各种编码的内容自然是不用说，那么如果我们想要自己构造怎么做呢，看下面：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串前面加 u 会默认构造出 Unicode 的字符串</span></span><br><span class="line">unicodeString = <span class="string">u'Unicode 字符串'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串前面什么都不加会构造出默认编码（首行限定了现在的 utf8 ）的字符串</span></span><br><span class="line">utf8String = <span class="string">'Utf-8 字符串'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然，没有首行，默认的编码是 Ascii</span></span><br><span class="line">那么他们之间怎么转换呢，同样很简单：</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接上一段程序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Unicode 转化为二进制编码中的一种： utf8</span></span><br><span class="line">unicodeString.encode(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二进制编码根据自己的编码种类转化为 Unicode</span></span><br><span class="line">utf8String.decode(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果二进制编码中混进了奇怪的东西可以根据需求用特殊的 decode 策略</span></span><br><span class="line">print(repr(<span class="string">'u8 字\x00 符串'</span>.decode(<span class="string">'utf8'</span>, <span class="string">'replace'</span>)))</span><br><span class="line">那么怎么样会出现问题呢：</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接上一段程序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果我们把他们转化成同样的编码方式就可以操作（例如相加）</span></span><br><span class="line">print(repr(unicodeString + utf8String.decode(<span class="string">'utf8'</span>)))</span><br><span class="line">print(repr(unicodeString.encode(<span class="string">'utf8'</span>) + utf8String))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但如果不转化，当然就会出现满世界的烤鸭二舅啦</span></span><br><span class="line">unicodeString + utf8String</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以另一方面也发现，编码转换是需要我们告诉程序怎么做的</span></span><br><span class="line"><span class="comment"># 所有`decode`操作都会生成 Unicode 编码，这是为了方便我之前说的大量接受 Unicode 的内部命令</span></span><br></pre></td></tr></table></figure></p>
<p>所以我们需要确定程序使用的编码，这是我们需要告诉程序的东西</p>
<p>一方面在操作字符串的时候确定是同种编码<br>另一方面在使用非自己写的命令时，一般使用 Unicode ，或者使用接收二进制编码的命令<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"><span class="comment"># 这里拿写入文件举例</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般使用 Unicode</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'Unicode.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f: f.write(<span class="string">u'Unicode 测试'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用接收二进制编码的命令</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'Utf8.txt'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f: f.write(<span class="string">'Utf8 测试'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 你可以反过来做个测试，自然会报错</span></span><br><span class="line"><span class="comment"># 二进制的命令方便了在不知道怎么解码的情况下也能进行操作（写入文件）</span></span><br></pre></td></tr></table></figure></p>
<p>我建议的使用习惯</p>
<p>相信到这里我已经把我对于编码的理解讲完了。</p>
<p>我们为什么会碰到各式各样的编码问题：</p>
<p>因为我们没有统一编码<br>因为我们没有用对命令（传对数据）<br>所以这里再重申一下八字真言：确定编码，同类交互</p>
<p>碰到问题，问一下自己，我现在是哪种编码<br>同一种编码才能交互，那我应该是哪种编码<br>这里给出我的使用习惯：</p>
<p>确定一种内部编码<br>内部编码的选择优先级如下：程序必须使用的编码、第三方包使用的编码、你喜欢的编码、 Unicode<br>在输出时再更改到特定的编码<br>记得在开始整个程序之前确定内部的编码，否则编码一团糟会产生很多不必要的 bug 。</p>
<p>不要迷信内部 Unicode ，例如 Evernote 开发就应该根据第三方包使用的 Utf8 确定内部编码。</p>
<h2 id="疑难问题解答"><a href="#疑难问题解答" class="headerlink" title="疑难问题解答"></a>疑难问题解答</h2><p>编码识别</p>
<p>说了要确定编码，那么拿到一串二进制要怎么确定编码呢？</p>
<p>最简单的方法是chardet：（需要安装）</p>
<p>python -m pip install chardet<br>使用非常简单：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> chardet <span class="keyword">import</span> detect</span><br><span class="line">print(detect(<span class="string">'这是一串 utf8 的测试字符'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：`&#123;'confidence': 0.99, 'encoding': 'utf-8'&#125;`</span></span><br></pre></td></tr></table></figure></p>
<p>另外例如抓取网站，那么头文件中很有可能有提示如何解码，记得不要忘记了。</p>
<p>编码转换</p>
<p>很可能因为字符串中参杂了奇怪的东西，导致即使编码种类正确，依旧无法解码。</p>
<p>我知道我之前讲过了，但可能有人直接跳疑难问题解答嘛。</p>
<p>这里可以使用decode的第二个参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串中混进了\x00</span></span><br><span class="line">rubbishUtf8String = <span class="string">'Utf-8 字\x00 符串'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(repr(rubbishUtf8String.decode(<span class="string">'utf8'</span>, <span class="string">'replace'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(repr(rubbishUtf8String.decode(<span class="string">'utf8'</span>, <span class="string">'ignore'</span>)))</span><br></pre></td></tr></table></figure></p>
<p>特殊平台下编码</p>
<p>很多人都说 Windows 是个坑，即使在 Python 3 下面也一样。</p>
<p>因为中文文件名出来都是乱码。</p>
<p>这里使用一个取巧的方法：平台编码再特殊，起码命令行读取和创建一个文件夹不会出乱码吧。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> folder <span class="keyword">in</span> os.walk(<span class="string">'.'</span>).next()[<span class="number">1</span>]:</span><br><span class="line">    print(folder.decode(sys.stdin.encoding))</span><br><span class="line">同样的输入输出也可以这样做优化：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sys_print</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(msg.encode(sys.stdin.encoding))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sys_input</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> raw_input(msg.encode(sys.stdin.encoding)).decode(sys.stdin.encoding)</span><br></pre></td></tr></table></figure></p>
<p>文件写入</p>
<p>如果抓下来一个内容不知道怎么解码，但还是想要写入文件怎么办</p>
<p>写入文件的时候制定用二进制命令即可：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line">import urllib</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'Utf8.txt'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f: f.<span class="built_in">write</span>(<span class="string">'Utf8 测试'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比如抓了个网页，不知道编码也可以写入文件进行一系列操作</span></span><br><span class="line"></span><br><span class="line">content = urllib.urlopen(<span class="string">'http://www.baidu.com'</span>).<span class="built_in">read</span>()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'baidu.txt'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f: f.<span class="built_in">write</span>(content)</span><br></pre></td></tr></table></figure></p>
<p>裸 Unicode 字符</p>
<p>Unicode 存成六个 Ascii 字符怎么办？其实也可以decode<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"><span class="comment"># 这是普通的 Unicode</span></span><br><span class="line">s = <span class="string">u'测'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s: print(i)</span><br><span class="line">print(repr(s))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是裸 Unicode ，实际存成了六个 Ascii</span></span><br><span class="line">s = repr(s)[<span class="number">2</span>:<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s: print(i)</span><br><span class="line">print(repr(s))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转化其实也很简单</span></span><br><span class="line">s = s.decode(<span class="string">'unicode-escape'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s: print(i)</span><br><span class="line">print(repr(s))</span><br></pre></td></tr></table></figure></p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>希望读完这篇文章能对你有帮助，有什么不足之处万望指正（鞠躬）。</p>
<p>有什么想法或者想要关注我的更新，欢迎来Github上Star或者Fork我的项目。</p>
<p>160623</p>
<p>LittleCoder</p>
<p>EOF<br><a href="http://www.v2ex.com/t/287727#reply23" target="_blank" rel="external">转载自V2EX</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[测试分类]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/06/13/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>本篇博文属于对软件测试领域的科普篇，关于软件测试领域，名词颇多，发现有许多测试新手混淆概念，甚至有不少招聘要求中对各种软件测试相关的名词乱用，所以，这里汇总测试相关的名词，也许能理清你对各种名词的概念。</p>
</blockquote>
<h2 id="根据项目流程阶段划分测试"><a href="#根据项目流程阶段划分测试" class="headerlink" title="根据项目流程阶段划分测试  "></a>根据项目流程阶段划分测试  <a id="more"></a></h2><hr>
<p><img src="http://ww1.sinaimg.cn/large/666cc9e3gw1f4tzicsxz2j20df08e74e.jpg" alt=""><br>上图是一个典型瀑布式软件开发流程，那么各项软件测试工作是在项目开发流程中循序渐进的进行的。下面将介绍下测试的含义。</p>
<p><strong>单元测试：</strong> 单元测试是对软件中的基本组成单元进行的测试。目的是检验软件基本组成单位的正确性。</p>
<p><strong>集成测试：</strong>集成测试是在软件系统集成过程中所进行的测试。目的是检查软件单位之间的接口是否正确。</p>
<p><strong>系统测试：</strong>系统测试是对已经集成好的的软件系统进行彻底的测试，以验证软件系统的正确性和性能等是否满足其规约所指定的要求。</p>
<p><strong>验收测试：</strong>验收测试是部署软件之前的最后一个测试操作。验收测试的目的是确保软件准备就绪，向软件购买商展示该软件系统满足其用户的需求。</p>
<h2 id="单元测试阶段"><a href="#单元测试阶段" class="headerlink" title="单元测试阶段"></a>单元测试阶段</h2><p><strong> 模块接口测试 </strong><br>　　  通过所测模块的数据流进行测试。调用所测模块时参数与模块的形式参数的个数、属性和顺序是否匹配。</p>
<p><strong> 局部数据结构测试 </strong><br>　　局部数据结构是为了保证临沭存储在模块内的数据在程序执行过程中完整、正确、模块的局部数据结构往往是错误的根源。</p>
<p><strong> 路径测试 </strong><br>　　对模块中重要的执行路径进行测试。</p>
<p><strong> 错误处理测试 </strong><br>　　比较完善的模块设计要求能遇见出错的条件，并设置是党的出错处理，以便在程序出错时，能够对出错程序重做安排，保证其逻辑上的正确性。</p>
<p><strong> 边界条件测试 </strong><br> 　　软件经常在边界上失效，边界条件测试是一项基础测试，也是后面系统测试中的功能测试的重点。</p>
<h2 id="集成测试阶段："><a href="#集成测试阶段：" class="headerlink" title="集成测试阶段："></a>集成测试阶段：</h2><p>在集成测试中，我们主要关注以下内容：</p>
<ol>
<li>把各个模块连接起来时，穿越模块接口的数据是否会丢失。</li>
<li>各个子模块组合起来，能否达到预期要求的功能。</li>
<li>一个模块的功能是否会对另外一个模块的功能产生不利影响。</li>
<li>全局数据结构是否有问题。</li>
<li>单个模块的误差积累起来是否会被放大，从而达到不可接受的程度。</li>
</ol>
<h2 id="系统测试阶段："><a href="#系统测试阶段：" class="headerlink" title="系统测试阶段："></a>系统测试阶段：</h2><p>　　一般系统的主要测试工作都是集中在系统测试阶段。根据不同的系统所进行的测试种类也很多。</p>
<p><strong> 功能测试 </strong><br>　　功能测试是对产品的各项功能进行验证，一检查是否满足需求的要求。</p>
<p><strong> 性能测试 </strong><br>　　性能测试是通过自动化测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。</p>
<p><strong> 安全测试 </strong><br>   　　安全测试检查系统对非法入侵的防范能力。</p>
<p><strong> 兼容测试 </strong><br>　　兼容性测试主要是测试系统在不同的软硬件环境下是否能够正常的运行。</p>
<h2 id="验收测试阶段："><a href="#验收测试阶段：" class="headerlink" title="验收测试阶段："></a>验收测试阶段：</h2><p>功能确认测试<br>安全可靠性测试<br>易用性测试<br>可扩充性测试<br>兼容性测试<br>资源占有率测试<br>用户文档资料验收</p>
<hr>
<h2 id="白盒测试、黑盒测试、灰盒测试"><a href="#白盒测试、黑盒测试、灰盒测试" class="headerlink" title="白盒测试、黑盒测试、灰盒测试"></a>白盒测试、黑盒测试、灰盒测试</h2><hr>
<p>　　上面是根据项目流程按照测试的各个阶段对测试工具的划分。白盒测试与黑盒测试，主要是测试工作对软件代码的可见程度的划分。这也是测试软件邻居中最基本的两个概念。</p>
<p><strong> 黑盒测试 </strong><br>　　黑盒测试，指的是把被测的软件看做是一个黑盒子，我们不去关心盒子里面的结构式什么样子的，只关心软件的输入数据和输出结果。<br>　　它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当的接受输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。</p>
<p><strong> 白盒测试 </strong><br>　　白盒测试，只的是把盒子盖子打开，去研究里面的源代码和程序结果。<br>　　它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常运行，检验程序中的每条通路是否都能按照预定要求正确工作。</p>
<p><strong> 灰盒测试 </strong><br>　　灰盒测试街与黑盒测试和白盒测试之间。<br>　　可以这样理解，灰盒测试关注输出对于输入的正确性，同时也关注内部表现，但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、时间、判断来判断内部的运行状态，有时候输出是正确的，但内部其实已经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采用这样的一种灰盒的方法。</p>
<hr>
<h2 id="功能测试、性能测试"><a href="#功能测试、性能测试" class="headerlink" title="功能测试、性能测试"></a>功能测试、性能测试</h2><hr>
<p><strong> 功能测试 </strong><br>　　功能测试检查实际的功能是否符合用户的需求。测试的大部分工作也是围绕软件的功能进行，设计软件的目的也是满足客户对其功能的需求。如果偏离这个目的的任何测试工作都是没有意义的。<br>　　功能测试又可以分为很多种：逻辑功能测试、界面测试、易用性测试、安装测试、兼容性测试等。</p>
<p><strong> 性能测试 </strong><br>　　性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。<br>　　软件的性能包括很多方面，主要有时间性能和空间性能两种。<br>　　<strong>时间性能：</strong>主要是指软件的一个经营体的响应时间。比如一个登录所需要的时间，一个交易所需要的时间等。当然，抛开具体的测试环境，来分析一次事物的响应时间是没有任何意义的。需要搭建一个具体且独立的测试环境。<br>　　<strong>空间性能：</strong>主要是指软件运行时所小号的系统资源，比如硬件资源，CPU、内存，网络带宽消耗等。</p>
<hr>
<h2 id="手工测试与自动化测试"><a href="#手工测试与自动化测试" class="headerlink" title="手工测试与自动化测试"></a>手工测试与自动化测试</h2><hr>
<p><strong> 手工测试： </strong><br>　　手工测试就是由人去一个一个的去执行测试用例，通过鼠标键盘等输如一些参数，查看返回结果是否符合预期结果。<br>（其实，不太喜欢别人把一般的功能测试工作叫手工测试，就像一个雕塑家不喜欢别人叫他刻石头的一样。手工测试同样需要业务熟悉、基本测试方法的理解。看似简单的工作却能够发现别人不能发现的软件问题。在目前的测试领域，手工测试仍然是无法替代的一种测试方法）</p>
<p><strong> 自动化测试： </strong><br>　　自动化测试是把以人为驱动的测试行为转化为机器执行的一种过程。通常，在设计了测试用例并通过评审之后，由测试人员根据测试用例中描述的规程一步步执行测试，得到实际结果与期望结果的比较。在此过程中，为了节省人力、时间或硬件资源，提高测试效率，便引入了自动化测试的概念。 </p>
<p>　　自动化测试：又可分为功能自动化测试与性能自动化测试。</p>
<p>　　我们一般所说的自动化测试就是指功能自动化测试，通过相关的测试技术，通过编码的方式用一段程序来测试一个软件的功能，这样就可以重复执行程序来进行重复的测试。如果一个软件一小部分发生改变，我们只要修改一部分代码，就可以重复的对整个软件进行功能测试。这样就大大的提高了测试效率。</p>
<p>　　性能自动化测试，当然，除了早期阶段，现在的性能测试工作都是通过性能测试工具辅助完成的。能过工具可以模拟成千上万的用户向系统发送请求，用来验证系统的处理能力。</p>
<hr>
<h2 id="冒烟测试、回归测试、随机测试"><a href="#冒烟测试、回归测试、随机测试" class="headerlink" title="冒烟测试、回归测试、随机测试"></a>冒烟测试、回归测试、随机测试</h2><hr>
<p>这三种测试在软件功能测试过程中，既不算具体明确的测试阶段也不算是具体的测试方法。</p>
<p><strong> 冒烟测试：</strong></p>
<p>　　是指在对一个新版本进行系统大规模的测试之前，先验证一下软件的基本功能是否实现，是否具备可测性。</p>
<p>　　引入到软件测试中，就是指测试小组在正规测试一个新版本之前，先投入较少的人力和时间验证一个软件 的主要功能，如果主要功能都没有实现，则打回开发组重新开发。这样做的好处是可以节省大量的时间成本和人力成本。</p>
<p><strong> 回归测试： </strong></p>
<p>　　回归测试是指修改了旧代码后，重新时行测试以确认修改后没有引入新的错误或导致其他代码产生错误。</p>
<p>　　回归测试一般是在进行软件的第二轮测试开始的，验证第一轮中发现的问题是否得到修复。当然，回归也是一个循环的过程，如果回归的问题通不过，则需要开发人员修改后再次进行回归，直到通过为止。</p>
<p><strong> 随机测试： </strong></p>
<p>　　是指测试中的所有输入数据都是随机生成的，其目的是模拟用户的真实操作，并发现一些边缘性的错误。</p>
<p>　　随机测试可以发现一些隐蔽的错误，但是也有很多缺点，比如测试不系统，无法统计代码覆盖率和需求覆盖率，发现的问题难以重现。一般是放在测试的最后执行。其实随机测试更专业的升级版叫 探索性测试</p>
<hr>
<p><strong>探索性测试</strong></p>
<p>　　探索性测试可以说是一种测试思维技术。它没有很多实际的测试方法、技术和工具，但是却是所有测试人员都应该掌握的一种测试思维方式。探索性强调测试人员的主观能动性，抛弃繁杂的测试计划和测试用例设计过程，强调在碰到问题时及时改变测试策略。 </p>
<p>　　探索性测试应该是未来测试领域的一个方向。</p>
<p><strong>安全测试</strong></p>
<p>　　安全测试是在IT软件产品的生命周期中，特别是产品开发基本完成到发布阶段，对产品进行检验以验证产品符合安全需求定义和产品质量标准的过程。 </p>
<p>　　安全测试也在越来越受到企业的关注和重视，因为由于安全性问题造成的后果是不可估量的。尤其对于互联网产品最容易遭受各种安全攻击。</p>
<p><strong><a href="http://www.cnblogs.com/fnng/archive/2012/10/24/2737972.html" target="_blank" rel="external">转载自虫师的博客</a></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浅说软件需求分析]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/06/12/%E6%B5%85%E8%AF%B4%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90.html</url>
      <content type="html"><![CDATA[<h2 id="什么是需求分析"><a href="#什么是需求分析" class="headerlink" title="什么是需求分析"></a>什么是需求分析</h2><hr>
<p>　　通俗的讲，对用户的意图不断揭示和验叛的过程，要对经过系统可行性分析所确定的系统目标做更为详细的描述。</p>
<p>　　假如你是个建筑工程师，有个客户找你建一个鸡窝，这个时候要需要与客户沟通，来确定客户到底想要一个什么样子的鸡窝。我们应该注意三点：</p>
<p><strong>1 .  准确的理解和描述客户需要的功能。</strong><a id="more"></a></p>
<p>　　客户说，我的鸡窝要三层的，带电梯，饮水池，厕所，饮水池要自动判断水位供水，电梯要可以同时乘坐10只鸡….客户滔滔不绝的讲了一大堆，你也都非常忠实的按照自己的理解再一一的向客户描述一遍，以便于确认客户的需求是否正确。</p>
<p><strong>2 .  帮助客户挖掘需求。</strong></p>
<p>　　等客户把自己的需求说完了，你发现客户没有说鸡的卧室，于是，你向客户提议说：“你看，这鸡的卧室要什么样子的？”，客户连连的拍着脑门说，我差点给忘记了，鸡们啊喜欢晚上在一起聊天，所以呢，需要一个长而大的卧室，但一定要舒适。</p>
<p><strong>3 . 分析客户需求的可行性</strong></p>
<p>　　客户临走时又说，最近了，黄鼠狼很多，我这个鸡窝啊，一楼就不用盖了，直接盖二楼和三楼吧！以免晚上遭遇黄鼠狼的攻击。你这么一分析，客户这要求，按照目前的技术可没法建啊，于是，你向客户提议，一楼采用坚固架子来支撑二三楼的建筑。</p>
<hr>
<h2 id="需求分析困难在哪儿？"><a href="#需求分析困难在哪儿？" class="headerlink" title="需求分析困难在哪儿？"></a>需求分析困难在哪儿？</h2><hr>
<p>有几种原因使需求分析变得困难：（1）客户说不清楚需求；（2）需求自身经常变动；（3）分析人员或客户理解有误。</p>
<p><strong>1 . 客户说不清楚需求</strong></p>
<p> 　　有些客户对需求只有朦胧的感觉，当然说不清楚具体的需求。例如全国各地的很多政府机构在搞网络建设，这些单位的领导和办公人员大多不清楚计算机网络有什么用，反而要软件系统分析人员替他们设想需求。这类工程的需求是如此的主观，以致产生很多贪污腐败现象。<br>　　有些客户心里非常清楚想要什么，但却说不明白。你可能很不以为然。就举日常生活的事例吧，比如说买鞋子。我们非常了解自已的脚，但没法说清楚脚的大小和形状。只能拿鞋子去试，试穿时感觉到舒服才会买鞋（居然也有神通广大的售货员，看一眼客户的手，就知道应该穿什么样的鞋）。<br>　　如果客户本身就懂软件开发，能把需求说得清清楚楚，这样的需求分析将会非常轻松、愉快。如果客户全不懂软件，但信任软件开发方，这事也好办。分析人员可以引导客户，先阐述常规的需求，再由客户否定不需要的，最终确定客户真正的需求。最怕的就是“不懂装懂”或者“半懂充内行”的客户，他们会提出不切实际的需求。如果这些客户甚至觉得自己是上帝的爸爸，那么沟通和协商都会很困难。</p>
<p><strong>2 . 需求自身经常变动  </strong></p>
<p> 　　唐僧曾说：“妖要是有了仁慈之心，就不再是妖，是人妖。”（《大话西游之大圣娶亲》）<br>　　连妖都会变心，别说人了。所以喜新厌旧乃人之常情，世界也因此变得多姿多彩。<br>　　软件的需求会变化吗？<br>　　答：据历史记载，没有一个软件的需求改动少于三次。唯一只改动需求两次的客户是个死人。这个可怜的家伙还是在运送第三次需求的路上被车子撞死的。[Cline 1995]<br>让我们先接受“需求会变动”这个事实吧，免得在需求变动时惊慌失措。明白“需求会变动”这个道理后，在进行需求分析时就要留点神：<br>　　（1）尽可能地分析清楚哪些是稳定的需求，哪些是易变的需求。以便在进行系统设计时，将软件的核心建筑在稳定的需求上，否则将会吃尽苦头。</p>
<p>　　（2）在合同中一定要说清楚“做什么”和“不做什么”。如果合同含含糊糊，日后扯皮的事情就多。要防止象韩复渠那样，在别人请他喝酒吃饭时他什么都点头（人家就更加献殷勤），吃完了他就宣布刚才答应的事都不算数，便扬长而去。</p>
<p><strong>3 .  分析人员和顾客理解有误</strong></p>
<p>　　有个外星人间谍潜伏到地球刺探情报，它给上司写了一份报告：“主宰地球的是车。它们喝汽油，靠四个轮子滚动前进。嗓门极大，在夜里双眼能射出强光。……有趣的是，车里住着一种叫作‘人’的寄生虫，这些寄生虫完全控制了车。”<br>　　软件系统分析人员不可能都是全才。客户表达的需求，不同的分析人员可能有不同的理解。如果分析人员理解错了，可能会导致开发人员白干活，吃力不讨好。我读中学时候最怕写作文逃题，如果逃题了，不管作文写得多长，总是零分。所以分析人员写好需求说明书后，要请客户方的各个代表验证。如果问题很复杂，双方都不太明白，就有必要请开发人员快速构造软件的原型，双方再次论证需求说明书是否正确。<br>　　由于客户大多不懂软件，他们可能觉得软件是万能的，会提出一些无法实现的需求。有时客户还会把软件系统分析人员的建议或答复给想歪了。<br>　　有一个软件人员滔滔不绝地向客户讲解在“信息高速公路上做广告”的种种好处，客户听得津津有味。最后，心动的客户对软件人员说：“好得很，就让我们马上行动起来吧。请您决定广告牌的尺寸和放在哪条高速公路上，我立即派人去做。”</p>
<hr>
<h2 id="需求分析的分类"><a href="#需求分析的分类" class="headerlink" title="需求分析的分类"></a>需求分析的分类</h2><hr>
<p>需求分析一般可分为功能需求、非功能需求和领域需求</p>
<p><strong>1 . 功能需求：</strong></p>
<p>　　 功能需求主要说明了系统实际应做到什么。这是用户最直观也是最主要的需求，如系统的输入输出、系统能完成的功能以及其它相关处理等；</p>
<p><strong>2 . 非功能需求：</strong><br>　　非功能需求又称“约束”，它主要从各个角度对系统起约束和限制作用。如响应时间、存储效率、报表的规格和界面的样式等<br><strong>3 . 领域需求：</strong><br>　　领域需求的来源不是用户，而是系统应用的领域，其主要反映了该领域的基本问题。例如勤工俭学管理系统，其领域需求就涉及到诸如应聘合同书、酬金发放及劳工考核等相关内容，如果这些需求得不到满足，系统就无法正常运行。值得一提的是，领域需求可能是功能需求，也可能是非功能需求。</p>
<hr>
<h2 id="如何进行需求分析"><a href="#如何进行需求分析" class="headerlink" title="如何进行需求分析"></a>如何进行需求分析</h2><p>　　进行需求分析不象情人之间的浪漫做法——“让我摸摸你的头发，感觉它是什么颜色。”我们需要了解需求分析的渠道和过程。<br><img src="http://ww1.sinaimg.cn/large/666cc9e3gw1f4tzk5dph6j20cp08u3z2.jpg" alt=""><br>需求分析的过程<br><img src="http://ww1.sinaimg.cn/large/666cc9e3gw1f4tzkrwicxj20cj06yweu.jpg" alt=""><br><strong>（1）可行性研究</strong></p>
<p>　　它指明现有的软件、硬件技术能否实现用户对系统的要求，从业务角度来决定系统开发是否可行以及在预算范围内能否开发出来。可行性研究的结果是清楚的回答：该系统是否值得开发</p>
<p><strong>（2）需求导出和分析</strong></p>
<p>　　这是一个通过对现有系统分析、与潜在客户讨论、进行任务分析等导出系统需求的过程，也可能需要开发一个或多个不同的系统原型，以帮助分析员了解所要描述的系统。</p>
<p><strong>（3）需求描述</strong></p>
<p>　　需求描述就是把在分析活动中收集的信息通过分析整理之后以文档的形式确定下来。该文档中有两类需求：用户需求是从客户和最终用户角度对系统需求的抽象描述；系统需求是对系统要提供的功能的详尽描述。</p>
<p><strong>（4）需求有效性验证</strong></p>
<p>　　主要是通过评审、验证等一系列活动来找出需求文档中的错漏并加以改正。</p>
<p><strong>（5）需求管理</strong></p>
<p>　　需求管理需求管理是一种系统化方法，可用于获取、组织和记录系统需求并使用户和开发方在系统变更需求上始终保持一致</p>
<hr>
<h2 id="需求分析的方法"><a href="#需求分析的方法" class="headerlink" title="需求分析的方法"></a>需求分析的方法</h2><p><strong>1 .  功能分析方法</strong></p>
<p>　　那怕是天下最无能的市长或书记，都知道在作报告时要先从宏观上讲一、二、三、四、五，再从细节上讲 A、B、C、D、E；需求分析不象侦探推理那样从蛛丝马迹着手。应该先了解宏观的问题，再了解细节的问题。</p>
<p>　　功能分析法功能分解法以系统提供的功能为中心来组织系统。首先定义各种功能, 然后把功能分解为子功能, 同时定义功能之间的接口。数据结构是根据功能/子功能的需要设计的。 其基本策略是以分析员的经验为依据, 确定新系统所期望的处理步骤或子步骤, 然后, 将问题空间映射到功能和子功能上。</p>
<p><strong>2 . 数据流方法</strong></p>
<p>　　周末，小明一觉醒来突然想吃红烧肉，那想得口水直流，于起床，穿好衣服，打开钱包一看空的，好吧，先去银行取钱，然后去菜那买了一肉、各种配料，然后回家，开火，各种材料往锅里一放，开始小火慢炖，半个小时后，小明终于吃上了美味可口的红烧肉。这是一个典型的流程，如果把它看成一个系统功能的话，那么小明吃到红烧肉是这个功能的目的，那么中间要经历许多环节，起床穿衣—取钱—习材料—-制作完成。而且各个功能（步骤）之间是相互联系的，小明总不能不穿衣服直接去取钱吧。</p>
<p>　　数据流法也叫结构化分析, 其基本策略是研究问题域中数据如何流动以及在各个环节上进行何种处理, 从而发现数据流和加工。 问题域被映射为由数据流、加工以及文件、端点等成份构成的数据流图(DFD) , 并用数据字典对数据流和加工进行详细说明。这种方法的关键是动态跟踪数据流动。</p>
<p><strong>3 . 信息建模方法</strong></p>
<p>　　一个贵妇去报案，我丢了一个辆车，小明是警察，然后问贵妇，你丢的什么样的车子？贵妇噼里啪啦的给小明描述车子样子：我的车子有四个轮子，前面两个小，后面两个大，车身是流线型的，后面带尾翼，里面只一排坐位的那种，车坐上都用的真皮做套子，后面…..你听着听头大了，然后对贵妇说：等等，我给你画下来。于是，贵妇边说，你边画，然后贵妇指出画的不对的地方由你来修改。当然了这只是实体的样子。我们还需要知道汽车各个部件的功能以及各部件之间的关系。</p>
<p>　　信息建模法的核心概念是实体和关系, 主要工具是语义数据模型(实体关系图) , 其基本策略是找出现实世界的对象, 然后用属性来描述对象, 增添对象与对象之间的关系, 定义父类与子类, 用父类型/子类型提炼属性的共性, 用关联对象关系作细化的描述, 最后进行规范化处理。 其实质是将问题空间直接映射成模型中的对象。</p>
<p> —-下面三种方法，我还不能理解—–</p>
<p><strong>4 .   面向对象方法</strong></p>
<p>　　我想你如果学习过面向对象编程的话，会很容易理解。</p>
<p>　　面向对象分析 OOA(Object- Oriented Analysis) 的基本策略是通过信息隐藏将比较容易变化的元素隐藏起来, 分析员基于比较稳定的元素建立其思想和规格说明的总体结构。</p>
<p>　　面向对象分析的主要特性是加强了对问题域( Problem Domain) 和系统责任( System Responsibili-ties)的理解; 改进与分析有关的各类人员之间的交流; 对需求的变化具有较强的适应性; 支持软件复用</p>
<p><strong>5 . 面向本体方法</strong></p>
<p>　　面向本体的需求分析 OORA (Ontology- Oriented Require-ments Analysis) , 是 OOA方法的有效补充和提升。 面向本体方法强调相关领域的本质概念以及这些概念之间的关联。其实质是在面向对象方法中引入对象关联, 并给出各种关联的语义语用。</p>
<p>　　OORA方法由 4 个阶段来完成。第一阶段: 用一种自然语言BIDL( Bisiness Information Description Language) 描述事务; 第二阶段: 确认隐含在 BIDL文本中的本体和对象; 第三阶段: 将这些本体和对象转换成另一种语言 Ononet (Ontology and Object- Ori-ented Network) , 得到用 Ononet 书写的需求预定义; 第四阶段: 在采用 Ononet 作为知识表示形式的领域本体知识库中搜索相关的知识, 并和前面的需求预定义合并, 得到软件完整的需求定义。</p>
<p>6 . 形式化方法</p>
<p>　　形式化方法, 广义上讲, 是应用数学的手段来设计、 模拟和分析, 得到像数学公式那样精确的表示。从狭义上讲, 就是使用一种形式语言进行语言公式的形式推理, 用于检查语法的良构性并证明某些属性。在需求分析阶段, 利用形式化方法得到需求规格说明书, 可以规范软件开发过程, 为获得更好的系统性能提供重要保证。</p>
<p>=======粗俗的方法=======<br>可能你对上面的方法看不懂，起码后三种我是看不懂的，怪我知识太少的缘故。</p>
<p>我们来看下面了解需求的方式：</p>
<p>（1）直接与客户交谈。如果分析人员生有足球评论员的那张“大嘴”，就非常容易侃出需求。</p>
<p>（2）有些需求客户讲不清楚，分析人员又猜不透，这时就要请教行家。有些高手真的很厉害，你还没有开始问，他就能讲出前因后果。让你感到“听君一席言，胜读十年书。”</p>
<p>（3）有很多需求可能客户与分析人员想都没有想过，或者想得太幼稚。要经常分析优秀的和蹩脚的同类软件，看到了优点就尽量吸取，看到了缺点就引以为戒。前人既然付了学费，后人就不要拒绝坐享其成。</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><blockquote>
<p>《关于软件需求分析的研究》–邱树伟<br> 《软件工程思想》–林锐</p>
</blockquote>
<p><strong><a href="http://www.cnblogs.com/fnng/archive/2011/09/13/2174268.html" target="_blank" rel="external">转载自虫师的博客</a></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[pythonの生成正交测试数据]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/05/30/python%E3%81%AE%E7%94%9F%E6%88%90%E6%AD%A3%E4%BA%A4%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE.html</url>
      <content type="html"><![CDATA[<h2 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h2><hr>
<p> 输入为数组，如下所示：<br>a=[[1,2,3],[4,5],[6,7]]<br>a[0],a[1],a[2]···表示各个因素，此时表示a有四个因素<br>a[0]=[1,2,3]表示a[0]有三个值可以选</p>
<hr>
<p>输出为数组，如下所示：<a id="more"></a><br>b= [[1, 4, 6], [1, 5, 7], [2, 4, 7], [2, 5, 6]]<br>b[0],b[1]···表示正交法生成的测试数据</p>
<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><h3 id="output-oracle-py"><a href="#output-oracle-py" class="headerlink" title="output_oracle.py"></a>output_oracle.py</h3><blockquote>
<p>获取数组的因素数和水平数<br>调用Ort_model.py函数 返回相应的正交表<br>将输入数据替换正交表内数 生成正交测试数据</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Ort_model</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ORT_EXPRESSION</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Output_Ort</span><span class="params">(self,input_array)</span>:</span></span><br><span class="line">        self.in_array=input_array</span><br><span class="line">        i_Factors_temp=len(self.in_array)   <span class="comment">#因素数</span></span><br><span class="line">        i_array=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(i_Factors_temp)]</span><br><span class="line">        <span class="comment">#求取水平数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,i_Factors_temp):</span><br><span class="line">            i_array[i]=len(self.in_array[i])</span><br><span class="line">        i_array_temp=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> i_array:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> i_array_temp:</span><br><span class="line">                i_array_temp[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i_array_temp[i] += <span class="number">1</span> </span><br><span class="line">        i_levels_temp=max(i_array_temp.iteritems(), key = <span class="keyword">lambda</span> x: x[<span class="number">1</span>])[<span class="number">0</span>]  <span class="comment">#水平数       </span></span><br><span class="line">        <span class="comment">#正交模型</span></span><br><span class="line">        Model_Ort=Ort_model.ORT_MODEL()</span><br><span class="line">        return_ort=Model_Ort.Ort_mod(i_Factors_temp,i_levels_temp)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> return_ort:</span><br><span class="line">            msg=<span class="string">'input is wrong'</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>,msg,<span class="string">''</span>]</span><br><span class="line">        <span class="comment">#带入数值</span></span><br><span class="line">        i_L=len(return_ort)</span><br><span class="line">        i_Factors=len(return_ort[<span class="number">0</span>])</span><br><span class="line">        return_array = [[<span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> range(i_Factors)] <span class="keyword">for</span> row <span class="keyword">in</span> range(i_L)]  </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i_Factors):</span><br><span class="line">            l_n=[x[j] <span class="keyword">for</span> x <span class="keyword">in</span> return_ort]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(l_n)):</span><br><span class="line">                <span class="keyword">if</span> l_n[i]&lt;len(self.in_array[j]):               </span><br><span class="line">                    return_array[i][j]=self.in_array[j][l_n[i]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    return_array[i][j]=random.choice(self.in_array[j])  <span class="comment">#使用随机函数选择当前可选数据</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>,<span class="string">''</span>,return_array]</span><br></pre></td></tr></table></figure>
<h3 id="Ort-model-py"><a href="#Ort-model-py" class="headerlink" title="Ort_model.py"></a>Ort_model.py</h3><blockquote>
<p>根据因素数和水平数 得到相应的正交表</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ORT_MODEL</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.L4=[</span><br><span class="line">                [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">                [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">                ]  <span class="comment">#2 3 </span></span><br><span class="line">        self.L8=[</span><br><span class="line">                [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">                [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">                [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">                [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">                ] <span class="comment">#2 7</span></span><br><span class="line">        self.L9=[</span><br><span class="line">                [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                [<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">                [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">                [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>],</span><br><span class="line">                [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">                [<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">                [<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>],</span><br><span class="line">                [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">                ]<span class="comment">#3 4</span></span><br><span class="line">        self.L16=[</span><br><span class="line">                 [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                 [<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">                 [<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">                 [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">                 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">                 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">                 [<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">                 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>],</span><br><span class="line">                 [<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">                 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>],</span><br><span class="line">                 [<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">                 [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>],</span><br><span class="line">                 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>],</span><br><span class="line">                 [<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">                 ]<span class="comment">#4 5</span></span><br><span class="line">        self.L25=[</span><br><span class="line">                  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">                  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">                  [<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>],</span><br><span class="line">                  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>],</span><br><span class="line">                  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">                  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">                  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">                  [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                  [<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">                  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>],</span><br><span class="line">                  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],</span><br><span class="line">                  [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>],</span><br><span class="line">                  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>],</span><br><span class="line">                  [<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">                  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],</span><br><span class="line">                  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>],</span><br><span class="line">                  [<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>],</span><br><span class="line">                  [<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">                  [<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>],</span><br><span class="line">                  [<span class="number">5</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">                  [<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>],</span><br><span class="line">                  [<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>],</span><br><span class="line">                  [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>],</span><br><span class="line">                  [<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">                  ]<span class="comment">#5 6</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Ort_mod</span><span class="params">(self,i_factors,i_levels)</span>:</span></span><br><span class="line">        self.i_fac=i_factors</span><br><span class="line">        self.i_lev=i_levels</span><br><span class="line">        <span class="keyword">if</span> (self.i_fac==<span class="number">3</span> <span class="keyword">and</span> self.i_lev&lt;=<span class="number">2</span>):<span class="comment">#2 3 </span></span><br><span class="line">            <span class="keyword">return</span> self.L4</span><br><span class="line">        <span class="keyword">if</span> (self.i_fac==<span class="number">7</span> <span class="keyword">and</span> self.i_lev&lt;=<span class="number">2</span>):<span class="comment">#2 7</span></span><br><span class="line">            <span class="keyword">return</span> self.L8</span><br><span class="line">        <span class="keyword">if</span> (self.i_fac==<span class="number">4</span> <span class="keyword">and</span> self.i_lev&lt;=<span class="number">3</span>):<span class="comment">#3 4</span></span><br><span class="line">            <span class="keyword">return</span> self.L9</span><br><span class="line">        <span class="keyword">if</span> (self.i_fac==<span class="number">5</span> <span class="keyword">and</span> self.i_lev&lt;=<span class="number">4</span>):<span class="comment">#4 5</span></span><br><span class="line">            <span class="keyword">return</span> self.L16</span><br><span class="line">        <span class="keyword">if</span> (self.i_fac==<span class="number">6</span> <span class="keyword">and</span> self.i_lev&lt;=<span class="number">5</span>):<span class="comment">#5 6</span></span><br><span class="line">            <span class="keyword">return</span> self.L25</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[标准正交表]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/05/29/%E6%A0%87%E5%87%86%E6%AD%A3%E4%BA%A4%E8%A1%A8.html</url>
      <content type="html"><![CDATA[<h2 id="标准表"><a href="#标准表" class="headerlink" title="标准表"></a>标准表</h2><hr>
<table>
<thead>
<tr>
<th style="text-align:center">水平数</th>
<th style="text-align:center">1级</th>
<th style="text-align:center">2级</th>
<th style="text-align:center">3级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2水平</td>
<td style="text-align:center">L4(2^3)</td>
<td style="text-align:center">L8(2^7)</td>
<td style="text-align:center">L16(2^15)</td>
</tr>
<tr>
<td style="text-align:center">3水平</td>
<td style="text-align:center">L9(3^4)</td>
<td style="text-align:center">L27(3^13)</td>
<td style="text-align:center">L81(3^40)</td>
</tr>
<tr>
<td style="text-align:center">4水平</td>
<td style="text-align:center">L16(4^5)</td>
<td style="text-align:center">L64(4^21)</td>
<td style="text-align:center">L256(4^85)</td>
</tr>
<tr>
<td style="text-align:center">5水平</td>
<td style="text-align:center">L25(5^6)</td>
<td style="text-align:center">L125(5^31)</td>
<td style="text-align:center">L625(5^156)</td>
</tr>
</tbody>
</table>
<h2 id="标准正交表"><a href="#标准正交表" class="headerlink" title="标准正交表"></a>标准正交表</h2><a id="more"></a>
<hr>
<p><strong>L4(2^3):</strong><br>L4=[<br>                [0,0,0],<br>                [0,1,1],<br>                [1,0,1],<br>                [1,1,0]<br>                ]  #2 3 </p>
<p><strong>L8(2^7):</strong><br>L8=[<br>                [0,0,0,0,0,0,0],<br>                [0,0,0,1,1,1,1],<br>                [0,1,1,0,0,1,1],<br>                [0,1,1,1,1,0,0],<br>                [1,0,1,1,0,1,0],<br>                [1,0,1,1,0,1,0],<br>                [1,1,0,1,0,0,1],<br>                [1,1,0,1,0,0,1]<br>                ] #2 7</p>
<p><strong>L9(3^4): </strong><br>L9=[<br>                [0,0,0,0],<br>                [0,1,1,1],<br>                [0,2,2,2],<br>                [1,0,1,2],<br>                [1,1,2,0],<br>                [1,2,0,1],<br>                [2,0,2,1],<br>                [2,1,0,2],<br>                [2,2,1,0]<br>                ]#3 4</p>
<p><strong>L16(4^5): </strong><br>L16=[<br>                 [0,0,0,0,0],<br>                 [0,1,1,1,1],<br>                 [0,2,2,2,2],<br>                 [0,3,3,3,3],<br>                 [1,0,1,2,3],<br>                 [1,1,0,3,2],<br>                 [1,2,3,0,1],<br>                 [1,3,2,1,0],<br>                 [2,0,2,3,1],<br>                 [2,1,3,2,0],<br>                 [2,2,0,1,3],<br>                 [2,3,1,0,2],<br>                 [3,0,3,1,2],<br>                 [3,1,2,0,3],<br>                 [3,2,1,3,0],<br>                 [3,3,0,2,1]<br>                 ]#4 5</p>
<p><strong>L25(5^6): </strong><br>L25=[<br>                  [1,1,1,1,1,1],<br>                  [1,2,2,2,2,2],<br>                  [1,3,3,3,3,3],<br>                  [1,4,4,4,4,4],<br>                  [1,5,5,5,5,5],<br>                  [2,1,2,3,4,5],<br>                  [2,2,3,4,5,1],<br>                  [2,3,4,5,1,2],<br>                  [2,4,5,1,2,3],<br>                  [2,5,1,2,3,4],<br>                  [3,1,3,5,2,4],<br>                  [3,2,4,1,3,5],<br>                  [3,3,5,2,4,1],<br>                  [3,4,1,3,5,2],<br>                  [3,5,2,4,1,3],<br>                  [4,1,4,2,5,3],<br>                  [4,2,5,3,1,4],<br>                  [4,3,1,4,2,5],<br>                  [4,4,2,5,3,1],<br>                  [4,5,3,1,4,2],<br>                  [5,1,5,4,3,2],<br>                  [5,2,1,5,4,3],<br>                  [5,3,2,1,5,4],<br>                  [5,4,3,2,1,5],<br>                  [5,5,4,3,2,1]<br>                  ]#5 6</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[正交试验法原理]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/05/28/%E6%AD%A3%E4%BA%A4%E8%AF%95%E9%AA%8C%E6%B3%95%E5%8E%9F%E7%90%86.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>由于要整理测试用例 用到了正交法生成测试用例<br>特对正交实验法进行下整理</p>
</blockquote>
<p><strong> 正交实验法概念 </strong><br>来自百度百科的解释<a href="http://baike.baidu.com/link?url=_RWY0sTNRmIpVMElPKw9SzkmJ4j4PbW_vwErYeAsU0c0Oo2jdOSV1YE3nC8EPfWtdSfSh6OEqQLXYts8SAjUQq" target="_blank" rel="external">正交试验法</a><a id="more"></a></p>
<blockquote>
<p>正交实验法就是利用排列整齐的表 -、<strong>正交表</strong>来对试验进行整体设计、综合比较、统计分析，实现通过少数的实验次数找到较好的生产条件，以达到最高生产工艺效果，<strong>这种试验设计法是从大量的试验点中挑选适量的具有代表性的点，利用已经造好的表格—正交表来安排试验并进行数据分析的方法。</strong>正交表能够在因素变化范围内均衡抽样，使每次试验都具有较强的代表性，由于正交表具备均衡分散的特点，保证了全面实验的某些要求，这些试验往往能够较好或更好的达到实验的目的。</p>
</blockquote>
<p><strong> 关于正交表 </strong></p>
<blockquote>
<p>日本著名的统计学家田口玄一将正交试验选择的水平组合列成表格，称为正交表。例如作一个三因素三水平的实验，按全面实验要求，须进行33=27种组合的实验，且尚未考虑每一组合的重复数。若按L9(33) 正交表按排实验，只需作9次，按L18(37) 正交表进行18次实验，显然大大减少了工作量。因而正交实验设计在很多领域的研究中已经得到广泛应用。</p>
</blockquote>
<p><strong> 正交实验法特点 </strong></p>
<blockquote>
<p>均匀分散，齐整可比</p>
</blockquote>
<p><strong>正交表的三个特性</strong><br>一、 正交性</p>
<ol>
<li>任一列中，不同数字出现次数相等</li>
<li>任两列中，同一横行所组成的数字对出现的次数相等<br>二、 可比性</li>
<li>任一列的个水平都出现，使得部分试验中包含所有因素的所有水平</li>
<li>任一2列建的所有组合全部出现，使任一两因素间都是全面实验<br>三、 综合可比性</li>
<li>任一列各水平出现的次数都相等</li>
<li>任两列间所有可能的组合出现的次数都相等<blockquote>
<p>正交性即均衡性是核心，是基础，代表性和综合可比性是正交性的必然结果，从而使正交表得以具体应用</p>
</blockquote>
</li>
</ol>
<p><strong> 正交实验过程 </strong></p>
<blockquote>
<p>正交实验设计包括两部分内容：第一，是怎样安排实验；第二，是怎样分析实验结果。</p>
</blockquote>
<p><strong>利用正交实验设计测试用例的步骤</strong></p>
<ol>
<li>明确实验目的，确定考核指标</li>
<li>挑因素，选水平</li>
<li>选择格式的正交表</li>
<li>进行表头设计</li>
<li>确定实验方案</li>
</ol>
<p><strong>正交表的构成</strong><br>行数(Runs)：正交表中的行的个数，即试验的次数，也是我们通过正交实验法设计的测试用例的个数。<br>因素数(Factors) ：正交表中列的个数，即我们要测试的功能点。<br>水平数(Levels)：任何单个因素能够取得的值的最大个数。正交表中的包含的值为从0到数“水平数-1”或从1到“水平数” 。即要测试功能点的输入条件。<br>正交表的形式：<br>L行数(水平数^因素数)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[pythonの将数组写入oracle内]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/05/19/python%E3%81%AE%E5%B0%86%E6%95%B0%E7%BB%84%E5%86%99%E5%85%A5oracle%E5%86%85.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>将给定的数组写入oracle内，保存到指定新表内<br>首先需要安装插件cx_oracle<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cx_Oracle</span><br><span class="line"><span class="comment">#程序目的：将二维数组内的数值写入oracle数据库相应的表内</span></span><br><span class="line"><span class="comment">#return [状态位，错误信息]</span></span><br><span class="line"><span class="comment">#0表示输出成功，错误信息为空</span></span><br><span class="line"><span class="comment">#1表示输出失败，返回相应错误信息</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>通过OUTPUT_ORACLE类实现功能 </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#----连接数据库-----</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OUTPUT_ORACLE</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#读取Oracle配置文件</span></span><br><span class="line">        Config_file=open(<span class="string">"Config.txt"</span>)</span><br><span class="line">        self.Oracle_Config=Config_file.readline()</span><br><span class="line">        Config_file.close()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">RW_Oracle</span><span class="params">(self,table_name,write_array)</span>:</span></span><br><span class="line">        self.tab_name=<span class="string">"create table "</span>+table_name  <span class="comment">#创建新表</span></span><br><span class="line">        self.w_array=write_array</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            conn=cx_Oracle.connect(self.Oracle_Config)</span><br><span class="line">            cursor=conn.cursor()</span><br><span class="line">        <span class="keyword">except</span> cx_Oracle.DatabaseError,msg:</span><br><span class="line">            cursor.close ()</span><br><span class="line">            conn.close ()</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>,msg]</span><br><span class="line"><span class="comment">#         try:</span></span><br><span class="line"><span class="comment">#             cursor.execute('drop table table_cc') #先删除表</span></span><br><span class="line"><span class="comment">#         except cx_Oracle.DatabaseError,msg:</span></span><br><span class="line"><span class="comment">#             cursor.close ()</span></span><br><span class="line"><span class="comment">#             conn.close ()</span></span><br><span class="line"><span class="comment">#             return [1,msg]</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cursor.execute(self.tab_name)  <span class="comment">#新建表格</span></span><br><span class="line">        <span class="keyword">except</span> cx_Oracle.DatabaseError,msg:</span><br><span class="line">            cursor.close ()</span><br><span class="line">            conn.close ()</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>,msg]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.w_array:</span><br><span class="line">            cursor.close ()</span><br><span class="line">            conn.close ()</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>,<span class="string">''</span>]</span><br><span class="line">        <span class="comment">#获取表名</span></span><br><span class="line">        Table_Name=table_name.split(<span class="string">'('</span>) <span class="comment">#用括号将表名分隔开</span></span><br><span class="line">        Insert_sql_temp=<span class="string">'insert into '</span>+Table_Name[<span class="number">0</span>]+<span class="string">' values('</span></span><br><span class="line">        <span class="comment">#创建插入SQL语句</span></span><br><span class="line">        x_len=len(self.w_array)     <span class="comment">#行数</span></span><br><span class="line">        y_len=len(self.w_array[<span class="number">0</span>])  <span class="comment">#列数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,x_len):</span><br><span class="line">            array_temp=<span class="string">''</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,y_len):</span><br><span class="line">                <span class="keyword">if</span> j==y_len<span class="number">-1</span>:</span><br><span class="line">                    array_temp=array_temp+str(self.w_array[i][j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    array_temp=array_temp+str(self.w_array[i][j])+<span class="string">','</span></span><br><span class="line">            Insert_sql=Insert_sql_temp+array_temp+<span class="string">')'</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                cursor.execute(Insert_sql)</span><br><span class="line">            <span class="keyword">except</span> cx_Oracle.DatabaseError,msg:</span><br><span class="line">                cursor.close ()</span><br><span class="line">                conn.close ()</span><br><span class="line">                <span class="keyword">return</span> [<span class="number">1</span>,msg]</span><br><span class="line">        <span class="comment">#提交数据</span></span><br><span class="line">        conn.commit(); </span><br><span class="line">        <span class="comment">#关闭数据库连接</span></span><br><span class="line">        cursor.close ()</span><br><span class="line">        conn.close ()</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>,<span class="string">''</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong> 存在的问题 </strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">写入效率不高，有待进一步优化</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[pythonの将数组写入excel内]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/05/18/python%E3%81%AE%E5%B0%86%E6%95%B0%E7%BB%84%E5%86%99%E5%85%A5excel%E5%86%85.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>将给定的数组写入excel内，保存到指定路径下<br>首先需要安装两个插件 xlrd xlwt<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*- </span></span><br><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#程序目的：将二维数组内的数值写入excel内，并保存到相应的路径</span></span><br><span class="line"><span class="comment">#return [状态位，错误信息]</span></span><br><span class="line"><span class="comment">#0表示输出成功，错误信息为空</span></span><br><span class="line"><span class="comment">#1表示输出失败，返回相应错误信息</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong> 通过OUTPUT_EXCEL类实现该功能 </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OUTPUT_EXCEL</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.file=xlwt.Workbook()</span><br><span class="line">        self.table=self.file.add_sheet(<span class="string">'sheet 1'</span>) <span class="comment">#默认存到Sheet 1内</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">RW_Excel</span><span class="params">(self,excel_name,save_path,write_array)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> write_array: <span class="comment">#判断数组是否为空</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.file.save(excel_name)</span><br><span class="line">            <span class="keyword">except</span> IOError,msg:</span><br><span class="line">                <span class="keyword">return</span> [<span class="number">1</span>,msg]</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        x_len=len(write_array)</span><br><span class="line">        y_len=len(write_array[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">0</span>,x_len):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,y_len):</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    self.table.write(i,j,write_array[i][j])</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="keyword">print</span> i ,j</span><br><span class="line">                    <span class="keyword">return</span> [<span class="number">1</span>,<span class="string">'Data error'</span>]</span><br><span class="line">        file_name_path=save_path+excel_name</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.file.save(file_name_path)</span><br><span class="line">        <span class="keyword">except</span> IOError,msg:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>,msg]</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>,<span class="string">''</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong> 存在的问题 </strong><br><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">由于使用xlwt xlrd插件，写入excel的行不能超过</span><span class="number">2</span><span class="xml"></span><span class="keyword">^16</span><span class="xml">，也就是最多只能写入</span><span class="number">65536</span><span class="xml">行</span></span><br></pre></td></tr></table></figure></p>
<p><strong> 未验证的可行的解决方法 </strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用openpyxl插件代替xlwt和xlrd插件</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[连载：面向对象葵花宝典：思想、技巧与实践(36-40章)]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/05/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B85.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>无意间发现这篇文章，文章讲解由浅入深，读完后感触很深<br>特全文转到自己的博客，方便以后自己随时查看<br>文章转载自爱技术的华仔的博客[<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">http://blog.csdn.net/yunhua_lee</a>]<br>非常感谢<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">爱技术的华仔</a></p>
</blockquote>
<h1 id="第三十六章"><a href="#第三十六章" class="headerlink" title="第三十六章"></a>第三十六章</h1><p>经过前面深入的阐述，SOLID的原则我们已经基本上讲清楚了，但如果想熟练的应用SOLID原则，仅仅知道SOLID是什么（what）还不够，我们还需要知道SOLID原则在什么时候和什么场景应用（when或where）。<a id="more"></a></p>
<p>幸运的是，SOLID原则的5个独立原则在实际应用中基本上都是独挡一面，并不会在某个地方需要同时从可选的几个原则中挑选一个最优的原则来应用，这样大大降低了我们应用SOLID原则的难度。</p>
<p>SOLID原则具体的应用场景如下：</p>
<p>SRP原则：用于类的设计</p>
<p>当我们想出一个类，或者设计出一个类的原型后，使用SRP原则核对一下类的设计是否符合SRP要求。</p>
<p>OCP原则：总的指导思想</p>
<p>OCP原则是一个总的指导思想，在面向对象的设计中，如果能够符合LSP/ISP/DIP原则，一般情况下就能够符合OCP原则了。<br>除了在面向对象的软件设计中外，OCP也可以用于指导系统<a href="http://lib.csdn.net/base/16" target="_blank" rel="external">架构</a>设计，例如常见的CORBA、COM协议，其实都可以认为是OCP原则的具体应用和实现。</p>
<p>LSP原则：用于指导类继承的设计</p>
<p>当我们设计类之间的继承关系时，使用LSP原则来判断这种继承关系是否符合LSP要求。</p>
<p>ISP原则：用于指导接口的设计</p>
<p>ISP原则可以认为是SRP原则的一个变种，本质上和SRP的思想是一样。SRP用于指导类的设计，而ISP用于指导接口的设计。</p>
<p>DIP原则：用于指导类依赖的设计</p>
<p>当我们设计类之间的依赖关系时，可以使用DIP原则来判断这种依赖是否符合DIP原则。<br>DIP原则和LSP原则相辅相成：DIP原则用于指导抽象出接口或者抽象类，而LSP原则指导从接口或者抽象类派生出新的子类。</p>
<h1 id="第三十七章"><a href="#第三十七章" class="headerlink" title="第三十七章"></a>第三十七章</h1><p>设计模式”这个词几乎成为了软件设计的代名词，很多人非常天真的以为掌握了设计模式就掌握了软件设计，但实际上如果只是握了设计模式，软件设计的门都还没摸到！</p>
<p>========================================================</p>
<p>谈起设计模式，那是几乎无人不知，无人不晓，大名鼎鼎的“GOF”（中文有的翻译为“四人帮”）惊世之作，真是“平生不识GOF，学尽设计也枉然！”</p>
<p>然而，设计模式真的是软件设计的“瑞士军刀”，切、削、锯、钻样样精通么？</p>
<p>读过设计模式的朋友估计不少，但真正注意过《设计模式》的副标题的估计很少，而这个副标题却是避免误解设计模式的关键。《设计模式》的副标题是：可复用面向对象软件的基础！</p>
<p> 不要小看了这短短的一句话，如果你没有看这句话，或者只是一扫而过并没有仔细体会，那么你很可能就认为设计模式是一把“瑞士军刀”，能够解决所有的设计问题，而实际上“<strong>设计模式只是一把锤子</strong>”，有个谚语叫做“如果你手里有一把锤子，那么所有的问题都变成了钉子”，如果你拿着设计模式这把锤子倒出去敲，要么东西被敲坏，要么就不起作用。</p>
<p>为什么说设计模式只是一把锤子呢？我们还是从副标题来看。《设计模式》的副标题揭示了《设计模式》的两个主要约束：</p>
<p>1）设计模式解决的是“可复用”的设计问题；<br>2）设计模式应用的领域是“面向对象”；</p>
<p>相信经过我这么一提醒，大家基本上都能够明白了为什么“设计模式只是一把锤子”了：</p>
<p>1）设计模式只能解决“可复用”的设计问题，其它的例如性能设计、可靠性设计、安全性设计、可服务性设计等都不是设计模式能够解决的；</p>
<p>2）设计模式只是在面向对象的语言中应用，如果是非面向对象的语言，就不怎么好用了。当然，你可以在C语言中用上设计模式，但毕竟要折腾不少，用起来也不那么得心用手。</p>
<p>所以，当你遇到一个问题就想到设计模式的时候，一定要注意“设计模式只是一把锤子”，不要拿着这把锤子到处去敲！</p>
<h1 id="第三十八章"><a href="#第三十八章" class="headerlink" title="第三十八章"></a>第三十八章</h1><p>很多人能够熟练背诵出所有的设计模式，能够快速画出各种设计模式的UML类图，也能够熟练的写出《设计模式》一书中各个模式的样例代码。但一到实际的项目设计和开发的时候，往往都会陷入迷茫：要么无从下手，不知道哪个地方要用设计模式；要么生搬硬套，胡乱使用设计模式，将方案和代码搞得一团乱麻。</p>
<p>===========================================================================</p>
<p>【知易行难 —— 设计模式应用的问题】<br>形而下者谓之器，形而上者谓之道。<br>                                               —《易经·系辞》</p>
<p>正如很多流行的技术（面向对象、UML等）一样，几乎大部分人都会宣称自己“掌握、熟练掌握”，甚至“精通”，然而，真正掌握的或者精通的，实在是少之又少。</p>
<p>一种典型的现象是：很多人能够熟练背诵出所有的设计模式，能够快速画出各种设计模式的UML类图，也能够熟练的写出《设计模式》一书中各个模式的样例代码。但一到实际的项目设计和开发的时候，往往都会陷入迷茫：要么无从下手，不知道哪个地方要用设计模式；要么生搬硬套，胡乱使用设计模式，将方案和代码搞得一团乱麻。</p>
<p>这是什么原因呢，难道是设计模式不好用，或者设计模式根本就是一个噱头？<br>答案不在于设计模式本身是否有用，而是在于我们没有掌握正确的学习和应用设计模式的方法。</p>
<p>学习《设计模式》一书中的23个设计模式，只是掌握了《设计模式》的“器”，但并没有掌握设计模式的“道”。就像一个工匠，锯、钻、锤、刨样样精通，但如果不知道什么地方该用锯，什么地方该用钻，肯定是一个不合格的工匠。为了能够更好的学习和应用设计模式，我们也需要掌握设计模式的“道”。</p>
<p>设计模式的“道”就是用来指导我们什么时候用设计模式，为什么要用设计模式，23个设计模式只是告诉了我们how，而设计模式之道却可以告诉我们why和where！</p>
<p>【拨云见日 —— 寻找设计模式之道】<br>熟悉《设计模式》一书内容的同学可能会想到：《设计模式》一书中，不是每个模式都有“适用性”的说明么？这个其实就是回答了where和why的问题啊！</p>
<p>例如：Facade模式的“适用性”说明如下（摘自《设计模式》中文版一书）：<br> <img src="http://ww1.sinaimg.cn/large/666cc9e3gw1f497id22urj20pd0agahg.jpg" alt=""><br>上面这一段文字，看起来回答了where和why的问题，但实际上我个人感觉作用并不大。</p>
<p>首先，这段描述太长了：以上这段文字是否花了你几分钟的时间去阅读和理解？</p>
<p>其次，这段描述比较抽象：什么事复杂，什么叫做简单，什么叫做很大依赖性。。。。。。可能每个人理解都不一样。</p>
<p>再者，23个模式，所有的“适应性”条款加起来估计有几十条条，你能够背住么？即使你能够全部背住，你能够全部理解么？即使你能够全部理解，当面对一个具体问题的时候，你知道几十条里面哪一条适应你的情况么？</p>
<p>所以，《设计模式》一书关于“适用性”的描述，实际上还是太复杂，太多了，不具备很强的实践知道意义和可操作性。</p>
<p>我们需要的是一个更简单的指导思想，大道至简，最好是一两句话就能够描述！<br>幸运的是，答案竟然就在《设计模式》一书中，但这个答案并不是那么明显！</p>
<p>《设计模式》一书的内容侧重点是23个模式的详细阐述，大部分人可能都是直奔主题，逐一去研究每个模式，而对于开头部分第1章和第2章的内容并没有详细研读和思考，或者对于这两章只是简单的浏览，并未认真领会和思考，由此错过了最重要的内容。再加上GoF在这2章的内容中，既要引入一个全新的概念，又要提纲挈领的介绍各个模式，还要引入实例进行分析，以至于大量的内容将真正核心的内容反而给淹没或者冲淡了。</p>
<p>设计模式之道就隐藏在“2.6.2 封装实现依赖关系”的最后一段，很简单的一句话：<br><strong>对变化的概念进行封装（encapsulate the concept that varies）</strong></p>
<p>你看到这句话可能有点失望，前面分析了那么久，卖了那么多的关子，结果就这么简简单单一句话，这不是在忽悠么？<br>你可千万别小看了这句话，“大道至简”，设计模式之道也不例外，但“简”并不意味着没用，相反，正因为其“简”，每个人的理解才一致，也更好掌握，实践中才更好应用。正所谓：“真传一句话，假传万卷书”。</p>
<p>GoF在《设计模式》一书中最早提出这个原则，后来不断的有其他专家进行阐述，其中《设计模式精解》（《Design pattern explained》）一书的阐述我认为是最精辟的：<strong>Find what varies and encapsulate it，翻译一下即“找到变化，封装变化”</strong>。虽然含义和GoF描述的基本一致，但其更加容易理解。</p>
<p>正所谓：踏破铁鞋无觅处，得来全不费工夫！</p>
<p>【庖丁解牛 —— 解析设计模式之道】<br>现在，让我们来深入理解“找到变化，然后封装变化”的设计模式之道。<br>首先，“找到变化”解决了“在哪里”使用设计模式的问题，即回答了“where”的问题。</p>
<p>“找到变化”看起来是比较抽象的一句话，但在实践中非常好应用和操作，而且不同领域、不同行业的系统都可以完美的应用这句话。虽然不同领域、不同行业变化的因素、方式、时机等都不一样，但每个领域或者行业的需求分析人员、设计人员，对自己所处行业和领域的可能变化肯定是有比较深刻的理解的，什么会变化、会如何变化、什么时候会变化。。。。。。等等，肯定都能够自己判断，这种判断并不需要什么高深的技巧和知识水平，只需要一定的经验积累。</p>
<p>如果我们刚接触一个行业或者领域，经验积累并不够，那怎么办呢？是否就无法“找到变化”了？<br>其实也不然，有一个万能的办法，只是要花费更多的精力了。</p>
<p>我的这个万能办法就是“唯一不变的是变化本身”，也就是说，如果你不知道什么会变化，那么就抱着怀疑一切的想法，一切都可能是变化的。</p>
<p>但光有这条指导原则还不行，如果我们真的抱着“一切都是可能变化的”想法，然后封装一切变化，那么就会陷入变化的漩涡无法自拔，因为变化是会递归的，A可能变成B，B也可能继续变化，于是这样无穷无尽，系统是不可能做出来的。</p>
<p>所以我们需要一个终止条件，避免陷入无穷无尽的变化递归漩涡。这个终止条件就是“有限时间内可能发生的变化”。这里的“有限时间”随行业和领域的不同而变化。例如（以下时间仅供参考）：<br>互联网行业可以说：半年内可能发生的变化。。。。。。<br>电信行业可以说：1年内可能发生的变化。。。。。。<br>金融行业可以说：2年内可能发生的变化。。。。。。<br>政府行业可以说：3年内可能发生的变化。。。。。。</p>
<p>有了这个指导原则后，你可以这样去问有经验的前辈、大虾、大牛等： XXX在1年内会发生变化么？会怎样变化？</p>
<p>就这样，即使你是菜鸟，通过这么一招“借花献佛”，也能够轻松发现“变化”的地方。</p>
<p>其次，“封装变化”解决了“为什么”使用设计模式的问题，即回答了“why”的问题。<br>为什么我们要用设计模式，是因为我们要封装变化！但我们为什么要封装变化呢？<br>答案很明显：变化不好！</p>
<p>当然这个“不好”不是从业务的角度来说的，而是从系统的角度来说的。从业务的角度来说，“变化”是好的，变化意味着新的机会；但从系统的角度来说，变化并不好，因为变化必然要求系统改动，改动就意味着风险！</p>
<p>虽然变化给系统带来风险，但我们不能因此而“拒绝变化”，因为拒绝变化就意味着失去了机会，简单来说，赚不到钱的系统，设计再优美，功能再强大，系统再稳定，也不过是一堆无用的摆设：<br>客户给你提了新需求，你不做，能拿到合同么。。。。。。<br>行业正在兴起新的流行功能，你不做，你的系统有人用么。。。。。。<br>一项创新带来了新的机遇，你不做，能抢占市场么。。。。。。</p>
<p>所以我们要“拥抱变化”，但我们又不能让变化带来太大的风险，所以就提出了“封装变化”。“封装变化”意味着将变化的影响范围控制最小，将风险降到最低。</p>
<p>我们来看看，变化会带来哪些问题和风险：<br>1）开发人员需要编码以适应变化，设计不好的方案将导致大量的编码工作量、自测工作量；<br>2）测试人员不单要测试因变化而新增的那部分，还要测试受影响的部分，设计不好的方案，牵一发而动全身，导致测试工作量大大增加；<br>3）如果为了适应某个变化而对系统做了比较大的改动，则系统的质量风险将上升，很可能导致上线失败，或者上线后出现各种问题；</p>
<p>因此，我们要尽量减少变化带来的工作量和风险，而减少的最有效方法就是将变化的影响范围缩小，即：将变化封装起来，使其只在有限的范围内有影响。</p>
<p>【举一反三 —— 活学活用设计模式之道】<br>就像一个武林高手有了深厚的内功，天下万物皆可成为手中的利器，而不必拘泥于具体的武器和招数一样，掌握了设计模式之道后，我们其实也完全可以不拘泥于只是用《设计模式》一书中的23个设计模式，可以根据需要选择最合适的方案。</p>
<p>例如：<br>不同的业务有不同的规则排列组合，规则引擎可以封装各种变化的规则。。。。。。<br>类之间的依赖是变化的，<a href="http://lib.csdn.net/base/17" target="_blank" rel="external">spring</a>使用XML配置文件来封装这种变化。。。。。。<br>每个银行的卡都不一样，银联封装了这种变化，使得不同银行可以互通。。。。。。</p>
<p>总之，你可以使用类和设计模式来封装变化，你也可以使用配置文件和模块来封装变化，你也可以使用一个系统来封装变化。。。。。。</p>
<h1 id="第三十九章"><a href="#第三十九章" class="headerlink" title="第三十九章"></a>第三十九章</h1><p>又是设计原则，又是设计模式，到底该用哪个呢？ =============================================================================</p>
<p>在“设计模型”一章中，我们提到设计原则和设计模式是互补的，设计原则和设计模式互补体现在：设计原则主要用于指导“类的定义”的设计，而设计模式主要用于指导“类的行为”的设计。</p>
<p>举一个很简单的例子：假设我们要设计一个图形类Shape，这个类既支持三角形，又支持矩形，其代码如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.designpattern.diagram;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 设计不好的Shape类，同时兼顾三角形和矩形的职责，不符合SRP设计原则 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BadShape</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//三角形的属性  </span></span><br><span class="line">    Position a;  </span><br><span class="line">    Position b;  </span><br><span class="line">    Position c;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//矩形的属性  </span></span><br><span class="line">    Position m;  </span><br><span class="line">    <span class="keyword">int</span> length;  </span><br><span class="line">    <span class="keyword">int</span> width;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTriangle</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 画出三角形  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 画出矩形  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有经验的朋友都会觉得这个设计不太合理，因为其不符合类的SRP设计原则。因此，合理的做法是将这个类按照SRP原则拆分，具体拆分方法如下：<br>NormalShape.java</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.designpattern.diagram;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 将BadShape拆开为三角形和矩形两个图形，并提取出NormalShape这个父类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">NormalShape</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span>(<span class="params"></span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NormalTriangle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.oo.designpattern.diagram;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 三角形类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalTriangle</span> <span class="keyword">extends</span> <span class="title">NormalShape</span> </span>&#123;  </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//三角形的属性  </span></span><br><span class="line">    Position a;  </span><br><span class="line">    Position b;  </span><br><span class="line">    Position c;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO：绘画三角形  </span></span><br><span class="line">        <span class="keyword">if</span>(Config.CURRENT_SYSTEM == Config.WINDOWS)&#123;  </span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> 调用Windows的画图方法  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( Config.CURRENT_SYSTEM == Config.LINUX)&#123;  </span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> 调用Linux的画图方法  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( Config.CURRENT_SYSTEM == Config.MAC)&#123;  </span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> 调用Mac的画图方法  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>NormalRectangle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.oo.designpattern.diagram;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 矩形类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalRectangle</span> <span class="keyword">extends</span> <span class="title">NormalShape</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//矩形的属性  </span></span><br><span class="line">    Position m;  </span><br><span class="line">    <span class="keyword">int</span> length;  </span><br><span class="line">    <span class="keyword">int</span> width;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 绘画矩形  </span></span><br><span class="line">        <span class="keyword">if</span>(Config.CURRENT_SYSTEM == Config.WINDOWS)&#123;  </span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> 调用Windows的画图方法  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( Config.CURRENT_SYSTEM == Config.LINUX)&#123;  </span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> 调用Linux的画图方法  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( Config.CURRENT_SYSTEM == Config.MAC)&#123;  </span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> 调用Mac的画图方法  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样拆分之后，从类的设计原则来看，已经是符合要求了。</p>
<p>接下来我们再使用设计模式来继续完善这个设计，这里就需要使用设计模式之道来指导我们设计了，即：<strong>找到变化，封装变化</strong>。</p>
<p>关于图形类一个比较明显的变化是跨平台，比如说要同时支持Windows、Linux、Mac三个桌面操作系统，那么实际画图的方法和需要调用的函数可能就随着平台的不同而变化，因此我们要找出一种方法来封装这种变化。</p>
<p>参考《设计模式》，可以知道这种方法就是“Bridge模式”，使用了Bridge后，会多出几个接口和实现类。<br>具体实现如下：<br>GoodShape.java<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.designpattern.diagram;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 在NormalShape的基础上，增加Bridge设计模式的实现，使其更加适应于跨平台 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GoodShape</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> ShapeDraw _draw;  <span class="comment">//将不同平台的实现封装到一个新的接口ShapeDraw  </span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span>(<span class="params"></span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>GoodTriangle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.oo.designpattern.diagram;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 按照Bridge设计模式设计的三角形类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodTriangle</span> <span class="keyword">extends</span> <span class="title">GoodShape</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    GoodTriangle(ShapeDraw draw)&#123;  </span><br><span class="line">        <span class="keyword">this</span>._draw = draw;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">        <span class="keyword">this</span>._draw.drawTriangle();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>GoodRectangle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.oo.designpattern.diagram;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 按照Bridge设计模式设计的矩形类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodRectangle</span> <span class="keyword">extends</span> <span class="title">GoodShape</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    GoodRectangle(ShapeDraw draw)&#123;  </span><br><span class="line">        <span class="keyword">this</span>._draw = draw;   </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">        <span class="keyword">this</span>._draw.drawRectangle();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ShapeDraw.java<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.designpattern.diagram;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 按照Bridge设计模式进行设计的画图的接口，封装了跨平台不同的实现 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">interface</span> <span class="title">ShapeDraw</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTriangle</span>(<span class="params"></span>)</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span>(<span class="params"></span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>WindowsDraw.java<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.designpattern</span><span class="selector-class">.diagram</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * Windwos上的画图实现 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">WindowsDraw</span> <span class="selector-tag">implements</span> <span class="selector-tag">ShapeDraw</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void drawTriangle() &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void drawRectangle() &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>LinuxDraw.java<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.designpattern</span><span class="selector-class">.diagram</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * Linux上的画图实现 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">LinuxDraw</span> <span class="selector-tag">implements</span> <span class="selector-tag">ShapeDraw</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void drawTriangle() &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void drawRectangle() &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MacDraw.java<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.designpattern</span><span class="selector-class">.diagram</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * Mac上的画图实现 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">MacDraw</span> <span class="selector-tag">implements</span> <span class="selector-tag">ShapeDraw</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void drawTriangle() &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void drawRectangle() &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，按照设计原则和设计模式进行重构后，原来不合理的设计逐步演变为一个优秀的设计了</p>
<h1 id="第四十章"><a href="#第四十章" class="headerlink" title="第四十章"></a>第四十章</h1><p>掌握了设计模式之道后，我们将以全新的方法来理解设计模式，这个方法更简单、更直观，不信？看几个样例就知道了</p>
<p>=====================================================================</p>
<p>DECORATOR 模式（以设计模式之道来理解）<br>【业务】<br>假设你进入了一个信息安全管理非常严格的公司，这家公司不允许员工自行打印文档，所有的文档打印都需要交给文档打印系统统一管理。文档打印系统会记录每次打印的时间、内容、打印人员。。。。。。等等，以便后续出现问题的时候进行追查。</p>
<p>由于公司有很多的部门，每个部门的安全要求并不完全一样，同时每个部门关于文档打印也有自己的一些规定。</p>
<p>我们的任务就是要开发一套能够支持整个公司文档打印需求的系统。</p>
<p>【发现变化】<br>文档打印系统面对的变化主要体现在：文档打印要求是变化的，不同的部门有不同的要求，同一个部门也可能修改自己的打印需求。</p>
<p>例如：<br>A 部门是一个战略规划的部门，里面的资料都非常重要，打印的时候需要在页眉位置打印 “绝密”，在页脚的位置打印 “密级申明”，同时要加上 “绝密文档” 的水印；<br>B 部门是内部培训部门，打印培训材料的时候需要在页眉位置打印 “内部公开”，但不需要密级申明，同时加上 “培训资料” 的水印<br>C 部门是对外宣传部门，打印宣传材料的时候只需要加上 “公司 logo” 的水印；</p>
<p>【传统方法】<br>传统方法使用类继承来封装打印请求，为每个部门创建一个打印的子类。详细示例代码如下：<br>PrintTask.Java – 文档打印系统开发小组负责维护</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 打印任务类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">abstract</span> public <span class="class"><span class="keyword">class</span> <span class="title">PrintTask</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">abstract</span> public void print(<span class="type">String</span> text);  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">SecretPrint</span>.java -- 文档打印系统开发小组负责维护:</span><br><span class="line">[java] view plain copy</span><br><span class="line"><span class="keyword">package</span> com.oo.designpattern.decorator;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 绝密文档的打印 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SecretPrint</span> <span class="keyword">extends</span> <span class="title">PrintTask</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    public void print(<span class="type">String</span> text) &#123;  </span><br><span class="line">        <span class="type">Printer</span>.printHeader(<span class="string">"绝密"</span>);  </span><br><span class="line">        <span class="type">Printer</span>.printText(text);  </span><br><span class="line">        <span class="type">Printer</span>.printFooter(<span class="string">"本文包含绝密信息，请勿泄露！"</span>);  </span><br><span class="line">        <span class="type">Printer</span>.printTextWaterMark(<span class="string">"绝密文档"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InternalPrint.java – 文档打印系统开发小组负责维护:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 内部公开的文档打印 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InternalPrint</span> <span class="keyword">extends</span> <span class="title">PrintTask</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    public void print(<span class="type">String</span> text) &#123;  </span><br><span class="line">        <span class="type">Printer</span>.printHeader(<span class="string">"内部公开"</span>);  </span><br><span class="line">        <span class="type">Printer</span>.printText(text);  </span><br><span class="line">        <span class="type">Printer</span>.printTextWaterMark(<span class="string">"培训资料"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PublicPrint.java – 文档打印系统开发小组负责维护:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.awt.<span class="type">Image</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 对外宣传的文档打印 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PublicPrint</span> <span class="keyword">extends</span> <span class="title">PrintTask</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">Image</span> _logo;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    public void print(<span class="type">String</span> text) &#123;  </span><br><span class="line">        <span class="type">Printer</span>.printText(text);  </span><br><span class="line">        <span class="type">Printer</span>.printImgWaterMark(_logo);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>文档打印系统实现如下：<br>PrintServer – 文档打印系统开发小组负责维护<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 文档打印系统 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> class PrintServer &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 执行打印任务 </span><br><span class="line">     * @param task </span><br><span class="line">     * @param text </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> executePrintTask(PrintTask task, <span class="keyword">String</span> <span class="built_in">text</span>)&#123;  </span><br><span class="line">        <span class="built_in">log</span>();  </span><br><span class="line">        task.<span class="built_in">print</span>(<span class="built_in">text</span>);  </span><br><span class="line">        audit();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 记录日志 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="built_in">log</span>()&#123;  </span><br><span class="line">        <span class="comment">// 省略具体实现代码  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 记录审计相关信息 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> audit()&#123;  </span><br><span class="line">        <span class="comment">// 省略具体实现代码  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义好不同的打印任务后，每个部门根据自己的需要，选择不同的任务发给文档打印系统。<br>例如，A 部门的打印处理如下：<br>SecretDepartment.java  – A 部门负责维护<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * A 部门的打印处理 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> SecretDepartment &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">print</span>(<span class="keyword">String</span> <span class="built_in">text</span>)&#123;  </span><br><span class="line">        PrintTask task = new SecretPrint();  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//PrintServer 即 “文档打印系统”  </span></span><br><span class="line">        PrintServer.executePrintTask(task, <span class="built_in">text</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>传统方法使用类继承来封装变化的打印需求，当面对变化时，存在如下问题：<br>1）新增部门的时候，需要文档打印系统提供一个新的打印任务类，将导致出现大量的 <strong><em>Print 类；<br>例如：新建了一个 D 部门，D 部门只需要打印纯文本即可，那么已有的 SecretPrint、InternalPrint、PublicPrint 类都无法满足需求，必须新增一个 PurePrint 的类；<br>2）某个部门的打印需求变更的时候，需要改变已有的 </em></strong>Print 类；<br>例如：C 部门希望在对外宣传材料的页眉上打印公司名称，则需要修改 PublicPrint 类。</p>
<p>【设计模式方法】<br>设计模式封装变化的方法就是 Decorator 模式。Decorator 模式定义如下：<br>“动态的给一个对象添加一些额外的职责”</p>
<p>《设计模式》一书中关于 Decorator 模式的描述并不很直观，我理解 Decorator 模式为 “通过聚合的方式将动态变化的职责组合起来”。</p>
<p>我们详细看看 Decorator 模式是如何封装变化的。<br>首先，将变化的职责封装为独立的类。传统方式实现中，不同的职责是对应不同的函数调用，而设计模式中，不同的职责是不同的类；<br>其次，通过聚合将变化的职责组合起来。传统方式中，不同职责的组合是通过在一个函数中写多行代码来体现的，而设计模式中，通过对象的聚合将不同职责组合起来。<br>【Decorator 模式结构】</p>
<p><img src="http://ww4.sinaimg.cn/large/666cc9e3gw1f497e2h1ovj20nw0eljth.jpg" alt=""></p>
<p>Component：定义一个对象接口（对应结构图中的 operation 函数），可以给这些对象动态添加职责<br>ConcreteComponent：定义一个对象，这个对象是实际的 Component，将被 Decorator 修饰<br>Decorator：定义修饰对象的接口，Decorator 实现的关键在于聚合了一个 Component 对象<br>ConcreteDecorator：具体的修饰对象</p>
<p>【代码实现】<br>使用 Decorator 设计模式实现的文档打印系统代码如下：<br><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong> 类设计 <strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></p>
<p>PrintComponent.java – 文档打印系统开发小组负责维护<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 打印组件的父类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PrintComponent</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span>(<span class="params"></span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PrintDecorator.java – 文档打印系统开发小组负责维护<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 修饰的打印任务，对应 Decorator 模式中的 Decorator </span><br><span class="line"> * Decorator 可以聚合 ConcreteComponent 或者其他 Decorator </span><br><span class="line"> * 这样可以使得打印任务能够嵌套执行下去，直到最后完成所有打印任务 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintDecorator</span> <span class="keyword">extends</span> <span class="title">PrintComponent</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">abstract</span> public void print();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TextComponent.java – 文档打印系统开发小组负责维护<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.oo.designpattern.decorator.<span class="type">Printer</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 文本打印，对应 Decorator 模式中的 ConcreteComponent </span><br><span class="line"> * 打印任务到 ConcreteComponent 就算真正完成了 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TextComponent</span> <span class="keyword">extends</span> <span class="title">PrintComponent</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> _text;  </span><br><span class="line">    <span class="type">TextComponent</span>(<span class="type">String</span> text)&#123;  </span><br><span class="line">        <span class="keyword">this</span>._text = text;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    public void print() &#123;  </span><br><span class="line">        <span class="type">Printer</span>.printText(<span class="keyword">this</span>._text);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HeaderDecorator.java – 文档打印系统开发小组负责维护<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.oo.designpattern.decorator.<span class="type">Printer</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 页眉打印 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HeaderDecorator</span> <span class="keyword">extends</span> <span class="title">PrintDecorator</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">PrintComponent</span> _comp; <span class="comment">// 被修饰的打印组件  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> _text;         <span class="comment">// 需要打印的页眉内容  </span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 初始化的时候，必须包含其它打印组件 comp，这是实现 Decorator 模式的前提 </span><br><span class="line">     * 同时也需要指定当前组件所需的参数，不能在 print 函数的参数中指定， </span><br><span class="line">     * 因为每个 Decorator 所需的参数是不一样的 </span><br><span class="line">     * @param comp </span><br><span class="line">     * @param text </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="type">HeaderDecorator</span>(<span class="type">PrintComponent</span> comp, <span class="type">String</span> text) &#123;  </span><br><span class="line">        <span class="keyword">this</span>._comp = comp;  </span><br><span class="line">        <span class="keyword">this</span>._text = text;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 打印 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    public void print() &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 打印的时候将当前 Decorator 和被修饰的 Component 分开，这是 Decorator 模式的关键  </span></span><br><span class="line">        <span class="type">Printer</span>.printHeader(_text);  <span class="comment">// 打印页眉  </span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">//_comp 本身如果是 Decorator，就会嵌套打印下去  </span></span><br><span class="line">        <span class="comment">//_comp 本身如果不是 Decorator，而是 ConcreteComponent，则打印任务到此结束  </span></span><br><span class="line">        _comp.print();                 </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FooterDecorator.java<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.oo.designpattern.decorator.<span class="type">Printer</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 页脚打印，和页眉打印类似，此处省略相同的注释代码 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FooterDecorator</span> <span class="keyword">extends</span> <span class="title">PrintDecorator</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">PrintComponent</span> _comp;   </span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> _text;           </span><br><span class="line">  </span><br><span class="line">    <span class="type">FooterDecorator</span>(<span class="type">PrintComponent</span> comp, <span class="type">String</span> text) &#123;  </span><br><span class="line">        <span class="keyword">this</span>._comp = comp;  </span><br><span class="line">        <span class="keyword">this</span>._text = text;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 打印 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    public void print() &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Printer</span>.printFooter(_text);  <span class="comment">// 打印页脚  </span></span><br><span class="line">          </span><br><span class="line">        _comp.print();                 </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TextWatermarkDecorator.java<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.oo.designpattern.decorator.<span class="type">Printer</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 文本水印打印，和页眉打印类似，此处省略相同的注释代码 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TextWatermarkDecorator</span> <span class="keyword">extends</span> <span class="title">PrintDecorator</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">PrintComponent</span> _comp;   </span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> _text;           </span><br><span class="line">  </span><br><span class="line">    <span class="type">TextWatermarkDecorator</span>(<span class="type">PrintComponent</span> comp, <span class="type">String</span> text) &#123;  </span><br><span class="line">        <span class="keyword">this</span>._comp = comp;  </span><br><span class="line">        <span class="keyword">this</span>._text = text;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 打印 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    public void print() &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Printer</span>.printTextWaterMark(_text);  <span class="comment">// 打印文本水印  </span></span><br><span class="line">          </span><br><span class="line">        _comp.print();                 </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ImgWatermarkDecorator.java<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.awt.<span class="type">Image</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.oo.designpattern.decorator.<span class="type">Printer</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 图片水印打印，和页眉打印类似，此处省略相同的注释代码 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ImgWatermarkDecorator</span> <span class="keyword">extends</span> <span class="title">PrintDecorator</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">PrintComponent</span> _comp;   </span><br><span class="line">    <span class="keyword">private</span> static <span class="type">Image</span> _logo; <span class="comment">// 图片水印只能是公司 logo          </span></span><br><span class="line">  </span><br><span class="line">    <span class="type">ImgWatermarkDecorator</span>(<span class="type">PrintComponent</span> comp) &#123;  </span><br><span class="line">        <span class="keyword">this</span>._comp = comp;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 打印 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    public void print() &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Printer</span>.printImgWaterMark(<span class="type">ImgWatermarkDecorator</span>._logo);  <span class="comment">// 打印图片水印  </span></span><br><span class="line">          </span><br><span class="line">        _comp.print();                 </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PrintServer.java<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> PrintServer &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 执行打印任务 </span><br><span class="line">     * @param comp </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executePrintTask</span><span class="params">(PrintComponent comp)</span></span>&#123;  </span><br><span class="line">        <span class="built_in">log</span>();  </span><br><span class="line">        comp.print();  </span><br><span class="line">        audit();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 记录日志 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="comment">// 省略具体实现代码  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 记录审计相关信息 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="comment">// 省略具体实现代码  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong> 类使用 <strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></p>
<p>A 部门的打印处理如下（如下代码请仔细阅读，特别是注释部分）：<br>SecretDepartment.java  – A 部门负责维护<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * A 部门的打印处理，注意与传统方法中的 SecretDepartment 类对比 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> class SecretDepartment &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 打印任务 1，对应传统方式的 SecretePrint 类 </span><br><span class="line">     * @param text </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">print</span>(<span class="keyword">String</span> <span class="built_in">text</span>)&#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">/** </span><br><span class="line">         * 使用 Decorator 设计模式后，打印任务不再是一个单独的类 SecretPrint 类， </span><br><span class="line">         * 而是通过将多个打印项目聚合成一个打印任务 </span><br><span class="line">         */</span>  </span><br><span class="line">        PrintComponent textComp = <span class="keyword">new</span> TextComponent(<span class="built_in">text</span>);  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 注意 header 聚合了 textComp  </span></span><br><span class="line">        PrintDecorator header = <span class="keyword">new</span> HeaderDecorator(textComp, <span class="string">"绝密"</span>);    </span><br><span class="line">        <span class="comment">// 注意 footer 聚合了 header，而不是 textComp，这样就能够嵌套执行下去  </span></span><br><span class="line">        PrintDecorator footer = <span class="keyword">new</span> FooterDecorator(header, <span class="string">"本文包含绝密信息，请勿泄露！"</span>);  </span><br><span class="line">        <span class="comment">// 注意 watermark 聚合了 footer，而不是 textComp，这样就能够嵌套执行下去  </span></span><br><span class="line">        PrintDecorator watermark = <span class="keyword">new</span> TextWatermarkDecorator(footer, <span class="string">"绝密文档"</span>);  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//PrintServer 即 “文档打印系统”，与传统的 PrintServer 相比，这里不需要知道打印的 text 内容  </span></span><br><span class="line">        <span class="comment">//text 内容已经封装到 TextComponent 中去了（对应代码行 14 行）  </span></span><br><span class="line">        PrintServer.executePrintTask(watermark);  <span class="comment">// 注意这里传递给打印系统的是最后一个 Decorator 对象 watermark  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * A 部门的第二个打印任务，将文本水印改为图片水印，并且不再打印页脚 </span><br><span class="line">     * @param text </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> print2(<span class="keyword">String</span> <span class="built_in">text</span>)&#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">/** </span><br><span class="line">         * 新增打印任务，无需文档管理系统增加新的类，只要 A 部门自己修改代码即可 </span><br><span class="line">         */</span>  </span><br><span class="line">        PrintComponent textComp = <span class="keyword">new</span> TextComponent(<span class="built_in">text</span>);  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 注意 header 聚合了 textComp  </span></span><br><span class="line">        PrintDecorator header = <span class="keyword">new</span> HeaderDecorator(textComp, <span class="string">"绝密"</span>);    </span><br><span class="line">        <span class="comment">// 注意 watermark 聚合了 header，而不是 textComp，这样就能够嵌套执行下去  </span></span><br><span class="line">        PrintDecorator watermark = <span class="keyword">new</span> ImgWatermarkDecorator(header);  </span><br><span class="line">          </span><br><span class="line">        PrintServer.executePrintTask(watermark);    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，使用了设计模式的方法后，打印业务的变化，可以通过类似数学上的排列组合已有的打印功能来完成，而不再需要新的打印类了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[连载：面向对象葵花宝典：思想、技巧与实践(28-35章)]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/05/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B84.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>无意间发现这篇文章，文章讲解由浅入深，读完后感触很深<br>特全文转到自己的博客，方便以后自己随时查看<br>文章转载自爱技术的华仔的博客[<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">http://blog.csdn.net/yunhua_lee</a>]<br>非常感谢<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">爱技术的华仔</a></p>
</blockquote>
<h1 id="第二十八章"><a href="#第二十八章" class="headerlink" title="第二十八章"></a>第二十八章</h1><p>前面通过实例讲解了一个一环扣一环的面向对象的开发流程：用例模型 -&gt; 领域模型 -&gt; 设计模型（类模型 + 动态模型），解答了面向对象如何做的问题。接下来我们就要讲“如何做好面向对象设计”的技巧了<a id="more"></a></p>
<p>===================================================================<br><strong>【内聚】</strong><br>参考维基百科的解释，内聚的含义如下：</p>
<blockquote>
<p>cohesion refers to the degree to which the elements of a <a href="http://en.wikipedia.org/wiki/Module_(programming" target="_blank" rel="external">module</a>) belong together.<br>（<a href="http://en.wikipedia.org/wiki/Cohesion_(computer_science)）" target="_blank" rel="external">http://en.wikipedia.org/wiki/Cohesion_(computer_science)）</a></p>
</blockquote>
<p>翻译一下即：<strong>内聚指一个模块内部元素彼此结合的紧密程度</strong>。</p>
<p>看起来很好理解，但深入思考一下，其实没有那么简单。<br>首先：“模块”如何理解？<br>你一定会说，“模块”当然就是我们所说的系统里的“XX模块”了，例如一个ERP系统的“权限”模块，一个电子商务的“支付”模块，一个论坛网站的“用户管理”模块。。。。。。等等</p>
<p>你说的没错，但在面向对象领域，谈到“内聚”的时候，模块的概念远远不止我们通常所理解的“系统内的某个模块”这个范围，而是可大可小，大到一个子系统，小到一个函数，你都可以理解为内聚里所说的“模块”。</p>
<p>所以，你可以用“内聚”来判断一个函数设计是否合理，一个类设计是否合理，一个接口设计是否合理，一个包设计是否合理，一个模块/子系统设计是否合理。</p>
<p>其次：“元素”究竟是什么？<br>有了前面对“模块”的深入研究后，元素的含义就比较容易明确了（不同语言稍有不同）。<br>函数：函数的元素就是“代码”<br>类/接口：类的元素是“函数、属性”<br>包：包的元素是“类、接口、全局数据”等<br>模块：模块的元素是“包、命名空间”等</p>
<p>再次：“结合”是什么？<br>英文的原文是“belong”，有“属于”的意思，翻译成中文“结合”，更加贴近中文的理解。但“结合”本身这个词容易引起误解。绝大部分人看到“结合”这个单词，想到的肯定是“你中有我、我中有你”这样的含义，甚至可能会联想到“美女和帅哥”的结合，抑或“青蛙王子和公主”的结合这种情况。<br>这样的理解本身也并没有错，但比较狭隘。<br>我们以类的设计为例：假如一个类里面的函数都是只依赖本类其它函数（当然不能循环调用啦），那内聚性肯定是最好的，因为“结合”得很紧密。</p>
<p>但如果这个类的函数并不依赖本类的函数呢？我们就一定能说这个类的内聚性不好么？<br>其实也不尽然，最常见的就是CRUD操作类，这几个函数相互之间没有任何结合关系（某些设计可能会先查询再修改，但这样的设计不是事务安全的），但其实这几个函数的内聚性非常高。</p>
<p>所以，关于内聚的结合概念，我认为不是非常恰当的描述。那么，就究竟什么才是真正的“内聚”呢？<br>答案就藏在显而易见的地方，翻开你的词典，仔细看看cohesion的含义，你会看到另外一个解释：凝聚力！</p>
<p><strong>“凝聚力”就是“内聚”的核心思想</strong>，抛开面向对象不谈，我们日常工作中几乎随处可见“凝聚力”：<br>你可能会说，你的团队很有凝聚力。。。。。。<br>领导可能会说：我们要增强团队的凝聚力。。。。。。<br>成功学大师会说：凝聚力是一个团队成功的基石。。。。。。。</p>
<p>面向对象领域的“凝聚力”，和团队的“凝聚力”是一样的概念。<br>l 判断团队凝聚力时，我们关注团队成员是否都专注于团队的目标；判断面向对象模块的凝聚力时，我们同样关注元素是否专注于模块的目标，即：模块本身的职责！<br>l 判断团队凝聚力时，我们还会关注团队成员之间是否互相吸引和帮助；判断面向对象模块凝聚力时，我们同样关注元素间的结合关系；</p>
<p>虽然判断内聚性的时候我们会考虑元素的结合情况，<strong>但其实是否专注模块的职责，才是内聚性的充要条件</strong>。<br>当模块的元素全部都专注于模块的职责的时候，即使元素间的结合不是很紧密，也是符合内聚性的要求的，这也是CRUD设计符合内聚性的原因。</p>
<p>所以，判断一个模块（函数、类、包、子系统）“内聚性”的高低，最重要的是关注模块的元素是否都忠于模块的职责，简单来说就是“不要挂羊头卖狗肉”。</p>
<p><strong>【耦合】</strong></p>
<p>参考维基百科，耦合的定义如下：</p>
<blockquote>
<p> coupling or dependency is the degree to which each <a href="http://en.wikipedia.org/wiki/Module_(programming" target="_blank" rel="external">program module</a>) relies on each one of the other modules<br>（<a href="http://en.wikipedia.org/wiki/Coupling_(computer_science)）" target="_blank" rel="external">http://en.wikipedia.org/wiki/Coupling_(computer_science)）</a></p>
</blockquote>
<p>简单翻译一下：耦合（或者称依赖）是程序模块相互之间的依赖程度。</p>
<p>从定义来看，耦合和内聚是相反的：内聚关注模块内部的元素结合程度，耦合关注模块之间的依赖程度。</p>
<p>理解耦合的关键有两点：什么是模块，什么是依赖。</p>
<p>什么是模块？<br>模块和内聚里面提到的模块一样，耦合中的模块其实也是可大可小。常见的模块有：函数、类、包、子模块、子系统等</p>
<p><strong>什么是依赖？</strong><br>依赖这个词很好理解，通俗的讲就是某个模块用到了另外一个模块的一些元素。<br>例如：A类使用了B类作为参数，A类的函数中使用了B类来完成某些功能。。。。。。等等</p>
<h1 id="第二十九章"><a href="#第二十九章" class="headerlink" title="第二十九章"></a>第二十九章</h1><p><strong>高内聚低耦合</strong>，可以说是每个程序猿，甚至是编过程序，或者仅仅只是在大学里面学过计算机，都知道的一个简单的设计原则。<br>虽然如此流行和人所众知，但其实<strong>真正理解的人并不多，很多时候都是人云亦云</strong>。</p>
<p>===============================================================<br>要想真正理解“高内聚低耦合”，需要回答两个问题：<br>1）为什么要高内聚低耦合？<br>2）高内聚低耦合是否意味内聚越高越好，耦合越低越好？</p>
<p><strong>第一个问题：为什么要高内聚低耦合？</strong><br>经典的回答是：降低复杂性。<br>确实很经典，当然，其实也是废话！我相信大部分人看了后还是不懂，什么叫复杂性呢？</p>
<p>要回答这个问题，其实可以采用逆向思维，即：如果我们不做到这点，将会怎样？<br>首先来看内聚，试想一下，假如我们是低内聚，情况将会如何？</p>
<p>前面我们在阐述内聚的时候提到内聚的关键在于“元素的凝聚力”，如果内聚性低，则说明凝聚力低；对于一个团队来说，如果凝聚力低，则一个明显的问题是“不稳定”；对于一个模块来说，内聚性低的问题也是一样的“不稳定”。具体来说就是如果一个模块内聚性较低，则这个模块很容易变化。一旦变化，设计、编码、测试、编译、部署的工作量就上来了，而一旦一个模块变化，与之相关的模块都需要跟着改变。</p>
<p>举一个简单的例子，假设有这样一个设计不好的类：Person，其同时具有“学生”、“运动员”、“演员”3个职责，有另外3个类“老师”、“教练”、“导演”依赖这个类。<br><strong>Person.java</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.cohesion.low;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “人”的类设计 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 学生的职责：学习 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> student's responsibility  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 运动员的职责：运动 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> sportsman's responsibility  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 演员的职责：扮演 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> actor's responsibity  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Teacher.java</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.cohesion.low;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “老师”的类设计 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Teacher</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span>(<span class="params">Person student</span>)</span>&#123;  </span><br><span class="line">        student.study(); <span class="comment">//依赖Person类的“学生”相关的职责  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Coach.java</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.cohesion.low;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “教练”的类设计 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Coach</span> &#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">train</span>(<span class="params">Person trainee</span>)</span>&#123;  </span><br><span class="line">        trainee.play();  <span class="comment">//依赖Person类的“运动员”职责  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Director.java</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.cohesion.low;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “导演”的类设计 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Director</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct</span>(<span class="params">Person actor</span>)</span>&#123;  </span><br><span class="line">        actor.act(); <span class="comment">//依赖Person类“演员”的相关职责  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的样例中，Person类就是一个典型的“低内聚”的类，很容易发生改变。比如说，现在老师要求学生也要考试，则Person类需要新增一个方法：test，如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.cohesion.low;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “人”的类设计 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 学生的职责：学习 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> student's responsibility  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 学生的职责：考试 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> student's responsibility  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 运动员的职责：运动 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> sportsman's responsibility  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 演员的职责：扮演 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> actor's responsibity  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Coach和Director类都依赖于Person类，Person类改变后，虽然这个改动和Coach、Director都没有关系，但Coach和Director类都需要重新编译测试部署（即使是PHP这样的脚本语言，至少也要测试）。</p>
<p>同样，Coach和Director也都可能增加其它对Person的要求，这样Person类就需要同时兼顾3个类的业务要求，且任何一个变化，Teacher、Coach、Director都需要重新编译测试部署。</p>
<p>对于耦合，我们采用同样的方式进行分析，<strong>即：如果高耦合，将会怎样？</strong><br>高耦合的情况下，模块依赖了大量的其它模块，这样任何一个其它依赖的模块变化，模块本身都需要受到影响。所以，高耦合的问题其实也是“不稳定”，当然，这个不稳定和低内聚不完全一样。对于高耦合的模块，可能本身并不需要修改，但每次其它模块修改，当前模块都要编译、测试、部署，工作量同样不小。</p>
<p>我们同样以一个样例来说明。假设我们要设计一个Boss类，Boss是要管整个公司的，那么我们假设这是一家“麻雀虽小五脏俱全”的公司，同时有“研发、测试、技术支持、销售、会计、行政”等部门。<br><strong>Boss.java</strong><br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.coupling</span><span class="selector-class">.high</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “老板”类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">Boss</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    private Tester tester;  </span><br><span class="line">    private Developer developer;  </span><br><span class="line">    private Supporter supporter;  </span><br><span class="line">    private Administration admin;  </span><br><span class="line">    private Accountant accountant;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * Boss每天检查工作，看到下面的代码，是否觉得Boss很忙？ </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">check</span>()&#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//检查测试工作  </span></span><br><span class="line">        tester<span class="selector-class">.report</span>();  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//检查研发工作  </span></span><br><span class="line">        developer<span class="selector-class">.report</span>();  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//检查技术支持工作  </span></span><br><span class="line">        supporter<span class="selector-class">.report</span>();  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//检查行政工作  </span></span><br><span class="line">        admin<span class="selector-class">.report</span>();  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//检查财务工作  </span></span><br><span class="line">        accountant<span class="selector-class">.report</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Accountant.java</strong><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.coupling.high;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * “财务”类 </span><br><span class="line"> * </span><br><span class="line"> */  </span><br><span class="line">public class Accountant &#123;  </span><br><span class="line">  </span><br><span class="line">    public void report()&#123;  </span><br><span class="line">        System.out.print("Accountant report");  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="strong">**Administration.java**</span></span><br><span class="line"><span class="strong">**[java]**</span> [<span class="string">view plain</span>](<span class="link">http://blog.csdn.net/yunhua_lee/article/details/25074707#</span>) [<span class="string">copy</span>](<span class="link">http://blog.csdn.net/yunhua_lee/article/details/25074707#</span>)</span><br><span class="line"> [<span class="string">![在CODE上查看代码片</span>](<span class="link">https://code.csdn.net/assets/CODE_ico.png</span>)](<span class="link">https://code.csdn.net/snippets/328340</span>)[<span class="string">![派生到我的代码片</span>](<span class="link">https://code.csdn.net/assets/ico_fork.svg</span>)](<span class="link">https://code.csdn.net/snippets/328340/fork</span>)</span><br><span class="line"></span><br><span class="line">package com.oo.coupling.high;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * “行政”类  </span><br><span class="line"> * </span><br><span class="line"> */  </span><br><span class="line">public class Administration &#123;  </span><br><span class="line">  </span><br><span class="line">    public void report()&#123;  </span><br><span class="line">        System.out.print("Administration report");  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Developer.java</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.coupling.high;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “开发”类 </span><br><span class="line"> * @author Administrator </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Developer</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.print(<span class="string">"Developer report"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Supporter.java</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.coupling.high;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “技术支持”类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Supporter</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.print(<span class="string">"Supporter report"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Tester.java</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.coupling.high;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “测试”类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tester</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.print(<span class="string">"Tester report"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好吧，Boss很忙，我们也很钦佩，但是有一天，研发的同学觉得他们应该做更多的事情，于是他们增加了一个“研究”的工作，且这个工作也不需要报告给Boss，例如：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.coupling.high;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “开发”类 </span><br><span class="line"> * @author Administrator </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Developer</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.print(<span class="string">"Developer report"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 研发新增加一个研究的任务，这个任务也不需要向Boss汇报 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">research</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.print(<span class="string">"Developer is researching big data, hadoop :)"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然这个工作不需要报告给Boss，但由于Developer类修改了，那么Boss类就需要重新编译测试部署。其它几个Tester、Supporter类等也是类似，一旦改变，即使这些类和Boss类半毛钱关系都没有，Boss类还是需要重新编译测试部署，所以Boss类是很不稳定的。</p>
<p>所以，无论是“低内聚”，还是“高耦合”，其本质都是“不稳定”，不稳定就会带来工作量，带来风险，这当然不是我们希望看到的，所以我们应该做到“高内聚低耦合”。</p>
<p>回答完第一个问题后，我们来看第二个问题：高内聚低耦合是否意味着内聚越高越好，耦合越低越好？<br>按照我们前面的解释，内聚越高，一个类越稳定；耦合越低，一个类也很稳定，所以当然是内聚越高越好，耦合越低越好了。<br>但其实稍有经验的同学都会知道这个结论是错误的，并不是内聚越高越好，耦合越低越好，<strong>真正好的设计是在高内聚和低耦合间进行平衡，也就是说高内聚和低耦合是冲突的</strong>。</p>
<p>我们详细来分析一下为什么高内聚和低耦合是冲突的。<br>对于内聚来说，最强的内聚莫过于一个类只写一个函数，这样内聚性绝对是最高的。但这会带来一个明显的问题：类的数量急剧增多，这样就导致了其它类的耦合特别多，于是整个设计就变成了“高内聚高耦合”了。由于高耦合，整个系统变动同样非常频繁。</p>
<p>同理，对于耦合来说，最弱的耦合是一个类将所有的函数都包含了，这样类完全不依赖其它类，耦合性是最低的。但这样会带来一个明显的问题：内聚性很低，于是整个设计就变成了“低耦合低内聚”了。由于低内聚，整个类的变动同样非常频繁。<br>对于“低耦合低内聚”来说，还有另外一个明显的问题：几乎无法被其它类重用。原因很简单，类本身太庞大了，要么实现很复杂，要么数据很大，其它类无法明确该如何重用这个类。</p>
<p>所以，内聚和耦合的两个属性，排列组合一下，<strong>只有“高内聚低耦合”才是最优的设计</strong>。<br>因此，在实践中我们需要牢牢记住需要在高内聚和低耦合间进行平衡，而不能走极端。 具体如何平衡，且听下回分解。</p>
<h1 id="第三十章"><a href="#第三十章" class="headerlink" title="第三十章"></a>第三十章</h1><p>前面详细阐述了“高内聚低耦合”的总体设计原则，但如何让设计满足这个原则，并不是一件简单的事情，幸好各位前辈和大牛已经帮我们归纳总结出来了，这就是“设计原则”和“设计模式”。毫不夸张的说，<strong>只要你吃透这些原则和模式并熟练应用，就能够做出很好的设计</strong>。</p>
<p>==================================================================</p>
<p><strong>【SRP原则详解】</strong><br>SRP，single responsibility principle，中文翻译为“单一职责原则”！</p>
<p>这是面向对象类设计的第一个原则，也是看起来最简单的一个原则，但这实际上远远没有那么简单，很多人都不一定真正理解了！</p>
<p>我们随便找几个网上的解释，看看各位大师或者经典网站是如何解释的：<br>百度百科（<a href="http://baike.baidu.com/view/1545205.htm" target="_blank" rel="external">http://baike.baidu.com/view/1545205.htm</a>）：</p>
<blockquote>
<p>一个类应该有且仅有一个职责。关于职责的含意，面向对象大师Robert.C.Martin有一个著名的定义：所谓一个类的职责是指引起该类变化的原因，如果一个类具有一个以上的职责，那么就会有多个不同的原因引起该类变化，其实就是耦合了多个互不相关的职责，就会降低这个类的内聚性。</p>
</blockquote>
<p>说句实话，虽然是面向对象大师Martin的解释，我还是看得不甚明白：引起类变化的原因太多了，例如：<br>给类加一个方法是变化吧？<br>给类加一个属性是变化吧？<br>类的函数增加一个参数是变化吧？<br>。。。。。。<br>引起这些变化的原因太多了，如果每个原因都是一个职责，那SRP原则简直就没法判断了！</p>
<p>Wiki百科（<a href="http://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="external">http://en.wikipedia.org/wiki/Single_responsibility_principle</a> ）内容和百度百科基本一致，看起来百度百科像wiki百科的翻译：）</p>
<blockquote>
<p>Martin defines a responsibility as a reason to change, and concludes that a class or module should have one, and only one, reason to change.</p>
</blockquote>
<p>除了这些标准的解释外，还有一种说法：SRP就是指每个类只做一件事！<br>这个解释更通俗易懂，也更加适合中国人理解。虽然比Martin大师的解释更清楚一些，但仔细想想，还是有个地方比较难以理解：什么叫做“一件事”？</p>
<p>比如说一个学生信息管理类，这个类有“添加学生信息”、“查询学生信息”、“修改学生信息”、“删除学生信息”，那么这是4件事情，还是一件事情呢？</p>
<p>看起来好像是4个事情，但稍有经验的朋友应该都知道，这4个事情绝大部分情况下都是一个类来实现的，而不是分成4个类！</p>
<p>所以关键的问题在于：什么是“一件事”？是每个功能一件事情么？ </p>
<p>其实答案就在我们自己身上，因为只要我们工作，无时不刻的承担着一定的“职责”！<br>现在让我们抛开面向对象，抛开软件，抛开计算机，来看看我们自己的“职责”。</p>
<p>比如说，我是一个程序猿，我的职责应该是“写程序”，但写程序有很多事情，例如：编码，单元测试、系统测试，bug修复，开会，写文档。。。。。。<br>再比如说，我的BOSS是一个管理者，他的职责是“管理程序猿”，他也有很多工作，例如：制定计划，团队建设、开会、协调资源、写文档。。。。。。<br>又比如说，我是一个快递员，也有很多工作：分包、快递、收款、开会。。。。。。</p>
<p>这些职责其实都不是我们自己定义的，而是公司或者部门或者组织给我们安排工作的时候定义的，也就是说：“职责”是站在他人的角度来定义的，而不是自己定义的，也许你想把自己定义成CEO，但你的老板会真的让你当CEO么？</p>
<p>经过对我们自己的职责的分析，我们可以得出两个关于职责的重要结论：<br>1） 职责是站在他人的角度来定义的<br>2） 职责不是一件事，而是很多事情，但这些事情都是和职责紧密相关的</p>
<p>对应到面向对象设计领域，我们可以说一个类的职责应该如下定义：<br>1） 类的职责是站在其它类的角度来定义的；<br>2） 类的职责包含多个相关功能；</p>
<p>因此，SRP可以翻译成“<strong>一个类只负责一组相关的事情</strong>”，对应到代码中就是：一个类有多个方法，这些方法是相关的。</p>
<p>当然，如果你再让我解释什么是“相关”，那我只能吐血了：）</p>
<p>有了这个定义，我们再来看“学生信息管理类”，很明显，学生管理类具有的4个功能都是和“管理”相关的，按照SRP原则，应该只设计一个“学生信息管理类”就可以了。</p>
<p><strong>【SRP原则范围】</strong><br>但现实世界往往比理想要复杂，一个最典型的例子就是“办公一体机”。<br>根据SRP原则，打印机可以设计成一个类，复印机也可以设计成一个类，扫描仪也可以设计成一个类，传真机还是可以设计成一个类，但偏偏就是出了个“办公一体机”，这个机器集成了“打印、复印、扫描、传真”4个职责！<br>如果我们要设计一个“办公一体机”的类，怎么也不可能设计出一个符合SRP原则的“办公一体机”的类来！</p>
<p>怎么办？是SRP不正确么，还是我们永远都不要设计“办公一体机”这样的类？</p>
<p>其实SRP也没有错，“办公一体机”也应该设计，但：不要用SRP来约束“办公一体机”这样的类！<br>也就是说，SRP其实是有适应范围的，SRP只适合那些基础类，而不适合基于基础类构建复杂的聚合类。</p>
<p>在“办公一体机“的样例中，“打印机”、“复印机”、“扫描仪”、“传真机”都是基础类，每个类都承担一个职责，而办公一体机是“聚合类”，同时集成了4种功能！</p>
<p>细心的朋友可能会继续问道：SRP不能应用于聚合类，那么如何保证聚合类的设计质量呢？<br>这个问题的答案在GoF的《设计模式》一书中有详细的答案，即：优先使用对象组合，而不是类继承。详细内容请参考后续“设计模式”部分的内容</p>
<h1 id="第三十一章"><a href="#第三十一章" class="headerlink" title="第三十一章"></a>第三十一章</h1><p>开闭原则是一个大部分人都知道，但大部分人都不懂的设计原则！</p>
<p>====================================================================<br>OCP，Open-Closed Principle，中文翻译为“开闭原则”。</p>
<p>当我第一次看到OCP原则时，我的感觉就是这原则也太抽象了吧，什么开，什么闭呢？</p>
<p>然后我去寻找更加详细的答案，最经典也是最常见的解释就是维基百科了：<br><a href="http://en.wikipedia.org/wiki/Open/closed_principle" target="_blank" rel="external">http://en.wikipedia.org/wiki/Open/closed_principle</a> </p>
<blockquote>
<p>“software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification”;</p>
</blockquote>
<p>翻译一下就是：对扩展开放，对修改封闭！</p>
<p>虽然这句解释更详细了，但其实还是很难理解，我因此去请教了一个前辈高人，他的回答更加惊世骇俗：不修改代码就可以增加新功能！！</p>
<p>当时我听到这句话就震惊了，这是多么神奇的事情啊，不修改代码就能够增加新功能！<br>但问题是：怎么做到的呢？难道这个原则是有关<a href="http://lib.csdn.net/base/2" target="_blank" rel="external">人工智能</a>，又或者有什么高超的技巧，能够做到不修改代码增加新功能？</p>
<p>这么牛逼的原则当然要继续探索了，但怎么也没有找到“不修改代码就可以增加新功能”的独门秘籍！</p>
<p>于是对这个原则有了怀疑，经过继续的探索和查看各种资料，才发现原来是各位大师们在解释这个原则的时候隐藏了非常重要的“主语”，而这才是OCP原则的关键！</p>
<p>大师们省略的主语一个就是consumer（翻译成使用者、消费者），一个就是provider（翻译成生产者、提供着），例如A类调用了B类的方法，则A就是consumer，B就是provider。</p>
<p>完整的OCP原则实际上应该这样表述：open for provider extension，closed for consumer modification，翻译一下就是：对使用者修改关闭，对提供者扩展开放！</p>
<p>更通俗的意思就是：提供者增加新的功能，但使用者不需要修改代码！</p>
<p>虽然到这里我们已经基本上将OCP原则解释清楚了，但实际上细心的朋友还是会发现有问题的：提供者增加新的功能，使用者不修改代码就能用上么？<br>比如说：你设计一款有关车游戏，需要设计一个“car”的类，这个类原来有“加速”、“刹车”、“转向”三个功能，现在你要加一个新功能“改装”，游戏中其它类例如player，不修改代码就可以用上“改装”这个功能么？</p>
<p>很显然这是不可能的，我都新加了一个函数，你都不调用就能用新的功能，这也太邪乎了吧？</p>
<p>答案在于所谓的增加新功能，并不是增加一个全新的功能，而是原有的功能有了替代实现，这也是英文的“extension”所隐含的深意！</p>
<p>继续以赛车car作为例子，假设现在你设计了“卡车”、“跑车”、“家用车”三种车，现在要增加一种车“卡丁车”，只要“卡丁车”也实现了“加速”、“刹车”、“转向”，那么player不需要修改代码，就可以玩“卡丁车”了；但如果你增加了一种“改装”的功能，那么player必须修改才能使用“改装”功能。</p>
<p>对应到代码上来说，OCP的应用原则如下：<br>1） <strong>接口不变</strong>：包括函数名、函数参数、函数返回值等，可以应用OCP<br>2） <strong>接口改变</strong>：已有函数修改名称、参数、返回值，或者增加新的函数，OCP都不再适应</p>
<p>虽然OCP原则是针对类设计提出来的原则，但其思想其实适应很广，系统和系统、子系统和子系统、模块和模块之间都可以应用OCP原则，而且不同的地方应用其实都是遵循同一个原则：<strong>通过接口交互</strong>！例如：<br>1） 类之间应用OCP：使用interface进行交互；<br>2）模块和模块、系统和系统：使用规定好的协议，不管是私有的还是公开的，例如HTTP、SOAP</p>
<h1 id="第三十二章"><a href="#第三十二章" class="headerlink" title="第三十二章"></a>第三十二章</h1><h1 id="LSP是唯一一个以人名命名的设计原则，而且作者还是一个“女博士”"><a href="#LSP是唯一一个以人名命名的设计原则，而且作者还是一个“女博士”" class="headerlink" title="LSP是唯一一个以人名命名的设计原则，而且作者还是一个“女博士” "></a>LSP是唯一一个以人名命名的设计原则，而且作者还是一个“女博士” </h1><hr>
<p><strong>LSP</strong>，Liskov substitution principle，中文翻译为“<strong>里氏替换原则</strong>”。</p>
<p>这是面向对象原则中唯一一个以人名命名的原则，虽然Liskov在中国的知名度没有UNIX的几位巨匠（Kenneth Thompson、Dennis Ritchie）、GOF四人帮那么响亮，但查一下资料，你会发现其实Liskov也是非常牛的：2008年图灵奖获得者，历史上第一个女性计算机博士学位获得者。其详细资料可以在维基百科上查阅：<a href="http://en.wikipedia.org/wiki/Barbara_Liskov" target="_blank" rel="external">http://en.wikipedia.org/wiki/Barbara_Liskov</a> </p>
<p>言归正传，我们来看看LSP原则到底是怎么一回事。<br>LSP最原始的解释当然来源于Liskov女士了，她在1987年的OOPSLA大会上提出了LSP原则，1988年，她将文章发表在ACM的SIGPLAN Notices杂志上，其中详细解释了LSP原则：<br>A type hierarchy is composed of subtypes and supertypes. The intuitive idea of a subtype is one whose objects provide all the behavior of objects of another type (the supertype) plus something extra.What is wanted here is something like the following substitution property: If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.</p>
<p>英文比较长，看起来比较累，我们简单的翻译并归纳一下：<br>1） <strong>子类的对象提供了父类的所有行为</strong>，且加上子类额外的一些东西（可以是功能，也可以是属性）；<br>2） 当程序基于父类实现时，<strong>如果将子类替换父类而程序不需要修改</strong>，则说明符合LSP原则</p>
<p>虽然我们稍微翻译和整理了一下，但实际上还是很拗口和难以理解。<br>幸好还有Martin大师也觉得这个不怎么通俗易懂，Robert Martin在1996年为《C++ Reporter》写了一篇题为《The The Liskov Substitution Principle》的文章，解释如下：<br>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</p>
<p>翻译一下就是：函数使用指向父类的指针或者引用时，必须能够在不知道子类类型的情况下使用子类的对象。</p>
<p>Martin大师解释了一下，相对容易理解多了。但Martin大师还不满足，在2002年，Martin在他出版的《Agile   Software   Development   Principles   Patterns   and   Practices》一书中，又进一步简化为：<br>Subtypes   must   be   substitutable   for   their   base   types。</p>
<p>翻译一下就是：子类必须能替换成它们的父类。</p>
<p>经过Martin大师的两次翻译，我相信LSP原则本身已经解释得比较容易理解了，但问题的关键是：如何满足LSP原则？或者更通俗的讲：什么情况下子类才能替换父类？</p>
<p>我们知道，对于调用者来说（Liskov解释中提到的P），和父类交互无非就是两部分：调用父类的方法、得到父类方法的输出，中间的处理过程，P是无法知道的。</p>
<p>也就是说，调用者和父类之间的联系体现在两方面：函数输入，函数输出。详细如下图：<br> <img src="http://ww3.sinaimg.cn/large/666cc9e3gw1f4977znz1ij208401na9x.jpg" alt=""><br>有了这个图之后，如何做到LSP原则就清晰了：<br>1） <strong>子类必须实现或者继承父类所有的公有函数</strong>，否则调用者调用了一个父类中有的函数，而子类中没有，运行时就会出错；<br>2） <strong>子类每个函数的输入参数必须和父类一样</strong>，否则调用父类的代码不能调用子类；<br>3） <strong>子类每个函数的输出</strong>（返回值、修改全局变量、插入数据库、发送网络数据等）必须不比父类少，否则基于父类的输出做的处理就没法完成。</p>
<p>有了这三条原则后，就可以很方便的判断类设计是否符合LSP原则了。需要注意的是第3条的关键是“不比父类少”，也就是说可以比父类多，即：父类的输出是子类输出的子集。</p>
<p>有的朋友看到这三条原则可能有点纳闷：这三条原则一出，那子类还有什么区别哦，岂不都是一样的实现了，那还会有不同的子类么？</p>
<p>其实如果仔细研究这三条原则，就会发现其中<strong>只是约定了输入输出，而并没有约束中间的处理过程</strong>。例如：同样一个写数据库的输出，A类可以是读取XML数据然后写入数据库，B类可以是从其它数据库读取数据然后本地的数据库，C类可以是通过分析业务日志得到数据然后写入数据库。这3个类的处理过程都不一样，但最后都写入数据到数据库了。</p>
<p>LSP原则最经典的例子就是“长方形和正方形”这个例子。从数学的角度来看，正方形是一种特殊的长方形，但从面向对象的角度来观察，正方形并不能作为长方形的一个子类。原因在于对于长方形来说，设定了宽高后，面积 = 宽 <em> 高；但对于正方形来说，设定高同时就设定了宽，设定宽就同时设定了高，最后的面积并不是等于我们设定的 宽 </em> 高，而是等于最后一次设定的宽或者高的平方。</p>
<p>具体代码样例如下：<br>Rectangle.Java<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.oo.java.principles.lsp;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 长方形 </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Rectangle &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> _width;  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> _height;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 设定宽 </span><br><span class="line">     * @param width </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setWidth(<span class="keyword">int</span> <span class="built_in">width</span>)&#123;  </span><br><span class="line">        <span class="keyword">this</span>._width = <span class="built_in">width</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 设定高 </span><br><span class="line">     * @param height </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setHeight(<span class="keyword">int</span> <span class="built_in">height</span>)&#123;  </span><br><span class="line">        <span class="keyword">this</span>._height = <span class="built_in">height</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 获取面积 </span><br><span class="line">     * @return </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getArea()&#123;  </span><br><span class="line">        <span class="built_in">return</span> <span class="keyword">this</span>._width * <span class="keyword">this</span>._height;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Square.java<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.oo.java.principles.lsp;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 正方形 </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Square extends Rectangle &#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 设定“宽”，与长方形不同的是：设定了正方形的宽，同时就设定了正方形的高 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setWidth(<span class="keyword">int</span> <span class="built_in">width</span>)&#123;  </span><br><span class="line">        <span class="keyword">this</span>._width = <span class="built_in">width</span>;  </span><br><span class="line">        <span class="keyword">this</span>._height = <span class="built_in">width</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 设定“高”，与长方形不同的是：设定了正方形的高，同时就设定了正方形的宽 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setHeight(<span class="keyword">int</span> <span class="built_in">height</span>)&#123;  </span><br><span class="line">        <span class="keyword">this</span>._width = <span class="built_in">height</span>;  </span><br><span class="line">        <span class="keyword">this</span>._height = <span class="built_in">height</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>UnitTester.java<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.oo.java.principles.lsp;  </span><br><span class="line">  </span><br><span class="line">public class UnitTester &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] <span class="built_in">args</span>)&#123;  </span><br><span class="line">        Rectangle <span class="built_in">rectangle</span> = <span class="built_in">new</span> Rectangle();  </span><br><span class="line">        <span class="built_in">rectangle</span>.setWidth(<span class="number">4</span>);  </span><br><span class="line">        <span class="built_in">rectangle</span>.setHeight(<span class="number">5</span>);  </span><br><span class="line">          </span><br><span class="line">        //如下assert判断为<span class="literal">true</span>  </span><br><span class="line">        assert( <span class="built_in">rectangle</span>.getArea() == <span class="number">20</span>);  </span><br><span class="line">          </span><br><span class="line">        <span class="built_in">rectangle</span> = <span class="built_in">new</span> Square();  </span><br><span class="line">        <span class="built_in">rectangle</span>.setWidth(<span class="number">4</span>);  </span><br><span class="line">        <span class="built_in">rectangle</span>.setHeight(<span class="number">5</span>);  </span><br><span class="line">          </span><br><span class="line">        //&lt;span <span class="built_in">style</span>=<span class="string">"color:#ff0000;"</span>&gt;如下assert判断为<span class="literal">false</span>，断言失败，抛出java.lang.AssertionError&lt;/span&gt;  </span><br><span class="line">        assert( <span class="built_in">rectangle</span>.getArea() == <span class="number">20</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这个样例同时也给出了一个判断子类是否符合LSP的取巧的方法，即：针对父类的单元测试用例，传入子类是否也能够测试通过。如果测试能够通过，则说明符合LSP原则，否则就说明不符合LSP原则</p>
<h1 id="第三十三章"><a href="#第三十三章" class="headerlink" title="第三十三章"></a>第三十三章</h1><p><strong>ISP</strong>，Interface Segregation Principle，中文翻译为“<strong>接口隔离原则</strong>”。</p>
<p>和DIP原则一样，ISP原则也是大名鼎鼎的Martin大师提出来的，他在1996年的C++ Reporter发表“ The Interface Segregation Principle”的文章详细阐述了ISP原则，并且在他的经典著作《 Agile Software Development, Principles, Patterns》（中文翻译为：敏捷软件开发：原则、模式与实践）、《Practices, and Agile Principles, Patterns, and Practices in C#》（中文翻译为：敏捷软件开发：原则、模式与实践（C#版））中详细解释了ISP原则。</p>
<p>ISP最原始的定义如下：<br>“CLIENTS SHOULD NOT BE FORCED TO DEPEND UPON INTERFACES THAT THEY DO NOT USE.”<br>翻译成中文就是“客户端不应该被强迫去依赖它们并不需要的接口”。</p>
<p>单纯从字面意思来看，ISP原则是5个原则中最好理解的一个了。但是我们深入思考一下，其实发现也没有那么简单。如果你还记得我们前面讲的那些原则，你可能会想到一个问题：既然有了SRP，为什么还要ISP？</p>
<p>现在我们来回想一下SRP原则，如果类满足了SRP原则，那么基于这个类提炼的接口不就自然而然的满足了ISP原则了么？为什么我们还要费神费力的又搞一个ISP原则呢？</p>
<p>Martin大师自然不会是吃饱了没事做，故意整个东东来折腾大家，他在ISP的论文中有这么一句话交代了ISP原则，可惜的是很多人都没有把这句话贴出来：<br>The ISP acknowledges that there are objects that require non-cohesive interfaces;<br>however it suggests that clients should not know about them as a single class. Instead, clients<br>should know about abstract base classes that have cohesive interfaces.</p>
<p>翻译一下：ISP原则承认对象需要非内聚的接口，然而ISP原则建议客户端不需要知道整个类，只需要知道具有内聚接口的抽象父类即可。</p>
<p>也就是说，<strong>ISP应用的场景是某些类不满足SRP原则，但使用这些类的客户端（即调用的类）应该根据接口来使用它，而不是直接使用它</strong>。</p>
<p>虽然翻译了一下，但还是比较抽象，给个例子一看就明白了，而且已经有一个很好的例子了，即SRP原则中的“一体机”。</p>
<p>在“一体机”的样例中，虽然“一体机”同时具备“打印、复印、扫描、传真”的功能，但我们并不会设计一个“一体机”的接口，而是设计4个接口。这样调用接口的类可以根据自己需要精确使用某个接口，而不是调用一个大而全的接口。</p>
<p>具体代码如下：</p>
<p>ICopier.Java</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.java.principles.isp;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 复印机接口 </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICopier</span> &#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 复印 </span><br><span class="line">     * @param paper </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">copy</span>(<span class="params">Paper paper</span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IFaxMachine.java<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.oo.java.principles.isp;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * 传真机接口 </span><br><span class="line"> */  </span><br><span class="line">public interface IFaxMachine &#123;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 传真 </span><br><span class="line">     * @param msg </span><br><span class="line">     */  </span><br><span class="line">    void fax(String msg);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">IPrinter.java</span><br><span class="line"><span class="strong">**[java]**</span> [<span class="string">view plain</span>](<span class="link">http://blog.csdn.net/yunhua_lee/article/details/27698945#</span>) [<span class="string">copy</span>](<span class="link">http://blog.csdn.net/yunhua_lee/article/details/27698945#</span>)</span><br><span class="line"> [<span class="string">![在CODE上查看代码片</span>](<span class="link">https://code.csdn.net/assets/CODE_ico.png</span>)](<span class="link">https://code.csdn.net/snippets/370671</span>)[<span class="string">![派生到我的代码片</span>](<span class="link">https://code.csdn.net/assets/ico_fork.svg</span>)](<span class="link">https://code.csdn.net/snippets/370671/fork</span>)</span><br><span class="line"></span><br><span class="line">package com.oo.java.principles.isp;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * 打印机接口 </span><br><span class="line"> */  </span><br><span class="line">public interface IPrinter &#123;  </span><br><span class="line">      </span><br><span class="line">    /** </span><br><span class="line">     * 打印 </span><br><span class="line">     * @param doc </span><br><span class="line">     */  </span><br><span class="line">    void print(Document doc);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>IScanner.java<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.java.principles.isp;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 扫描仪接口 </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IScanner</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 扫描 </span><br><span class="line">     * @param paper </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scan</span>(<span class="params">Paper paper</span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MultiFuncPrinter.java<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.java</span><span class="selector-class">.principles</span><span class="selector-class">.isp</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 多功能打印机（一体机） </span><br><span class="line"> * 实现了IFaxMachine（传真机）、ICopier（复印机）、IPrinter（打印机）、IScanner（扫描仪）4个接口 </span><br><span class="line"> * 而不是提供一个IMultiFuncPrinter的接口，同时提供以上接口的功能 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">MultiFuncPrinter</span> <span class="selector-tag">implements</span> <span class="selector-tag">IFaxMachine</span>, <span class="selector-tag">ICopier</span>, <span class="selector-tag">IPrinter</span>, <span class="selector-tag">IScanner</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void scan(Paper paper) &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void print(Document doc) &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void copy(Paper paper) &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void fax(String msg) &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>People.java<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.java</span><span class="selector-class">.principles</span><span class="selector-class">.isp</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 人 </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">People</span> &#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 复印操作，copy方法依赖ICopier接口，而不是使用MutiFuncPrinter类 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">copy</span>(ICopier copier, Paper paper)&#123;  </span><br><span class="line">        copier<span class="selector-class">.copy</span>(paper);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 打印操作，print方法依赖IPrinter接口，而不是使用MutiFuncPrinter类 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">print</span>(IPrinter printer, Document doc)&#123;  </span><br><span class="line">        printer<span class="selector-class">.print</span>(doc);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 传真操作，fax方法依赖IFaxMachine接口，而不是使用MutiFuncPrinter类 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">fax</span>(IFaxMachine faxer, String message)&#123;  </span><br><span class="line">        faxer<span class="selector-class">.fax</span>(message);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 扫描操作，scan方法依赖IScanner接口，而不是使用MutiFuncPrinter类 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">scan</span>(IScanner scanner, Paper paper)&#123;  </span><br><span class="line">        scanner<span class="selector-class">.scan</span>(paper);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Tester.java<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.oo.java.principles.isp;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Tester &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> mai(String args[])&#123;  </span><br><span class="line">        People people = <span class="keyword">new</span> People();  </span><br><span class="line">        MultiFuncPrinter mfp = <span class="keyword">new</span> MultiFuncPrinter();  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//如下函数都是使用mfp作为参数，但实际上是使用了MultiFuncPrinter类实现了的不同接口  </span></span><br><span class="line">        people.<span class="keyword">copy</span>(mfp, <span class="keyword">new</span> Paper());     <span class="comment">//使用了MultiFuncPrinter类的ICopier接口，  </span></span><br><span class="line">        people.fax(mfp, <span class="string">"I love oo"</span>);      <span class="comment">//使用了MultiFuncPrinter类的IFaxMachine接口，  </span></span><br><span class="line">        people.<span class="keyword">print</span>(mfp, <span class="keyword">new</span> Document()); <span class="comment">//使用了MultiFuncPrinter类的IPrinter接口，  </span></span><br><span class="line">        people.scan(mfp, <span class="keyword">new</span> Paper());     <span class="comment">//使用了MultiFuncPrinter类的IScanner接口，  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="第三十四章"><a href="#第三十四章" class="headerlink" title="第三十四章"></a>第三十四章</h1><p>DIP，dependency inversion principle<strong>，中文翻译为“依赖倒置原则”。</strong></p>
<p>DIP是大名鼎鼎的Martin大师提出来的，他在1996 5月的C++ Reporter发表“ The Dependency Inversion Principle”的文章详细阐述了DIP原则，并且在他的经典著作《 Agile Software Development, Principles, Patterns》（中文翻译为：敏捷软件开发：原则、模式与实践）、《Practices, and Agile Principles, Patterns, and Practices in C#》（中文翻译为：敏捷软件开发：原则、模式与实践（C#版））中详细解释了DIP原则。</p>
<p>DIP原则主要有两点含义：<br>1） 高层模块不应该直接依赖低层模块，两者都应该依赖抽象层；<br>2） 抽象不能依赖细节，细节必须依赖抽象；</p>
<p>虽然DIP原则的解释非常清楚，但要真正理解也不那么简单，因为有几个关键的术语都比较抽象，我们需要更详细的解析：<br>1）什么是模块？<br>英文中用到了module、component，但我们这是在讲类的设计原则，为什么要把DIP拉进来呢？<br>其实Martin大师只是讲一个设计原则而已，这个原则可以应用到软件系统不同的层级。<br>例如：站在<a href="http://lib.csdn.net/base/16" target="_blank" rel="external">架构</a>层的角度，模块可以指子系统subsystem<br>站在子系统的角度，模块可以指module，component<br>站在模块的角度：模块可以指类<br>所以说，这里的模块应该是一个广义的概念，而不是狭义的软件系统里各个子模块。</p>
<p>2）什么是依赖？<br>这里的依赖对应到具体的面向对象领域其实包含几个内容：<br>高层模块“依赖”低层模块：指高层模块需要调用低层模块的方法；<br>高层模块依赖抽象层：指高层模块基于抽象层编程；<br>低层模块依赖抽象层：指低层模块继承（inheritance）或者实现（implementation）抽象层；<br>细节依赖抽象：其实和上一个依赖是同一个意思；</p>
<p>所以说，大师就是大师啊，一个简简单单的“依赖”将各种情况都概括进来了，只是苦了我们这些平凡人，要么导致无法理解，要么导致理解错误：（</p>
<p>我们以一个简单样例来详细解释这些依赖，样例包含一个Player类，代表玩家；ICar接口，代表汽车；Benz、Ford、Chery代表具体的汽车，详细的代码如下</p>
<p>【Player】<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.oop</span><span class="selector-class">.dip</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 玩家，对应DIP中的“高层模块”  </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">Player</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 开福特 </span><br><span class="line">     * 不好的依赖：对应DIP中的“高层模块依赖低层模块”，Player直接使用了Ford类对象作为参数，Ford类修改，Player类【需要】重新编译测试 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">play</span>(Ford car)  </span><br><span class="line">    &#123;  </span><br><span class="line">        car<span class="selector-class">.accelerate</span>();  </span><br><span class="line">        car<span class="selector-class">.shift</span>();  </span><br><span class="line">        car<span class="selector-class">.steer</span>();  </span><br><span class="line">        car<span class="selector-class">.brake</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 开奔驰 </span><br><span class="line">     * 不好的依赖：对应DIP中的“高层模块依赖低层模块”，Player直接使用了Benz类对象作为参数，Benz类修改，Player类【需要】重新编译测试 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">play</span>(Benz car)  </span><br><span class="line">    &#123;  </span><br><span class="line">        car<span class="selector-class">.accelerate</span>();  </span><br><span class="line">        car<span class="selector-class">.shift</span>();  </span><br><span class="line">        car<span class="selector-class">.steer</span>();  </span><br><span class="line">        car<span class="selector-class">.brake</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 开奇瑞 </span><br><span class="line">     * 不好的依赖：对应DIP中的“高层模块依赖低层模块”，Player直接使用了Chery类对象作为参数，Chery类修改，Player类【需要】重新编译测试 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">play</span>(Chery car)  </span><br><span class="line">    &#123;  </span><br><span class="line">        car<span class="selector-class">.accelerate</span>();  </span><br><span class="line">        car<span class="selector-class">.shift</span>();  </span><br><span class="line">        car<span class="selector-class">.steer</span>();  </span><br><span class="line">        car<span class="selector-class">.brake</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 开车 </span><br><span class="line">     * 好的依赖： 对应DIP中的“高层模块依赖抽象层”，Player依赖ICar接口，不需要知道具体的车类型，Ford、Benz、Chery类修改，Player类【不需要】重新编译测试，只有ICar修改的时候Player才需要修改 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">play</span>(ICar car)  </span><br><span class="line">    &#123;  </span><br><span class="line">        car<span class="selector-class">.accelerate</span>();  </span><br><span class="line">        car<span class="selector-class">.shift</span>();  </span><br><span class="line">        car<span class="selector-class">.steer</span>();  </span><br><span class="line">        car<span class="selector-class">.brake</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>【ICar】<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.oop.dip;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 汽车接口，对应DIP中的抽象层 </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICar</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 加速 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accelerate</span>(<span class="params"></span>)</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 换挡 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shift</span>(<span class="params"></span>)</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 转向 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">steer</span>(<span class="params"></span>)</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 刹车 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brake</span>(<span class="params"></span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>【Benz】<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.oop</span><span class="selector-class">.dip</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 奔驰，实现了ICar接口，对应DIP中的“低层依赖抽象层”  </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">Benz</span> <span class="selector-tag">implements</span> <span class="selector-tag">ICar</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void accelerate() &#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//加速非常快  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Benz accelerate: very fast !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void shift() &#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//自动挡  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Benz shift:  automatic transmission !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void steer() &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//非常平稳  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Benz steer:  very smooth，ESP &amp;&amp; DSC &amp;&amp; VSC !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void brake() &#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//刹车辅助系统  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Benz steer:  ABS &amp;&amp; EBA &amp;&amp; BAS &amp;&amp; BA !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>【Ford】<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.oop</span><span class="selector-class">.dip</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 福特，实现了ICar接口，对应DIP中的“低层依赖抽象层”  </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">Ford</span> <span class="selector-tag">implements</span> <span class="selector-tag">ICar</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void accelerate() &#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//加速快  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Ford accelerate: fast !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void shift() &#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//手自一体变速器  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Ford shift:  Tiptronic transmission !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void steer() &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//平稳  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Ford steer:  smooth，ESP !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void brake() &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//刹车辅助系统  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Ford steer:  ABS &amp;&amp; EBA &amp;!!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>【Chery】<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.oop</span><span class="selector-class">.dip</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 奇瑞，实现了ICar接口，对应DIP中的“低层依赖抽象层”  </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">Chery</span> <span class="selector-tag">implements</span> <span class="selector-tag">ICar</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void accelerate() &#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//加速慢  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Chery accelerate: slow !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void shift() &#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//手动挡  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Chery shift:  manual transmission !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void steer() &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//平稳  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Chery steer:  smooth，ESP &amp;&amp; DSC !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void brake() &#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//刹车辅助系统  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Chery steer:  only ABS !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="第三十五章"><a href="#第三十五章" class="headerlink" title="第三十五章"></a>第三十五章</h1><p><strong>NOP，No Overdesign Priciple，不要过度设计原则</strong>。</p>
<p>这应该是你第一次看到这个原则，而且你也不用上网查了，因为这个不是大师们创造的，而是我创造的：）</p>
<p>之所以提出这个原则，是我自己吃过苦头，也在工作中见很多人吃过类似的苦头。</p>
<p>你可能也见过这样的场景：<br>产品提出了一个需求，设计师眼光非常长远，他甚至把5年后可能的业务变化都提出来并且加以设计了，让你不得不佩服设计师的高瞻远瞩的眼光，并且由衷的从心底赞叹：牛逼啊！</p>
<p>但很快你就会发现，设计师是很牛逼，但你开发的时候就很苦逼了，设计方案巨复杂，工作量巨大，即使你发扬一不怕苦二不怕累的精神，每天加班加点奋斗了三个月终于做出来了，但你苦逼完了，测试跟着苦逼了：很多东西测试都没办法测试！</p>
<p>怎么会出现这样的情况呢？我们做面向对象不就是为了应对变化、拥抱变化么？</p>
<p>要回答这个问题其实很简单，孔夫子在《论语》中已经为我们解答了：“子贡问：‘师与商也孰贤？’子曰：‘师也过，商也不及。’曰：‘然则师愈与？’子曰：‘过犹不及。’”</p>
<p>什么事情过头了就和没有达到是一样的效果，面向对象的设计也不例外。面向对象的初衷虽然是为了拥抱变化，但这个变化也是有一个度的，而不是预测得越长越好，原因很简单：预测越长，预测的结果正确性越低！谁能在2000年预测SUN公司的衰落？谁又能在2005年预测苹果的崛起？</p>
<p>除了预测时间越长准确性越差的问题外，过分设计会导致设计方案不必要的复杂、代码量庞大，投入产出不成正比，项目计划无法按时完成。。。。。。等等很多问题。</p>
<p>有时候过分设计比设计不足的影响和危害更大，因为如果设计不足，我们还有“重构”这个利器，也不会出现浪费大量人力物力的情况；<br>而如果过分设计，如果后面发现原来的设计不正确或者不合理，首先原有的投入浪费了，其次是即使重构，也需要花费更多的人力物力。</p>
<p>所以，在设计过程中要时刻谨记NOP原则，避免过度设计！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[连载：面向对象葵花宝典：思想、技巧与实践(21-27章)]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/05/13/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B83.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>无意间发现这篇文章，文章讲解由浅入深，读完后感触很深<br>特全文转到自己的博客，方便以后自己随时查看<br>文章转载自爱技术的华仔的博客[<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">http://blog.csdn.net/yunhua_lee</a>]<br>非常感谢<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">爱技术的华仔</a></p>
</blockquote>
<h1 id="第二十一章-SSD"><a href="#第二十一章-SSD" class="headerlink" title="第二十一章 SSD"></a>第二十一章 SSD</h1><p>用例图是用来描述系统的，而SSD（系统序列图）又是来描述用例的，oh my god，这不是在玩我们么？<img src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/crazy.gif" alt="抓狂"><a id="more"></a></p>
<p>System Sequence Diagram，缩写为SSD（注意不要与SSD硬盘混淆），中文翻译为“<strong>系统顺序图</strong>”，主要用于描述某个用例的某个分支场景下，外部参与者与系统的交互过程。简单来说：SSD就是用例的可视化描述。</p>
<p>细心的朋友可能会发现，前面我们在介绍“用例方法”的时候说不需要画图，这里又说SSD是用来描述用例的，这不是互相冲突了么？</p>
<p>事实上并不冲突，原因在于：用例方法分析需求的时候，确实不需要图；但用例方法分析完成后得到的用例，我们可以使用SSD让用例更直观一些。</p>
<p>SSD有几点需要特别注意：<br>1）SSD不是标准的UML图形：UML只有顺序图、用例图，但是没有一个专门的“系统顺序图”；之所以叫做“系统”顺序图，是因为这个顺序图中只有两类对象：系统、与系统交互的对象；<br>2）SSD是用来描述某个用例的某个分支，而不是描述系统的结构；<br>3）画SSD的时候，整个系统被当做一个黑盒，不涉及系统的分解；<br>4）不需要为每个用例每个分支都画一个SSD，挑出关键的用例和分支即可；</p>
<p>有的朋友可能会有疑问：如何知道哪些用例的哪些分支是关键的呢？</p>
<p>我的答案是：你认为是关键的你就画，你认为不是关键的你就不画；如果你认为所有的用例都很关键，那么所有的用例你都画即可，只要你不怕麻烦或者工作量太大；如果你认为所有的用例都很简单，那么一个都不画也可以。至于你的判断是否正确，主要靠经验积累，当经验不够的时候，也可以求助有经验的人。</p>
<p>以POS机为例，假如我们认为POS机的正常处理流程是关键分支，则对应的SSD如下：<br> <img src="http://ww4.sinaimg.cn/large/666cc9e3gw1f4972ruegnj20ek0sx761.jpg" alt=""><br>仔细对照SSD和POS机的用例，我们会发现SSD和用例基本上是对应的，但并不完全对应，例如：<br>Ø 用例中第1步是“顾客携带选择好的商品到收银台”，但SSD中第1步是开始交易；<br>Ø 用例中“顾客将钱交给收银员”，但SSD中并没有对应的步骤；<br>Ø 用例中最后一步是“买单完成，顾客携带商品和小票离开”，但SSD中最后一步是“交易结束”；</p>
<p>为什么会出现这种不对应的情况呢？<br>主要原因在于：用例是整个业务的流程，而SSD是站在系统的角度来描述系统与外部对象的交互，这就需要我们在画SSD的时候做一些技巧性的处理：<br>Ø 删除系统无关的业务步骤<br>例如上述的“顾客将钱交给收银员”，这个步骤和POS机没有关系，因此无需体现，再说了，就算你想体现，你也体现不了；<br>Ø 将业务语言转换为系统语言<br>例如用例中是描述“顾客携带选择好的商品到收银台”，但对应系统来说，这就意味了“交易开始”；同样，“买单完成，顾客携带商品和小票离开”意味着“交易结束”。</p>
<p>有的朋友可能会认为，应该在用例分析的时候就应该详细写清楚。例如，“买单完成，顾客携带商品和小票离开，收银员告诉POS机交易结束”。<br>这种想法本身没错，但问题在于，理想和现实总是有差距的，用例不可能那么完善，甚至有的时候用例可能都存在错误，如果我们自己没有一定的分析和理解能力，完全依赖原始的用例，这样做是不可能设计出优秀的系统的，甚至连合格的系统都可能做不到。</p>
<p>综合上面的分析，我们可以看到，SSD虽然来源于用例，但还需要在用例的基础上稍微加工一下，使得SSD能够更加聚焦于“系统”这个主角。</p>
<p>最后小小吐槽一下：<strong>用例图是用来描述系统的，而SSD又是来描述用例的，oh my god，这不是在玩我们么？</strong></p>
<h1 id="第二十二章-领域模型"><a href="#第二十二章-领域模型" class="headerlink" title="第二十二章 领域模型"></a>第二十二章 领域模型</h1><p>领域模型是面向对象分析和设计的第一步！！</p>
<p>完成了需求分析之后，我们已经有了一个良好的开端，但我们的主角“面向对象”还不见踪影。<br>前面我们提到，需求分析和面向对象是没有直接关系的，需求分析阶段是不区分是面向对象还是面向过程，那么什么时候才真正开始面向对象的工作呢？</p>
<p>答案就在本章：<strong>领域建模</strong>。<br>从领域模型开始，我们就开始了面向对象的分析和设计过程，可以说，领域模型是完成从需求分析到面向对象设计的一座桥梁。</p>
<p>领域模型，顾名思义，就是需求所涉及的领域的一个建模，更通俗的讲法是业务模型。<br>参考百度百科（<a href="http://baike.baidu.cn/view/757895.htm" target="_blank" rel="external">http://baike.baidu.cn/view/757895.htm</a> ），领域模型定义如下：</p>
<blockquote>
<p>领域模型是对领域内的概念类或现实世界中对象的可视化表示，又称概念模型、领域对象模型、分析对象模型。它专注于分析问题领域本身，发掘重要的业务领域概念，并建立业务领域概念之间的关系。</p>
</blockquote>
<p>从这个定义我们可以看出，领域模型有两个主要的作用：<br>1）发掘重要的业务领域概念<br>2）建立业务领域概念之间的关系</p>
<p>【领域建模三字经】<br>领域模型如此重要，很多同学可能会认为领域建模很复杂，需要很高的技巧。然而事实上领域建模非常简单，简单得有点难以让人相信，领域建模的方法概括一下就是“找名词”！</p>
<p>许多同学看到这个方法后估计都会笑出来：太假了吧，这么简单，找个初中生都会啊，那我们公司那些分析师和设计师还有什么用哦？</p>
<p>分析师和设计师当然有用，后面我们会看到，即使是简单的找名词这样的操作，也涉及到分析和提炼，而不是简单的摘取出来就可，这种情况下分析师和设计师的经验和技能就能够派上用场了。但领域模型分析也确实相对简单，即使没有丰富的经验和高超的技巧，至少也能完成一个能用的领域模型。</p>
<p>虽然我们说“找名词”很简单，但一个关键的问题还没有说明：从哪里找？<br>如果你还记得领域模型是“需求到面向对象的桥梁”，那么你肯定一下子就能想到：从需求模型中找，具体来说就是从用例中找。</p>
<p>归纳一下域建模的方法就是“从用例中找名词”。<br>当然，找到名词后，为了能够更加符合面向对象的要求和特点，我们还需要对这些名词进一步完善，这就是接下来的步骤：加属性，连关系！</p>
<p>最后我们总结出领域建模的三字经方法：<strong>找名词、加属性、连关系</strong>。</p>
<p>欲知具体如何操作，请看下回分解</p>
<h1 id="第二十三章"><a href="#第二十三章" class="headerlink" title="第二十三章"></a>第二十三章</h1><p>看起来有点不可思议，需求阶段“白纸黑字”的用例文档，经过我们一步一步的操作，逐步就得到了“图形化”的领域模型，面向对象初具雏形。</p>
<p>领域建模的三字经方法：<strong>找名词、加属性、连关系</strong>。</p>
<p>我们接下来以一个样例看看领域模型具体如何建模。</p>
<h2 id="1-1-找名词"><a href="#1-1-找名词" class="headerlink" title="1.1 找名词"></a>1.1 找名词</h2><p>我们以POS机买单的用例来看看具体如何建领域模型。</p>
<p>首先，将用例中所有的名词挑选出来（如下用例文档中<strong>蓝色加粗</strong>的词组）：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">【用例名称】</span><br><span class="line">买单</span><br><span class="line">【场景】</span><br><span class="line">Who：*<span class="strong">*顾客、收银员*</span>*</span><br><span class="line">Where：商店的*<span class="strong">*收银台*</span>*</span><br><span class="line">When：营业时间</span><br><span class="line">【用例描述】</span><br><span class="line">1. *<span class="strong">*顾客*</span><span class="strong">*携带选择好的*</span><span class="strong">*商品*</span><span class="strong">*到收银台；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">2. 收银员逐一扫描商品*</span><span class="strong">*条形码*</span><span class="strong">*，系统根据条形码查询商品信息；</span><br><span class="line">2.1 *</span><span class="strong">*扫描仪*</span><span class="strong">*坏了，必须支持手工输入条形码；</span><br><span class="line">2.2 商品的*</span><span class="strong">*条形码*</span><span class="strong">*无法扫描，必须支持手工输入条形码；</span><br><span class="line">2.3 条形码能够扫描，但查询不到信息，需要收银员和顾客沟通，放弃购买此产品</span><br><span class="line">3. 扫描完毕，系统显示商品总额，收银员告诉顾客商品总额；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">4. 顾客将*</span><span class="strong">*钱*</span><span class="strong">*交给收银员；</span><br><span class="line">4.1 顾客的钱不够，顾客和收银员沟通，删除某商品；</span><br><span class="line">4.2 顾客的钱不够，顾客和收银员沟通，删除某类商品中的一个或几个（例如买了*</span><span class="strong">*5包烟*</span><span class="strong">*，去掉两包）</span><br><span class="line">4.3 顾客觉得某个商品价格太高，要求删除某商品；</span><br><span class="line">4-A：顾客使用*</span><span class="strong">*信用卡*</span><span class="strong">*支付</span><br><span class="line">4-A.1 信用卡支付流程（请读者自行思考完善，可以写在这里，如果太多，也可以另外写一个子用例）</span><br><span class="line">4-B：顾客使用*</span><span class="strong">*购物卡*</span><span class="strong">*支付</span><br><span class="line">        4-B.1 购物卡支付流程</span><br><span class="line">4-C：顾客使用*</span><span class="strong">*会员卡*</span><span class="strong">*积分支付</span><br><span class="line">        4-C.1 会员卡积分支付流程</span><br><span class="line">5. 收银员清点钱数，输入收到的款额，系统给出找零的数目；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">6. 收银员将找零的钱还给顾客，并打印*</span><span class="strong">*小票*</span><span class="strong">*；</span><br><span class="line">7. *</span><span class="strong">*买单*</span><span class="strong">*完成，顾客携带*</span><span class="strong">*商品*</span><span class="strong">*和*</span><span class="strong">*小票*</span><span class="strong">*离开；</span><br><span class="line">【用例价值】</span><br><span class="line">顾客买完单以后，就可以携带商品离开，而超市也将得到收入；</span><br><span class="line">【约束和限制】</span><br><span class="line">1. POS机必须符合国标XXX；</span><br><span class="line">2. 键盘和屏幕使用*</span><span class="strong">*中文*</span><span class="strong">*，因为收银员都是*</span><span class="strong">*中国人*</span><span class="strong">*；</span><br><span class="line">3. 一次买单数额不能超过99999RMB；</span><br><span class="line">4. POS机要非常稳定，至少一天内不要出现故障；</span></span><br></pre></td></tr></table></figure></p>
<p>名词列表：<br>顾客、收银员、收银台、商品、条形码、扫描仪、钱、5包烟、信用卡、会员卡、小票、买单、键盘、屏幕、中文、中国人</p>
<p>通过这种简单的方法，我们很轻松的就识别出了领域中的各种概念，但是还不能高兴的太早，识别领域概念的工作还没有结束，接下来我们还需要提炼。</p>
<p>有了前面步骤识别的名词列表后，提炼的工作就相对很简单了，只需要删除不是领域对象的名词即可。<br>但具体应该删除什么名词，是和不同的业务领域强相关的，并没有完全统一的标准，此时分析师的行业和领域经验起决定作用，而这也正是菜鸟和专家的区别。</p>
<p>以我们的收银机为例，提炼的过程如下：<br>1）删除“收银台”：收银台只是一个物理设备，且这个设备与我们的POS机也没有任何交互，所以不能算作领域模型中的一个概念；<br>2）删除“5包烟”：5包烟只是用例中举例时的一个实例，是一个具体的商品，已经包含在“商品”中了；<br>3）删除“中文”：“中文”只是“键盘”和“屏幕”的一个属性，并不是一个独立的领域概念；<br>4）删除“中国人”：“中国人”只是“收银员”的一个属性，并不是一个独立的领域概念；<br>5）删除“条形码”：“条形码”只是“商品”的一个属性，并不是一个独立的领域概念；</p>
<p>经过上面的提炼步骤后，就得到了真正的POS机领域类，详细如下：<br><strong>顾客、收银员、商品、扫描仪、钱、信用卡、会员卡、小票、买单、键盘、屏幕</strong></p>
<h2 id="1-2-加属性"><a href="#1-2-加属性" class="headerlink" title="1.2. 加属性"></a>1.2. 加属性</h2><p>找出领域模型的名词后，接下来一个重要工作就是将这些名词相关的属性找出来，使其更加准确。</p>
<p>但加属性和前面找名词有一点点差别：有的属性并没有在用例中明确给出，需要分析人员和设计人员额外添加，此时也是分析师的行业和领域经验起决定作用。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名词</th>
<th style="text-align:center">属性</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">顾客</td>
<td style="text-align:center">NA</td>
<td style="text-align:center">对于POS机来说，并不需要识别顾客的相关信息，因此在领域模型中，顾客是没有属性的</td>
</tr>
<tr>
<td style="text-align:center">收银员</td>
<td style="text-align:center">国籍、编号</td>
<td style="text-align:center">“国籍”由找名词步骤中的“中国人”提炼</td>
</tr>
<tr>
<td style="text-align:center">商品</td>
<td style="text-align:center">条形码、名称、价格</td>
<td style="text-align:center">名称和价格并没有在用例中体现，但毫无疑问这是商品最基本的属性</td>
</tr>
<tr>
<td style="text-align:center">扫描仪</td>
<td style="text-align:center">NA</td>
<td style="text-align:center">扫描仪是POS机的一个输入设备，POS机不需要识别扫描仪的相关信息，因此在领域模型中，扫描仪也是没有属性的</td>
</tr>
<tr>
<td style="text-align:center">钱（现金）</td>
<td style="text-align:center">数量，币别</td>
<td style="text-align:center">从领域分析的角度来讲，“现金”更专业一些</td>
</tr>
<tr>
<td style="text-align:center">信用卡</td>
<td style="text-align:center">卡号</td>
<td style="text-align:center">NA</td>
</tr>
<tr>
<td style="text-align:center">会员卡</td>
<td style="text-align:center">会员号、积分、有效期</td>
<td style="text-align:center">NA</td>
</tr>
<tr>
<td style="text-align:center">小票</td>
<td style="text-align:center">交易信息、POS机信息、收银员信息</td>
<td style="text-align:center">小票的属性在用例中并没有详细体现，但有经验的分析师能够很容易识别出来</td>
</tr>
<tr>
<td style="text-align:center">买单（交易）</td>
<td style="text-align:center">商品列表、日期时间、总额、支付信息</td>
<td style="text-align:center">这里的属性看起来和“小票”一样，是因为“小票”本质上是给客户的一个交易记录。这里为了更加符合软件系统的属于习惯，可以将“买单“改为“交易”。</td>
</tr>
<tr>
<td style="text-align:center">键盘</td>
<td style="text-align:center">NA</td>
<td style="text-align:center">和扫描仪类似，POS机不需要识别键盘信息</td>
</tr>
<tr>
<td style="text-align:center">屏幕</td>
<td style="text-align:center">NA</td>
<td style="text-align:center">和扫描仪类似，POS机不需要识别屏幕信息</td>
</tr>
</tbody>
</table>
<h2 id="1-3-连关系"><a href="#1-3-连关系" class="headerlink" title="1.3. 连关系"></a>1.3. 连关系</h2><p>有了类，也有了属性，接下来自然就是找出它们的关系了。</p>
<p>有了前面的工作，看起来连关系自然也是睡到渠成的事情，但不要忘了我们的这个例子是非常简单的，在一些复杂的系统中，领域模型之间的关系并不那么明显，菜鸟可能就只能看到最显而易见的一些联系，而系统分析师和设计师可以凭着丰富的经验、良好的技巧识别出来，这也是系统分析师和设计师的价值所在。</p>
<p>POS机的领域类关系如下（仅供参考，并不要求每个分析师和设计师都一定是这么理解，但总体来说应该相似）：<br>  <img src="http://ww3.sinaimg.cn/large/666cc9e3gw1f4973bk17xj20wp0g90w8.jpg" alt=""></p>
<p>看起来有点不可思议，需求阶段白纸黑字的用例文档，经过我们一步一步的操作，最后得到了图形化的领域模型。<br>只要曾经画过甚至只是看过UML类图的同学都应该很容易发现，领域模型和设计类图非常相似，面向对象终于有了雏形了</p>
<h1 id="第二十四章"><a href="#第二十四章" class="headerlink" title="第二十四章"></a>第二十四章</h1><p>完成领域类到软件类的转换，这就是面向对象领域设计阶段的主要任务。</p>
<p>经过领域模型的分析后，面向对象已经初具雏形，但领域类并不能指导我们进行编码工作，因为领域类只是从用例模型中提炼出来的反应业务领域的概念，而并不是真正意义上的软件类。</p>
<p>“革命尚未成功，同志还需努力”，我们需要再进一步，完成<strong>领域类到软件类的转换</strong>，这就是面向对象领域设计阶段的主要任务。</p>
<p>设计阶段是整个面向对象分析和设计的高潮阶段。在设计阶段中，我们将要输出设计模型，并且需要综合各种方法、技巧，运用十八般武艺，使出浑身解数，以求能够设计出满足各种需要的设计方案。</p>
<p>这也是最考验设计师功力的时候，因为设计并没有一个量化的标准，也没有一个标准答案，更多的时候需要设计师综合知识、技能、经验、灵感等因素，综合权衡而得出一个方案。世界上找不到两片相同的叶子，同样，你也找不到两个完全一样的设计方案。毫不夸张的说，面向对象的设计更多时候是一项艺术。</p>
<p>虽然我们说面向对象设计是一门艺术，但这并不意味着只有天才才能进行面向对象设计，面向对象设计也是有一定的规律和方法可寻的，我们将在接下来的章节逐一介绍。</p>
<p>【设计模型总览】<br>设计模型主要包含2部分内容：<strong>静态模型、动态模型</strong>，任何一个模型的缺失或者不完善，都将导致最终的设计质量不高，甚至可能导致最终的系统没有实现业务需求。</p>
<p>静态模型又可以称为“类模型”，主要关注系统的“静态”结构，描述了系统包含的类， 以及类的名称、职责、属性、方法，类与类之间的关系。<br>动态模型关注系统的“动态”行为，描述类本身的一些动作或者状态变化，以及类之间如何配合以完成最终的业务功能。只有结合静态模型和动态模型，我们才能够真正的将一个系统描述清楚。</p>
<p>静态模型和动态模型对于后续的编码也具有不同的指导意义。静态模型主要用于指导类的声明，包括类名称，属性名，方法名；而动态模型主要用于指导类的实现，主要就是每个方法内部的具体实现。</p>
<h1 id="第二十五章"><a href="#第二十五章" class="headerlink" title="第二十五章"></a>第二十五章</h1><p>面向对象设计和弹吉他差不多，有很多成熟的理论和技巧，学会弹吉他并不难，你只需要应用这些理论和技巧即可！</p>
<p><strong>【师傅领进门，修行在个人】</strong><br>“类模型”是整个面向对象设计模型的核心，是面向对象设计阶段的主要输出，也是设计师们最能够发挥自己才能的地方。</p>
<p>虽然“类模型”如此重要，但面向对象设计技术经过几十年的发展后，目前已经形成了很成熟的一套体系，因此真正在进行“类模型”设计的时候，其实难度并不高，这也是多亏了众多前辈们的无私贡献，才能使得我们这些芸芸众生也能轻松掌握这些原本带有艺术色彩的技能。</p>
<p>不过话又说回来了，入门容易精通难，“类模型”的设计也是如此，虽然有前辈们各种各样的思想结晶指导着我们，但毕竟如何理解、如何应用这些思想结晶，还是要看个人的领悟力和把握力。就像同样的《葵花宝典》，岳不群看了创立了气宗，蔡子峰看了创立了剑宗，渡元禅师听了后悟出了辟邪剑法，东方不败看了竟然练出了绣花针绝技！所以接下来的内容，也只是“师父领进门，修行在个人”，如果希望做出优秀的设计，更多还是依靠个人的领悟和实践！</p>
<p><strong>【设计的魔法崇拜】</strong><br>面向对象类的设计很多时候都蒙上了一层神秘的面纱。一个常见的场景是：“设计师”拿到需求后，经过一段时间的设计，感觉就像变戏法一样，然后就拿出了一个类模型。普通的开发人员看到这样的类模型，很难想象如何从需求才能够得到了这些类，由于大部分公司的设计人员确实也都是公司里面的牛人，因此大家就自然而然地认为这是水平和创造力的表现，心底不由得产生由衷的赞叹：“牛逼啊！”</p>
<p>我称这种现象为设计的“魔法崇拜”，具体表现就是认为设计是一种魔法，做设计的人是魔法师，只有牛逼的人才能够做设计。</p>
<p>但这种认识并不准确，就像我们前面提到的，面向对象领域已经发展了几十年，各种思想、理论都已经基本成熟，绝大部分人在做设计的时候，都不可能有什么天才的创新或者天才的灵感，而只是这些已经成熟的思想和理论的应用而已。</p>
<p>之所以现在还会出现这种现象，主要原因还是在于各种思想、理论、方法都是针对具体问题的分析或者总结，但并没有谁明确的将这些东东形成一套完整的面向对象设计体系。</p>
<p>可能很多人都有这种感觉：面向对象我也懂，设计模式我也知道，设计原则我也明白，但真的要进行设计的时候，就不知道如何下手了，比如说：<br>对象从哪里来？<br>什么时候用设计模式？<br>如何判断设计是否正确？<br>什么样的设计才是优秀的设计？<br>。。。。。。。。。。。</p>
<p>正因为存在这样的原因，我们自然会对那些能够设计出完整的类模型的设计师们刮目相看了。</p>
<p>其实面向对象设计并不是什么高深的技术，也不需要天才的创新，更不需要变魔法，而是有章可循的，只要我们按照一定的步骤，一步一个脚印，不断精益求精，就能够完成面向对象的设计。</p>
<p>但正如前面提到的一样，面向对象设计更多的时候是一门艺术。虽然我们按照一定的步骤能够完成面向对象的设计，但在这些步骤实施的过程中，如何应用相关技术，如何做出设计选择等，更多时候是带有艺术色彩的。就像很多人都会弹吉他，但真正的吉他大师弹出来的感觉，肯定和一个普通人弹的不一样。</p>
<p>接下来我们将会分几个小节讲述如何进行面向对象的类设计：</p>
<p>第一步（照猫画虎）：领域类映射 — 告诉你类从哪里来<br>第二步（精雕细琢）：应用设计原则和设计模式   —告诉你如何设计“好”类<br>第三步（照本宣科）：拆分辅助类   —告诉你如何和你的开发框架结合起来</p>
<h1 id="第二十六章"><a href="#第二十六章" class="headerlink" title="第二十六章"></a>第二十六章</h1><p><strong>类模型设计其实就是程咬金打天下 – 三板斧 而已 ：）</strong></p>
<hr>
<h2 id="第一斧（照猫画虎）：领域类映射"><a href="#第一斧（照猫画虎）：领域类映射" class="headerlink" title="第一斧（照猫画虎）：领域类映射"></a><strong>第一斧（照猫画虎）：领域类映射</strong></h2><p>面向对象类设计首先要解决的一个问题是：类从哪里来 ？</p>
<p>有的人可能会认为，要发挥想象力、创造力。。。。。等各种“力”——这种方法的主要问题是：我们不是在进行纯粹的艺术创造，而是要最终满足客户需求，而不能天马行空。</p>
<p>有的人可能会想到，参考其它的系统吧，把类似系统拿过来改吧改吧 ——这种方法的主要问题是：如果没有其它类似系统给你参考呢 ？还有的人干脆就说：拍脑袋吧，凭感觉吧 —— 这种方法的主要问题是：猴子能敲出莎士比亚全集么 ？看起来以上方法都不太可行，那究竟如何才能从哪里找到我们需要的类呢？</p>
<p>相信绝大部分认真看书的同学都会灵光一闪：领域模型。我们将上一章中的领域模型图拿出来，重新再看一下：<img src="http://ww2.sinaimg.cn/large/666cc9e3gw1f4973z2vcdj20wp0g90w8.jpg" alt="">相信不用我多说，绝大部分同学一眼就能看出：哇塞，这不就是类么？</p>
<p>确实是这样的，<strong>领域模型中的“领域类”，是设计模型中“软件类”最好的来源</strong>。通过“领域类”来启发我们设计最初的“软件类”，具有如下几个明显的<strong>优点</strong>：1）软件类来自领域类，领域类来自用例，用例来自客户，这样一环扣一环，软件类的正确性得到了保证，不用担心拍脑袋带来的问题；2）领域类到软件类的转换非常简单，不需要天才的创新，或者丰富的想象力，只要掌握基本的面向对象的知识就能完成，菜鸟也能做设计；3）不需要参考其它系统，不用担心没有参照物时无法设计的问题；从领域类到软件类的转换操作非常简单，基本上就是一个照猫画虎的过程。</p>
<p><strong>【类筛选】</strong>虽然我们说从领域类到软件类是一个照猫画虎的过程，但并不意味着将领域类全盘拷贝过来即可。主要的原因在于“软件类”是软件系统内部的一个概念，而领域类是业务领域的概念，并不是每个领域类最终都会体现在软件系统中。以POS机的领域类为例，领域类“顾客”不需要转换为软件类，因为顾客是POS机业务领域的一个重要参与者，但并不是POS机内部需要实现的一个实体，在POS机业务中，顾客甚至都不是和POS机直接交互的实体，站在POS软件系统的角度来说，顾客和POS机其实没有任何关系。对于屏幕、键盘、扫描仪这些输入输出设备，一般情况下我们认为它们是POS机系统硬件的一部分，而并不是POS机软件系统的一部分。但假如POS机有一个需求是既支持图形界面输出，又支持字符界面输出，那么POS的软件系统就需要处理这种和屏幕相关的需求了，此时屏幕就是POS机软件系统的一部分了，需要将领域类转换为软件类。为了简单处理，接下来的分析中，输入输出设备不做转换。经过筛选后，剩下的领域类就需要都转换为软件类，具体如下：收银员、商品、交易、小票、支付、信用卡、会员卡、现金、购物卡。</p>
<p><strong>【名称映射】</strong>筛选完成后，我们开始讲领域类转换为软件类，转换的方法很简单，首先不管三七二十一，将每个领域类都用一个软件类与对应，名称都保持一样即可。有的同学可能担心这样设计是否会不符合面向对象设计的要求，是否会导致设计质量不高。。。。。。等等，其实这种担心是多余的，因为我们后续还有很多工作要做，目前做的只是一个开始工作。</p>
<p><strong>【属性映射】</strong>通过名称映射的方法得到软件类后，接下来就是要设计类的属性了。由于领域类中也已经有了属性，因此我们也只需简单的照搬过来即可。</p>
<p><strong>【提炼方法】</strong>软件类的属性设计完成后，接下来就需要设计软件类的方法了。但这次我们就没有那么好的运气了，因为领域类中并没有方法！因此我们不能通过简单映射的方法来获取方法，必须采取其它手段。和类的设计一样，类方法的设计同样不能采取“创造力、参考其它系统、拍脑袋”等方式来完成，为了确保正确性，类的方法设计也同样应该能够从已有的模型中推导出来。由于已经明确领域模型中没有方法了，因此就不能从领域模型中得到软件类的方法，剩余只有一个“用例模型”了，因此我们锁定“用例模型”，看看如何从中找到我们所需要的方法。其实方法也很简单，概括一下就是：<strong>找动词</strong>。你可能不敢相信自己的眼睛，这么简单，那几乎初中生都会做设计啊，找动词谁不会呢？然而不管你信不信，这一步确实是这么简单，当然，如果面向对象设计只是到此为止，那确实初中生也是可以做的，但实际上这只是面向对象类设计的开始步骤而已，后面的工作还多着了，所以完全不用担心初中生来抢你的饭碗。我们以POS机为例，来看看如何通过“找动词”这种技巧来找到软件类的方法。如下是POS机的用例，我们将相关动词都<strong>加粗</strong>显示：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">【用例名称】</span><br><span class="line">买单</span><br><span class="line">【场景】</span><br><span class="line">Who：顾客、收银员</span><br><span class="line">Where：商店的收银台</span><br><span class="line">When：营业时间</span><br><span class="line">【用例描述】</span><br><span class="line">1. 顾客*<span class="strong">*携带*</span><span class="strong">*选择好的商品到收银台；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">2. 收银员逐一*</span><span class="strong">*扫描*</span><span class="strong">*商品条形码，系统根据条形码*</span><span class="strong">*查询*</span><span class="strong">*商品信息；</span><br><span class="line">2.1 扫描仪坏了，必须支持*</span><span class="strong">*手工输入*</span><span class="strong">*条形码；</span><br><span class="line">2.2 商品的条形码无法扫描，必须支持*</span><span class="strong">*手工输入*</span><span class="strong">*条形码；</span><br><span class="line">2.3 条形码能够扫描，但查询不到信息，需要收银员和顾客*</span><span class="strong">*沟通*</span><span class="strong">*，放弃购买此产品</span><br><span class="line">3. 扫描完毕，系统*</span><span class="strong">*显示*</span><span class="strong">*商品总额，收银员*</span><span class="strong">*告诉*</span><span class="strong">*顾客商品总额；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">4. 顾客将钱*</span><span class="strong">*交给*</span><span class="strong">*收银员；</span><br><span class="line">4.1 顾客的钱不够，顾客和收银员沟通，*</span><span class="strong">*删除*</span><span class="strong">*某商品；</span><br><span class="line">4.2 顾客的钱不够，顾客和收银员沟通，*</span><span class="strong">*删除*</span><span class="strong">*某类商品中的一个或几个（例如买了5包烟，去掉两包）</span><br><span class="line">4.3 顾客觉得某个商品价格太高，要求*</span><span class="strong">*删除*</span><span class="strong">*某商品；</span><br><span class="line">4-A：顾客使用信用卡*</span><span class="strong">*支付*</span>*</span><br><span class="line">4-A.1 信用卡支付流程（请读者自行思考完善，可以写在这里，如果太多，也可以另外写一个子用例）</span><br><span class="line">4-B：顾客使用购物卡*<span class="strong">*支付*</span>*</span><br><span class="line">        4-B.1 购物卡支付流程</span><br><span class="line">4-C：顾客使用会员卡积分*<span class="strong">*支付*</span>*</span><br><span class="line">        4-C.1 会员卡积分支付流程</span><br><span class="line">5. 收银员*<span class="strong">*清点*</span><span class="strong">*钱数，*</span><span class="strong">*输入*</span><span class="strong">*收到的款额，系统*</span><span class="strong">*给出找零*</span><span class="strong">*的数目；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">6. 收银员将找零的钱还给顾客，并*</span><span class="strong">*打印*</span><span class="strong">*小票；</span><br><span class="line">7. 买单完成，顾客*</span><span class="strong">*携带*</span><span class="strong">*商品和小票*</span><span class="strong">*离开*</span><span class="strong">*；</span><br><span class="line">【用例价值】</span><br><span class="line">顾客买完单以后，就可以携带商品离开，而超市也将得到收入；</span><br><span class="line">【约束和限制】</span><br><span class="line">1. POS机必须符合国标XXX；</span><br><span class="line">2. 键盘使用中文，因为收银员都是中国人；</span><br><span class="line">3. 一次买单数额不能超过99999RMB；</span><br><span class="line">4. POS机要非常稳定，至少一天内不要出现故障；</span></span><br></pre></td></tr></table></figure></p>
<p>标识出所有的动词后，还需要进一步的工作：<br>【筛选】并不是所有的动词都一定是软件类的方法，我们需要将这些动词识别出来并排除在后续设计范围之外。<br>例如：“顾客携带选择好的商品到收银台”：这里的“携带”是顾客的一个动作，而顾客并不是我们的软件类；“收银员告诉顾客商品总额”：这里的“告诉”确实是收银员的一个动作，而且“收银员”确实也是我们的软件类，但这里也要排除“告诉”，因为“告诉”这个动作和POS系统并没有关系，只是业务流程中的一个步骤而已。其它需要排除的动词还有：“需要收银员和顾客沟通”、“顾客将钱交给收银员”、“收银员清点钱数”、“收银员将找零的钱还给顾客”、“顾客携带商品和小票离开”<br>【提炼】筛选完不需要的动词后，剩下的就是我们需要的动词了，但此时并不能简单的将所有动词拿出来直接扔给某个软件类就行了，我们还需要进行一些加工。</p>
<p>继续以POS机为例：“收银员逐一扫描商品条形码”：这里的“扫描”看起来是“收银员”的一个动作，而且“收银员”确实也是我们的软件类，但其实深究一下，“扫描”这个动词并不能分配给“收银员”这个软件类，因为真正执行“扫描”功能的是“扫描仪”，收银员只是拿着扫描仪扫描商品，并不是收银员自己去读取商品条形码；类似的动词还有“必须支持手工输入条形码”，也不能算作“收银员”的功能。</p>
<p>那我们为什么不排除这两个动词呢？秘密就在于我们要从这两个动词提炼出软件类的方法。稍作分析，我们就可以发现，无论是“扫描条形码”，还是“手工输入条形码”，其实最终的目的都是“添加本次交易的商品”，因此我们可以提炼出“增加交易商品”的动词。</p>
<p>还有一种提炼的方法需要从已有的动词中推断出来，例如：“扫描完毕，系统显示商品总额”，这里只提到了“显示”这个动词，但相信大部分人都能一眼看出，“显示”之前肯定要“计算”，不然显示出来的值从哪里来呢？</p>
<p>有的朋友可能会疑惑，为什么不在用例的时候就写清楚呢？例如：扫描完毕，系统计算商品总额，然后系统显示商品总额。这样不就一目了然的看出来了么？</p>
<p>理想情况下这种想法当然没错，但现实往往没有那么美好，写用例的产品人员可能经验不足，也可能表达能力有限，还有可能比较马虎，或者遗漏了。。。。。。总之会有很多异常情况，因此设计人员必须具备这样的推断和判断能力。</p>
<p>经过这一步骤后，我们获得的动词如下：</p>
<ul>
<li>增加商品</li>
<li>计算商品总额</li>
<li>显示商品总额</li>
<li>删除商品</li>
<li>现金支付</li>
<li>信用卡支付</li>
<li>购物卡支付</li>
<li>会员卡积分支付</li>
<li>打印小票<br>当然，以上列出来的动词并不是就一定是100%的标准答案，不同的人来进行分析和设计，可能略有不同，但总体应该比较相似，毕竟业务是一样的，而业务需求就是设计最强的约束。<br>【分配】<br>识别出有效的动词后，最有一步就是分配了，即：将从用例中提炼出来的动词，分配给已经有了属性的软件类。这种分配操作很多时候都是按图索骥，特别是对于有领域经验的人来说，基本上凭直觉就能基本分配正确。当然，如果你的经验并不是很丰富，那么还是老老实实的一个一个来分析吧。<br>以POS机为例：</li>
<li>增加商品：很明显应该分配给“交易”类</li>
<li>计算商品总额：分配给“交易”类</li>
<li>显示商品总额：分配给“交易”类</li>
<li>删除商品：分配给“交易”类</li>
<li>现金支付：分配给“现金”类</li>
<li>信用卡支付：分配给“信用卡”类</li>
<li>购物卡支付：分配给“购物卡”类</li>
<li>会员卡积分支付：分配给“会员卡”类</li>
<li>打印小票：这个动词的分配存在一定的灵活性，有的人可能认为应该分配给“交易”类，因为打印小票可以认为是“交易”流程中的一个步骤；有的人可能认为应该分配给“小票”类，因为打印小票可以认为是“小票”类的一个基本功能。其实两者都有一定道理，如果没有其它更有力的选择因素，我建议根据个人经验选择一个即可，这里我们选择分配给“小票”。分配完成后，我们可以看到“交易”、“小票”、“信用卡”、“购物卡”、“会员卡”、“现金”都已经有方法了。</li>
</ul>
<p>当然，对于有经验的人来说，以上步骤完全可以在脑海中就迅速完成了，而并不会这样一步一步的演示给别人看，所以看起来就像变戏法一样，不知怎么就设计出来了很多的软件类。</p>
<p>经过上面的处理步骤后，我们得到如下的类图：<img src="http://ww2.sinaimg.cn/large/666cc9e3gw1f4974v4brbj20ls0fkjux.jpg" alt=""><br>与领域模型相比，部分领域类被剔除了，留下来的领域类映射成软件类后，又增加了方法。虽然还不完善，但软件类的是越来越有型，越来越清晰了。</p>
<h2 id="第二斧（精雕细琢）：应用设计原则和设计模式"><a href="#第二斧（精雕细琢）：应用设计原则和设计模式" class="headerlink" title="第二斧（精雕细琢）：应用设计原则和设计模式"></a><strong>第二斧（精雕细琢）：应用设计原则和设计模式</strong></h2><p>完成了从领域类到软件类的映射后，类出来了，属性也出来了，方法也有了，看起来设计已经大功告成了。事实上也确实有很多人基本上做到这一步就开始动手编码了，而且经过一番拼搏，最后发布的系统也能用。</p>
<p>但相信很多人都会有这个疑问：这样做就够了么，这样设计是否是好的设计呢？要回答这个问题，我们首先要明确：什么叫做“好”的设计呢 ？</p>
<p>到目前为止，我们已经有了一个类的设计模型，而且如果按照这个模型去实现的话，最终应该也是能够满足用户的需求，毕竟我们这个类模型是按照“需求模型 -&gt; 领域模型 -&gt; 类模型”这样一路推导过来的，不会出现大的偏差。</p>
<p>那么，满足了用户需求的设计就是好的设计么？相信有经验的朋友都会知道答案：“满足用户需求”只是设计的一个最基本要求，而不是一个“好设计”的评判标准。</p>
<p>既然如此，那么到底什么才是好的设计呢，是否有明确的标准来进行评价呢？幸运的是，面向对象领域经过几十年的发展，确实已经发展出了很多成熟的指导思想和方法，用于评价和指导如何才能做好面向对象的设计。其中最具代表性的就是<strong>“设计原则”和“设计模式”</strong>。</p>
<p><strong>【设计原则】</strong></p>
<p>当我们谈到面向对象领域的设计原则的时候，我们其实都是在谈论罗伯特.C.马丁（Robert C. Martin ，又叫Bob大叔）的SOLID原则。这也难怪，Bod大叔实在是太牛了，面向对象领域的设计原则几乎被他全部包揽了，加上他在他的畅销书《敏捷软件开发：原则、模式与实践》中详细的将这些原则集中一 一阐述，面向对象领域设计原则的权威非他莫属。毫不夸张的说，Bob大叔的威名和在面向对象领域中的地位，和设计模式的“四人帮”是不相上下的。虽然很多资料都将SOLID原则和敏捷开发、测试驱动开发等方法绑定在一起，但我觉得只要是面向对象设计，不管是瀑布流程、、CMM流程、RUP流程、还是敏捷开发流程，都应该应用设计原则以提高设计质量。参考wiki百科，SOLID设计原则简单介绍如下：SOLID实际上是取5个设计原则的首字母拼起来的一个助记单词。具体的设计原则如下（详细的设计原则，我们会在后面详细阐述，这里不再详细展开）：</p>
<table>
<thead>
<tr>
<th>首字母</th>
<th>英文简写</th>
<th>英文名称</th>
<th>中文名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>SRP</td>
<td>Single Responsibility Principle</td>
<td>单一职责原则</td>
<td>对象应该只具备单一职责</td>
</tr>
<tr>
<td>O</td>
<td>OCP</td>
<td>Open/Close Principle</td>
<td>开放/封闭原则</td>
<td>认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。</td>
</tr>
<tr>
<td>L</td>
<td>LSP</td>
<td>Liskov Substitution Principle</td>
<td>Liskov替换原则</td>
<td>认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念</td>
</tr>
<tr>
<td>I</td>
<td>ISP</td>
<td>Interface Segregation Principle</td>
<td><a href="http://zh.wikipedia.org/w/index.php?title=%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99&amp;action=edit&amp;redlink=1" target="_blank" rel="external">接口隔离原则</a></td>
<td>多个特定客户端接口要好于一个宽泛用途的接口</td>
</tr>
<tr>
<td>D</td>
<td>DIP</td>
<td>Dependency Inversion Principle</td>
<td><a href="http://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99" target="_blank" rel="external">依赖反转原则</a></td>
<td>依赖于抽象而不是一个实例</td>
</tr>
</tbody>
</table>
<p>[wik链接]（<a href="http://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1）" target="_blank" rel="external">http://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1）</a></p>
<p>前面我们简单的八卦了一下，现在回归正题：设计原则有什么用？其实和所有的原则一样，设计原则也是一个判断标准，说通俗点，设计原则就像是木匠手中的尺子，尺子是用来衡量木材的长短的，而设计原则就是衡量类设计的“尺子”：量一量，看长了还是短了，还是正好，长了就裁短一些，短了就加长一些。经过如此衡量并调整，最终就能够得到我们希望的设计作品。当然，和木匠的尺子稍有不同，木匠不用尺子就做不出能用的家具，但我们不用设计原则的话，其实还是能够做出满足需求的系统的。<br>既然这样，我们为什么一定要用设计原则呢？ARTHUR J.RIEL在《OOD启思录》一书中针对这个问题给出了非常形象的解释：你不必严格遵守这些原则，违背它也不会被处以宗教刑罚。但你应当把这些原则看做警铃，若违背了其中的一条，那么警铃就会响起。”——-ARTHUR J.RIEL,《OOD启思录》<br>也就是说，如果违背了这些设计原则，就可能有危险，但究竟是什么危险呢，警铃要警告我们什么呢，是火灾、水灾、地震、陷阱、还是有狮子、老虎。。。。。？</p>
<p>要回答这个问题，还需要回到面向对象的本源：我们在第一章解释为什么要面向对象的时候提到了面向对象的核心思想是“可扩展性”，这其实就是我们应用设计原则的根本目的：保证可扩展性。如果我们不遵守这些设计原则，警铃就会响起，提醒我们：你的设计可扩展性会有问题！除了设计原则外，后面要讲到的设计模式，其本质也是为了提高可扩展性。这也是为什么我们通过领域类映射得到了很多软件类之后，还需要不辞辛劳的继续应用设计原则和设计模式的主要原因，本质上都是为了提高设计的可扩展性。</p>
<p>SOLID设计原则的各个子原则详细介绍会在后面详细介绍，这里我们简单的以POS机为例，看看如何应用设计原则。</p>
<p>仔细观察我们通过领域类映射得到的软件类，可以发现一个很明显不符合SOLID原则中的DIP原则的地方，即：“交易类”直接依赖“会员卡”、“购物卡”、“信用卡”、“现金”4个子类，这样的实现不符合DIP原则，当需要增加新的支付方式时，“交易类”也需要跟着修改。</p>
<p>既然不满足DIP设计原则，那么我们就按照DIP原则的要求，提取出一个支付的父类来，即：“交易类”依赖“支付类”，“会员卡”、“购物卡”、“信用卡”、“现金”都继承“支付”类。具体实现如下：<br><img src="http://ww4.sinaimg.cn/large/666cc9e3gw1f4975xrknaj20m00kkq6x.jpg" alt=""></p>
<p>可以看到，应用DIP设计原则之后，我们又多出了一个“支付”的类，这个类原来在领域模型中是没有的，而是我们在设计阶段“创造”出来的。对于其它各个类，我们都可以依次使用设计原则进行判断，当发现不符合设计原则的设计时，就采取增加、删除、合并、拆分等手段，使我们的设计逐步改进，最终达到符合设计原则的目的。</p>
<p><strong>【设计模式】</strong></p>
<p>相比设计原则来说，设计模式更加普及和流行，当我们谈到设计方法的时候，大部分人肯定都会想到设计模式，设计模式如此深入人心，几乎到了言必谈设计模式的地步。<br>和设计原则类似，当我们谈论设计模式的时候，我们其实都是在谈论GOF（Gang of Four，中文翻译为“四人帮”）在经典名作《设计模式  –可复用面向对象软件的基础》一书中提到的设计模式。<br>通俗的讲，设计模式是用于指导我们如何做出更好的设计方案，而前面提到的设计原则，其作用也是这样的。那么，设计原则和设计模式，我们该如何选择？<br>有的朋友可能会以为这两个是二选一的关系，要么用设计原则，要么用设计模式。这种理解是错误的，设计原则和设计模式并不是竞争关系，正好相反，它们是互补的关系。<br>设计原则和设计模式互补体现在：<strong>设计原则主要用于指导“类的定义”的设计，而设计模式主要用于指导“类的行为”的设计</strong>，更通俗一点的讲：设计原则是类的静态设计原则，设计模式是类的动态设计原则。</p>
<p>一般情况下，我们是采用“先设计原则，后设计模式”的方法来操作的。</p>
<p>设计模式的相关内容会在后文详细介绍，这里我们以POS机为例，看看如何应用设计模式来优化我们的设计。</p>
<p>通过分析应用设计原则优化后的类，我们发现“信用卡”这个类存在优化的空间，因为国际上存在不同的信用卡，最常见的有中国银联（UnionPay）、Visa、MasterCard这几种，每种信用卡在支付的时候需要接入不同的机构，其接入方式和协议肯定都是有一定差异的。为了封装这种差异以支持后续更好的扩展，我们应用设计模式的Bridge模式，提取出“信用卡处理”这个类，这个类的主要处理“连接、认证、扣款”这样的职责。UnionPay、Visa、MasterCard都继承“信用卡处理”这个类。具体如下：<br><img src="http://ww3.sinaimg.cn/large/666cc9e3gw1f4976hjbucj20yp0omafe.jpg" alt=""></p>
<h2 id="第三斧（照本宣科）：拆分辅助类"><a href="#第三斧（照本宣科）：拆分辅助类" class="headerlink" title="第三斧（照本宣科）：拆分辅助类"></a><strong>第三斧（照本宣科）：拆分辅助类</strong></h2><p>**经过前面的设计步骤之后，面向对象类的设计工作已经完成，我们输出了完整的类模型，看起来已经可以开始动手编码了，你是否舒了一口气，看着自己的设计作品，不由得产生了一种自豪感呢？</p>
<p>确实值得自豪，毕竟我们一步一个脚印，从最初仅仅存在于客户脑袋中的需求，逐步的推导、演变、设计出了能够付诸实施的类模型了。但在最终实施之前，还有一点小小的动作要完成，这就是我们的拆分辅助类操作。</p>
<p>拆分辅助类的主要目的是为了使我们的类在编码的时候能够满足一些框架或者规范的要求。比如说常见的MVC模式，将一个业务拆分成Control、Model、View三个元素；J2EE模式中，将对象分为PO、BO、VO、DTO等众多对象。</p>
<p>之所以说这是一点小小的动作，是因为这个动作确实很简单，只要将我们设计出来的类，按照规范要求，一 一对应分拆即可。</p>
<p>以POS机为例，假如我们的框架要求提供DAO对象，负责数据库的相关操作，则“购物卡”类就应该拆分为两个：“购物卡”、“购物卡DAO”，其中“购物卡”用于负责提供“支付”功能给“交易”类调用，“购物卡DAO”用于负责从数据库读取购物卡信息，修改数据库中购物卡余额等操作。<br><img src="http://ww3.sinaimg.cn/large/666cc9e3gw1f4976wzbsgj20ch03vmxu.jpg" alt=""><br>需要注意的是，拆分设计辅助类仅仅是为了满足框架或者规范的要求，<strong>本身并不是一个设计的步骤，而是实施的一个步骤</strong>，所以我们一般都不需要将拆分的辅助类体现在类模型中，仅仅在编码的时候拆分即可。</p>
<h1 id="第二十七章"><a href="#第二十七章" class="headerlink" title="第二十七章"></a>第二十七章</h1><p>类模型指导我们如何<strong>声明类</strong>，动态模型指导我们如何<strong>实现类</strong>！</p>
<p>动态模型设计一般都是在类模型设计完成后才开始，因为动态模型设计的时候一般都需要用到类模型中的类。相对类模型来说，动态模型要相对简单一些，主要原因在于动态模型设计的时候没有什么设计原则和设计模式需要应用，只需要对照用例模型，根据用例模型的特点，选取一个合适的动态模型将其表述出来即可。</p>
<p>动态模型在实际开发过程中有非常重要的作用，简单来说，如果没有动态模型，那么你虽然完成了类设计，但还是不能编码，或者只能编写类的声明代码（类属性、方法名称），但不能写类的实现代码（方法里面的实现逻辑，即：每个方法的实现）。动态模型就是用来指导我们如何编写具体的方法的。</p>
<p>有的同学可能会有疑问：那些地方要进行动态模型设计呢？<br>还是那句老话，你觉得比较复杂你就设计，简单你就不设计，总之：<strong>你需要你就设计</strong>！<br>像我在实际开发中，基本上一个中等项目就一两个业务设计动态模型（小项目看到需求就编码了 ：） ），其它业务看需求文档就能看出如何编码，这也是有经验和经验不足的差别。</p>
<p>参考UML标准，常见的动态模型如下：<br>【状态模型】<br>状态模型主要用于描述对象的生命周期的状态变化。通过状态图，我们可以了解到对象有哪些状态，状态之间如何转换，转换的触发条件等。当我们发现一个对象的状态比较复杂的时候，就需要设计对象的状态模型。<br>UML中使用状态图来描述状态模型</p>
<p><strong>【活动模型】</strong><br>活动模型主要用于描述一个工作流程或者计算流程。其关注点是在完成某项工作的过程中，系统中的哪些对象承担了什么样的任务、做了什么处理，以及这些对象之间的先后交互关系。当我们发现一个处理流程比较复杂的时候，就需要设计流程的活动模型。<br>UML中使用活动图来描述活动模型</p>
<p><strong>【序列模型】</strong><br>序列模型主要用于描述对象按照时间顺序组织的消息交互过程，其关键特征是强调按照“时间顺序”来组织对象的交互，所以序列图有时又称为“时序图”或者“顺序图”。序列模型是我们最常用的动态模型，特别适合将用例模型或者SSD转换为系统的动态模型。<br>UML中使用序列图来描述序列模型</p>
<p><strong>【协作模型】</strong><br>协作模型主要用于描述按照对象之间的关联来组织的消息交互过程，其关键特征是强调“对象关系”来组织对象的交互。协作模型的作用和序列模型一样，只是强调的点不同，大部分的时候我们都是选择“序列模型”，因为序列模型的时间顺序很多时候和用例模型的步骤不谋而合。<br>UML中使用协助图来描述协作模型</p>
<p>注意：以上模型并不是每个都必须有的，根据实际需要选择即可</p>
<p><strong>建模实践</strong><br>以上这些模型都可以从用例模型推导出来，活动模型、序列模型、协作模型基本上都是和用例模型一一对应的，或者对应用例中的某个分支。一般情况下不推荐一个模型中包含多个分支，因为这样会导致图比较复杂，而且主题不突出。</p>
<p>状态模型和其它模型相比要复杂一些，因为并不能从单个用例或者单个用例分支推导出某个对象的所有状态，而需要综合多个用例模型，从中提取出和某个对象状态相关的内容，再统一设计状态模型。</p>
<p>从用例模型推导出动态模型是一个“分解和分配”的过程，因为在用例模型中，系统是当做一个“黑盒”来看待的，而在动态模型中，系统不再是一个黑盒，而是分解成了一个一个的类。因此我们需要将原来笼统的划分给系统的功能和职责，进一步分解并分配给不同的类。通俗的讲，动态模型就是说：为了完成系统的XXX功能， 先需要类A做任务1，然后需要类B需要做任务2，再由类C做任务3。。。。。。依次分解下去，最终就能够实现将类串起来，相互配合，最后实现了系统的需求。</p>
<p>我们以POS机为例，假设我们基于买单这个用例的正常分支设计“序列模型”，则可以得到如下的“序列模型”：<br><img src="http://ww3.sinaimg.cn/large/666cc9e3gw1f4977ftgrwj20qh0zq41q.jpg" alt="">有了上面这个“序列图”，假设我们要开始写代码，则基本可以按照如下伪码的方式实现（实际的编码肯定不会这么简单，但方法是一样）：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;  </span><br><span class="line">  </span><br><span class="line">    Trade trade = <span class="literal">new</span> Trade();                  </span><br><span class="line">    <span class="built_in">Integer</span> tradeId =trade.makeNewTrade();  <span class="comment">//创建  </span></span><br><span class="line">    trade.addGoods();                       <span class="comment">//增加商品  </span></span><br><span class="line">    trade.cacuMoney();                      <span class="comment">//计算总额  </span></span><br><span class="line">    <span class="attr">...</span><span class="attr">...</span><span class="attr">...</span><span class="attr">...</span><span class="comment">//省略一大段代码  </span></span><br><span class="line">    Receipt receipt = <span class="literal">new</span> Receipt();          </span><br><span class="line">    receipt.print(trade);                   <span class="comment">//打印小票  </span></span><br><span class="line">    <span class="attr">...</span><span class="attr">...</span><span class="attr">...</span>..<span class="comment">//省略一大段代码  </span></span><br><span class="line">    trade.finish();                         <span class="comment">//结束  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[连载：面向对象葵花宝典：思想、技巧与实践(11-20章)]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/05/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B82.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>无意间发现这篇文章，文章讲解由浅入深，读完后感触很深<br>特全文转到自己的博客，方便以后自己随时查看<br>文章转载自爱技术的华仔的博客[<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">http://blog.csdn.net/yunhua_lee</a>]<br>非常感谢<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">爱技术的华仔</a></p>
</blockquote>
<h1 id="第十一章-“封装”-详解"><a href="#第十一章-“封装”-详解" class="headerlink" title="第十一章 “封装” 详解"></a>第十一章 “封装” 详解</h1><p>封装的概念本身很好理解，意思就是把一堆东东装起来。<br> <a id="more"></a><br>但要想真正理解封装，这样还远远不够。<br>第一个问题是：我们要封装什么？<br>这个问题很好回答，封装当然是封装不想让别人知道或者看到的东东了。<br>例如：<br>你的身家。。。。。。<br>漂亮MM的年龄。。。。。。<br>富二代的女朋友数。。。。。<br>明星是否整过容。。。。。。<br>你是如何赚到100万的（想想什么样的赚钱方法不想让人知道？）。。。。。。<br>你是如何消磨时间的（想想什么样的消磨时间方法不想让人知道？）。。。。。。<br>等等<br>站在面向对象的角度来说，封装就是“类”的一个功能，你可以封装“类”的属性（比如身家、年龄等），也可以封装“类”的方法（比如说如何赚钱、如何消磨时间），也就是说，面向对象通过“类”来实现了封装。</p>
<p>第二个问题是：我们为什么要封装？<br>封装数据的主要原因是“<strong>保护隐私</strong>”，因为有“隐私”，所以要“封装”。如果没有封装，你的隐私就暴露在所有人面前了，别人也可以控制你的隐私，那样将是非常危险的。</p>
<p>例如面向过程的设计中，数据结构是公开的，任何能够获取到数据的人都可以随意修改，也可以使用不同的方式修改，如果某个不小心的程序员或者菜鸟或者一个准备离职又心怀不满的开发人员，无意或有意改错了，那么其它依赖这个数据的函数都会受到影响，要么导致业务出错，甚至导致程序崩溃。</p>
<p>而面向对象的类封装了属性后，对属性的修改只能通过类的方法进行，一来不会暴露内部的具体属性，二来对属性的操作都是统一的，不会出现乱改的情况。</p>
<p>封装方法的主要原因是“<strong>隔离复杂度</strong>”。每个类只需要关注自己的负责的功能如何完成即可，如果需要其它类配合，只需要调用类的方法即可，而不需要了解其它类功能的具体的实现。</p>
<p>“隔离复杂度”的例子即使在现实世界中也比比皆是。例如我们夏天常用的空调能够提供制冷功能，我们只要轻轻一按遥控器的按钮，空调就能够开始制冷，但空调究竟是如何制冷的，绝大部分人并不知道，也并不关心。空调封装了制冷的实现过程，对人提供了一个制冷的按钮，人通过这个按钮来启动制冷的过程。</p>
<p>【封装的样例】<br>简单的这么回答你可能没有什么感觉，但给一个面向对象“封装”和面向过程“无封装”的例子，相信你就很清楚了。<br> 举个简单的例子，假设用程序实现付款这个操作，我们来看面向对象和面向过程的方式。</p>
<p>面向过程 = <a href="http://lib.csdn.net/base/31" target="_blank" rel="external">算法</a> + 数据结构<br>这里的数据结构是公开的，每个地方都可以看到和引用的，而且必须知道，否则面向过程的各个处理流程就没法处理了。<br>具体代码实现如下：<br>person.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PERSON_H_  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERSON_H_  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Person&#123;  </span><br><span class="line">    <span class="keyword">char</span>* name;  <span class="comment">//姓名  </span></span><br><span class="line">    <span class="keyword">int</span> money;   <span class="comment">//金钱数量  </span></span><br><span class="line">&#125;Person;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* PERSON_H_ */</span></span></span><br></pre></td></tr></table></figure></p>
<p>money.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"person.h"</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> null 0x00  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    Person* me = (Person*)<span class="built_in">malloc</span>(sizeof(Person));  </span><br><span class="line">    me-&gt;name = <span class="string">"华仔"</span>;  </span><br><span class="line">    me-&gt;money = <span class="number">100</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//收银员收银  </span></span><br><span class="line">    <span class="keyword">if</span>( me-&gt;money &gt; <span class="number">50</span> )&#123;  </span><br><span class="line">        me-&gt;money -= <span class="number">50</span>;   <span class="comment">//收银操作时，需要知道Person实际有多少钱，然后直接操作Person的money  </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s 付款成功，共  %d 块\n"</span>, me-&gt;name, me-&gt;money);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s 付款失败 \n"</span>, me-&gt;name);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//小偷偷钱  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"偷了 %s %d 块\n"</span>, me-&gt;name, me-&gt;money);  </span><br><span class="line">    me-&gt;money = <span class="number">0</span>;   <span class="comment">//小偷也可以直接知道Person有多少钱，并直接操作Person的money  </span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">free</span>(me);  </span><br><span class="line">    me = null;  </span><br><span class="line">    return EXIT_SUCCESS;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，你有多少钱，所有人都知道！<br>也就是说，你的钱，别人可以随便控制！<br>就像你去超市买东西，付款的时候，收银员说：把你所有的钱摆在台子上，我从里面拿50.<br>不用我说你也知道，这当然是一件很恐怖的事情！</p>
<p>面向对象 = 对象 + 交互<br>但在面向对象的实现里面就不会这样了，你不需要把钱摆出来，你只需要拿出50就可以了，你既不需要担心别人知道你有多少钱（然后实施某种后续动作），也不需要担心别人拿错了（不管是有意的还是无意的）。</p>
<p>具体实现代码如下：<br>Person.Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.oo.java;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 普通人 </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String _name;    <span class="comment">//姓名  </span></span><br><span class="line">    <span class="keyword">private</span> Integer _money;  <span class="comment">//金钱  </span></span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> _name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">pay</span><span class="params">(Integer money)</span></span>&#123;  </span><br><span class="line">        <span class="comment">//付款的逻辑由Person自己控制，例如判断当前的钱是否够支付  </span></span><br><span class="line">        <span class="keyword">if</span>( money &gt; _money )&#123;  </span><br><span class="line">              </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        _money -= money;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Cashier.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oo.java;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 收银员 </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cashier</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">get</span><span class="params">(Person person, Integer money)</span></span>&#123;  </span><br><span class="line">        Boolean result = person.pay(money);  <span class="comment">//收银员只需要调用Person的pay方法，无需知道Person当前有多少钱  </span></span><br><span class="line">        <span class="keyword">if</span>( result )&#123;  </span><br><span class="line">            System.out.println(person.getName() + <span class="string">" 付款成功，共  "</span> + money +<span class="string">" 块"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>&#123;  </span><br><span class="line">            System.out.println(person.getName() + <span class="string">" 付款失败"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Thief.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oo.java;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 小偷 </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thief</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">stole</span><span class="params">(Person person)</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//小偷想直接访问Person的money，但这样做不允许，编译出错  </span></span><br><span class="line">        System.out.println(<span class="string">"偷了 "</span> + person.getName() +<span class="string">" "</span> + person._money + <span class="string">" 块\n"</span>);  </span><br><span class="line">        person._money = <span class="number">0</span>;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//虽然小偷这个类语法上也可以直接调用Person的pay方法，  </span></span><br><span class="line">        <span class="comment">//但Person的pay方法里面可以做很多的校验功能来让这样的调用返回失败  </span></span><br><span class="line">        person.pay(<span class="number">50</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="第十二章-“继承”-详解"><a href="#第十二章-“继承”-详解" class="headerlink" title="第十二章 “继承” 详解"></a>第十二章 “继承” 详解</h1><p>继承 = 遗传<br>继承是面向对象最基本的特征，如果一个语言没有继承机制，就谈不上真正的面向对象的语言。</p>
<p>继承本身很好理解，和我们日常生活中的“继承”概念基本一样：子承父业！所以，你可以看到面向对象的编程语言里面，有了“父类”、“子类”的概念。</p>
<p>但是我个人认为“继承”这个说法并不确切，一般我们理解“继承”，都是理解为继承产业、继承财产，例如李泽钜继承李嘉诚的事业。但在面向对象的领域里面，并不是“子类”继承了“父类”的产业，而是继承了“父类”的特点，具体来说就是继承了“属性和方法”。</p>
<p>所以我认为“继承”更加贴切的说法是类似生物学上的“遗传”，按照中国话的说法就是“龙生龙，凤生凤，老鼠生来会打洞”，面向对象的继承意味“子类”遗传了了某些“父类”的属性和方法。</p>
<p>但就像生物学上的进化论一样，有遗传就有变异，正因为有了变异，才会有新的物种产生；有了变异，面向对象才有子类的出现。</p>
<p>当然，面向对象的进化不是“自然选择”的结果，而是你——伟大的程序猿——选择的结果。<br>除了可以选择子类如何变异外，你——伟大的程序猿——还可以控制另外一个遗传因素：你可以决定父类遗传什么给子类！</p>
<p>也就是说，你可以控制父类将哪些“基因”遗传下去，你也可以控制子类如何变异出哪些新基因。<br>所以，你——伟大的程序猿——就是面向对象世界的“上帝”！</p>
<p> 继承 vs 抽象？<br>我们来看看一个继承的实例：<br> <img src="http://ww2.sinaimg.cn/large/666cc9e3gw1f496wyixmpj20ge07wmxx.jpg" alt=""></p>
<p>如果你还记得前面看过的“抽象”一章的内容，你一定会感到很惊讶：<br>抽象和继承的图完全相反，那这两个东东到底有什么区别和联系呢？</p>
<p>抽象：是分析和设计过程中的一个动作，一个技巧，通过抽象得出类<br>继承：是实现过程中的一个动作，基于抽象结果，通过编程语言的特性，完成抽象图的模拟。</p>
<p>因此，抽象和继承是前后衔接的关系，先有抽象，通过抽象得出类，后通过继承来表达抽象结果</p>
<h1 id="第十三章-“多态”-详解"><a href="#第十三章-“多态”-详解" class="headerlink" title="第十三章 “多态” 详解"></a>第十三章 “多态” 详解</h1><p>在此要向将polymorphism翻译成“多态”的人致敬！<br>因为多态的英文实在是太难理解了，而中文翻译得又如此形象如此贴切。</p>
<p>从字面意思上就可以看出，多态就是“多种形态”的意思。但仔细探究一下：“多种形态”其实还是没法很好的理解，不同的人也还是会有不同的理解。</p>
<p>动画片看得多的同学可能会以为：多种形态，就是很多种变身啦 ：），就像孙悟空72变一样，一会儿可以变成房子，一会儿可以变成牛魔王。。。。。。</p>
<p>擅长盛装打扮的美女可能会以为：多种形态，其实就是换不同的衣服嘛，你看我一会文艺小清新打扮，一会儿高贵典雅的贵妇人装束，一会儿小鸟依人的淑女形象。。。。。。</p>
<p>学院派技术宅男可能会以为：多种形态，其实就是多种状态啦，比如说TCP协议栈有XX种状态，线程有XX种状态。。。。。。</p>
<p>还可能有很多其它各种各样的理解，但在面向对象领域，这些理解都不正确，多态不是变身、不是换装、不是状态变化，而是“多胎”！！</p>
<p>你可能会很惊讶，以为这里是打字打错了，怎么可能是“多胎”呢？“多胎”又是什么意思呢？</p>
<p>多胎在这里也是一个形象的说法，在面向对象领域，多态的真正含义是：使用指向父类的指针或者引用，能够调用子类的对象。</p>
<p>我们以Java程序为例：<br>Animal.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oo.base.polymorphism;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 这是父类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">talk</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">Dog.java</span><br></pre></td></tr></table></figure></p>
<p>package com.oo.base.polymorphism;  </p>
<p>/** </p>
<ul>
<li>子类：狗 </li>
<li><p>*/<br>public class Dog extends Animal {  </p>
<p> public Dog() {  </p>
<p> }  </p>
<p> @Override<br> String talk() {  </p>
<pre><code>return &quot;Dog......wang wang&quot;;  
</code></pre><p> }  </p>
</li>
</ul>
<p>}<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Pig.java</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">package</span> com.oo.base.polymorphism;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 子类：猪 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pig</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pig</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function">String <span class="title">talk</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Pig......ao ao"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Cat.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oo.base.polymorphism;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 子类：猫 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function">String <span class="title">talk</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cat......miao miao"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oo.base.polymorphism;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     *  </span><br><span class="line">     * <span class="doctag">@param</span> a Animal  这个参数就是“多态”的具体表现形式 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Animal a)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//在调用a.talk()的时候, 函数并不知道a究竟是Pig，Dog，还是Cat，只知道是一个Animal  </span></span><br><span class="line">        System.out.println(a.talk());   </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//在调用write函数的时候，可以传入Cat/Dog/Pig对象，并且输出也不一样  </span></span><br><span class="line">        write(<span class="keyword">new</span> Cat()); <span class="comment">//传入Cat，输出"Cat......miao miao"  </span></span><br><span class="line">        write(<span class="keyword">new</span> Dog()); <span class="comment">//传入Dog，输出"Dog......wang wang"  </span></span><br><span class="line">        write(<span class="keyword">new</span> Pig()); <span class="comment">//传入Pig，输出"Pig......ao ao"  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的样例可以看出，Pig、Dog、Cat是三个Animal的子类，在函数调用的时候，参数类型指定为Animal，但具体传入的参数值可以是Animal的子类Pig、Dog、Cat，也就是说：指定为Animal类型的参数，可以为Pig，也可以为Dog，也可以为Cat，总共有3中不同的形态。</p>
<p>多态的特性在面向对象编程的领域中具有十分重要的作用。多态屏蔽了子类对象的差异，使得调用者可以写出通用性的代码，而无需针对每个子类都需要写不同的代码。<br>例如，如上的样例，如果没有多态，Test的write函数就必须这么写了：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.oo.<span class="keyword">base</span>.polymorphism;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 不支持多态的Test实现 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test2</span> &#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 如果不支持多态，每个write函数都需要和具体的子类对应， </span><br><span class="line">     * writeCat对应Cat子类 </span><br><span class="line">     * @param a </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeCat</span>(<span class="params">Cat a</span>) </span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(a.talk());   </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 如果不支持多态，每个write函数都需要和具体的子类对应， </span><br><span class="line">     * writeDog对应Dog子类 </span><br><span class="line">     * @param a </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeDog</span>(<span class="params">Dog a</span>) </span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(a.talk());   </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 如果不支持多态，每个write函数都需要和具体的子类对应， </span><br><span class="line">     * writePig对应Pig子类 </span><br><span class="line">     * @param a </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writePig</span>(<span class="params">Pig a</span>) </span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(a.talk());   </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//需要针对每个子类调用不同的函数  </span></span><br><span class="line">        writeCat(<span class="keyword">new</span> Cat()); <span class="comment">//传入Cat，输出"Cat......miao miao"  </span></span><br><span class="line">        writeDog(<span class="keyword">new</span> Dog()); <span class="comment">//传入Dog，输出"Dog......wang wang"  </span></span><br><span class="line">        writePig(<span class="keyword">new</span> Pig()); <span class="comment">//传入Pig，输出"Pig......ao ao"  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码与Test1的代码对比，很明显Test1的要清晰和简洁很多，要少写很多代码。</p>
<p>除了能够让代码清晰简洁外，多态还有一个更加重要的作用：<br><strong>当增加新的子类时，调用者的代码无需变动就能适用新的子类</strong>。<br>以Test1为例，假设我们增加一个Cock的Animal子类，Test1的代码无需任何改变就可以支持Cock类，而Test2则需要增加一个writeCock的函数。</p>
<h1 id="第十四章-面向对象开发技术流程"><a href="#第十四章-面向对象开发技术流程" class="headerlink" title="第十四章  面向对象开发技术流程"></a>第十四章  面向对象开发技术流程</h1><p>抛开项目流程，让我们来谈谈“技术流程”吧！！</p>
<p>谈到流程，很多人立刻就会想到熟悉的瀑布模型、螺旋模型、迭代开发、敏捷、RUP等一堆软件工程相关的软件开发流程，但对于大部分人来说，这些流程仅仅是项目管理上的概念，只有项目经理开例会时那红红绿绿的甘特图、燃尽图、路径图等，或者只有评估工作量和是否要加班的时候，我们才会意识到这些流程的存在。</p>
<p>通俗的讲，项目管理上的流程主要是用于指导项目经理如何管理项目用的，但对于如何指导开发人员如何开发项目，并无多大用处。一个典型的情况就是刚毕业的大学生，软件工程掌握的很熟悉，各个开发阶段应该做什么，瀑布流程有什么优缺点等，谈起来都头头是道，但真的参加开发项目后，就会发现有一种无从下手的感觉。例如：<br>Ø 需求分析阶段要分析需求，但具体怎么分析呢？<br>Ø 客户的需求是描述性的，例如“我们需要一个POS机”，而代码是一个一个具体的类和函数，那么如何从描述性的语言最后转化到具体的类和函数呢？<br>Ø 具体语言的特性，例如Java和C++的private、protected、public这些属性是从哪里来的？什么时候设计的？<br>Ø 面向对象的类、接口等，是怎么设计出来的 ？</p>
<p>相信这些问题都曾经困扰过很多人，但软件工程并没有给出这些问题的答案，因此也就导致了很多开发人员在实际开发过程中，要么只能在别人的指导下工作，要么就瞎蒙乱撞、拼凑堆砌，反正最后也能够实现需求，至于效果嘛，那就要看运气了。少数几个领悟力强的人，经过一段时间的磨练后，也许就慢慢掌握了门道，但大部分人可能就一直原地踏步，不断的在重复别人分配给自己的工作。</p>
<p>其实，就像项目管理上有一套完整的流程一样，<strong>项目开发也有一套完整的过程</strong>，尤其对于面向对象来说，整个开发流程其实是非常清晰的，只是很少有人将这部分归纳总结提炼出一套用于指导开发人员进行开发的流程。</p>
<p>为了区别起见，我们将瀑布模型、敏捷开发等称为“管理流程”，而将面向对象开发流程称为<strong>“技术流程”</strong>。面向对象的技术流程可以概括如下：<br>需求模型 -&gt; 领域模型 -&gt; 设计模型 -&gt; 实现模型</p>
<p>l 需求模型<br>通过和客户沟通，结合行业经验和知识，明确要求客户的需求。</p>
<p>l 领域模型<br>基于需求模型，提炼出领域相关的概念，为后面的面向对象设计打下基础。</p>
<p>l 设计模型<br>以领域模型为基础，综合面向对象的各种设计技巧，完成类的设计。</p>
<p>l 实现模型<br>以设计模型为基础，将设计模型翻译为具体的语言实现，完成编码。</p>
<p>以上流程环环相扣，上一步流程的输出就是下一步流程的输入。后面我们可以看到，通过这种一步一个脚印的方式，即使是经验并不丰富的菜鸟，也能完成从需求到最后实现的相关工作，而不再需要仰望和崇拜其他大虾大牛，或者自己摸着石头过河了！</p>
<h1 id="第十五章-需求详解"><a href="#第十五章-需求详解" class="headerlink" title="第十五章 需求详解"></a>第十五章 需求详解</h1><p>很多人像老黄牛一样辛辛苦苦做了很多年软件开发，但却连“需求”到底是什么都不清楚。当然，没有人自己会承认这点！</p>
<p><strong>【需求到底是什么】</strong><br>凡事都有一个开头，软件项目也不例外，对于软件项目来说，需求就是项目最开始的一个输入。</p>
<p>参考维基百科，需求定义如下：</p>
<blockquote>
<p>In systems engineering, a requirement can be a description of what a system must do, referred to as a Functional Requirement.</p>
</blockquote>
<p>简单翻译一下就是：需求即系统需要做什么。</p>
<p>但正是这个简单的定义，让很多人陷入了<strong>陷阱</strong>：需求即功能。<br>单纯从字面意思来理解这样也是没有问题的：系统需要做什么，当然就是系统要提供什么功能了！</p>
<p>我们来看一个简单的例子：ATM自动取款机。<br>有的人说，ATM的功能是取款、存款、查询余额，所以针对ATM的需求应该是：取款、存款、查询余额；<br>有的人说，ATM的功能有很多：识别卡、密码认证、点钞、验钞、查询余额、跨行取款等，所以针对ATM的需求应该是：识别卡、密码认证、点钞、验钞、查询余额、跨行取款。</p>
<p>如果你是ATM购买商，你认为哪种才是你的需求？<br>如果你是ATM制造者，你认为哪种才是你的需求？<br>如果你是ATM使用者，你认为哪种才是你的需求？</p>
<p>可能大部分人都会支持第二种，原因很简单：取款也要密码认证、存款也要密码认证，所以密码认证是一个需求，而不是分到两个需求里面。<br>而且第二种方式划分需求有一个好处：系统最后提供的功能和需求基本上是一一对应的。</p>
<p>看起来很美妙，但其实我们忽略了一个问题：采用第二种方式的主要原因是我们对ATM机很熟悉了！</p>
<p>但如果换一个身份，比如说你是一个只识字的农民工，你对ATM机的要求会是“识别卡、密码认证。。。。。。”这样专业的需求么？<br>肯定不会，你的需求应该是“取款”、“存款”、“查询余额”。</p>
<p>我们继续打破砂锅问到底：为什么农民工兄弟的需求肯定是“取款”、“存款”、“查询余额”，而不是“识别卡”、“密码认证”、“点钞”。。。。。。？</p>
<p>我们假设一下，假如农民工兄弟对ATM的需求是“点钞”，那么就会出现这样滑稽的场景：他经常拿着卡去ATM机，让ATM机点一下钞；又或者他的需求是“密码认证”，那么他经常拿着卡去ATM机验证一下密码。</p>
<p>你当然不会看到这样的场景，农民工兄弟也不会有这样的需求，他只管能取到钱即可，因为取到钱他就可以拿钱去花了，至于取钱的过程中管你是密码认证、点钞还是验钞，说的搞笑一点：他更希望把卡插进去，钱就自动吐出来而且不受限额。</p>
<p>相信到这里，你已经能够明白需求和功能的差别了，我们总结一下：<br>需求：对客户来说有价值的事情；<br>功能：系统为了实现客户价值而提供的能力；</p>
<p>因此，区别是需求还是功能的方法很简单了：只要判断是否对客户有价值。<br>我们可以举更多例子来证明这个方法：<br>POS机：“买单”是需求，“商品扫描”、“金额汇总”、“收银”等是功能，因为买完单后顾客就能将产品拿走；<br>汽车：“驾驶”是需求，“发动机”、“刹车”、“加速”等是功能；<br>打印机：“打印”是需求，“进纸”、“设定”、“与电脑连接”等是功能；<br>。。。。。。<br>（有兴趣的朋友可以自己多想想）</p>
<p>【需求非常重要】<br>俗话说，万事开头难，需求是软件项目的最开始输入，肯定是非常重要的，按道理来说也应该是需要重点关注的。</p>
<p>然而现实情况却恰恰相反：很多项目都不怎么重视需求！</p>
<p>你可以经常看到这样的场景：<br>需求分析人员和客户沟通了一下，然后把客户的要求简单整理了一下就交给研发了。。。。。。<br>项目计划比较紧，那么就把需求分析阶段加快一些吧（实际上就是减少投入时间）。。。。。。<br>产品给了一个简单的需求，为了能够快速交付，没有怎么分析就开始设计编码了。。。。。。</p>
<p>虽然看起来时间是节省了，项目是加快了，然而最终的结果却令人失望：据统计，有将近1/3的项目失败或者陷入困境时因为需求原因导致的！</p>
<p>这个就是所谓的“垃圾进垃圾出（Garbage in, garbage out）”的效果，即：<br>如果最开始的输入是错误的，后面的过程再怎么优秀，最终都会输出垃圾产品。而且可能是后面越优秀，最终输出越垃圾，就像你朝一个错误的方向跑步，跑得越快离正确的终点越远一样。</p>
<p>举一个虽然恶心但很形象的例子：给你一坨屎，你放到饼干生产线上，最后生产出来的不是饼干，而是像饼干的一坨屎！：）</p>
<p>你可能会说，错了我改还不行么？<br>当然是可以的，但你要做好心理准备，还有一个更加令人抓狂的事实：修复需求错误的问题的成本非常高昂！</p>
<p>我们假设编码阶段发现和修复一个错误所耗费的人力是1个单位，那么在测试阶段修复需求错误的成本是5~10倍，在维护阶段（产品正式应用后），修复需求错误的成本是20倍，而如果在需求阶段修复需求错误，成本只需要0.1~0.2即可。</p>
<p>也就是说，需求错误的成本存在这样的比例关系：维护阶段修复 = 需求阶段修复 * 200 ！<br>原因显而易见：如果你的需求错了，那么你几乎是要把软件项目重做一遍！</p>
<p>相信经过前面的分析，你对于需求的重要性已经有了充分的认识了。<br>请时刻牢记：需求很重要！</p>
<h1 id="第十六章-需求分析终极目的"><a href="#第十六章-需求分析终极目的" class="headerlink" title="第十六章 需求分析终极目的"></a>第十六章 需求分析终极目的</h1><p><strong>需求分析有三种级别，你自认为属于哪一级呢 ？   —写在前面</strong></p>
<hr>
<p>============================华丽丽的分割线=============================</p>
<p><strong>需求分析的目的是什么？</strong></p>
<p>你可能会毫不犹豫的回答：需求分析的目的当然是了解客户需要什么！</p>
<p>这个回答看起来是毫无疑问的，我们当然要了解客户需要什么，我们才能给他们做出他们想要的。<br>但只做到这样就可以了么？</p>
<p>我们来看一个简单的需求，客户找到你说：“我要一只羊！”<br>这个需求够简单吧？那你是不是毫不犹豫的就抓一只羊给客户呢？</p>
<p>如果你这样做了，如果你运气好，客户可能非常满意，但大部分情况，也许客户很不满意，为什么？<br>我们来看“我要一只羊”这个需求的多个版本：<br>图一：<br>一个饥肠辘辘的人说，我要一只羊，用来烤着吃！<br>（来源于网络： <a href="http://soufun.com/Album/PictureDetail_40800605_200_127935903.htm" target="_blank" rel="external">http://soufun.com/Album/PictureDetail_40800605_200_127935903.htm</a> ）<br><img src="http://ww1.sinaimg.cn/large/666cc9e3gw1f496xob6hqj20c2078dg8.jpg" alt=""></p>
<p>图二：<br>一个慈爱的父亲说，我要一只羊，给我小孩做宠物！<br>（来源于网络： <a href="http://ww4.sinaimg.cn/mw600/763f9322jw1duqu3vsy6wj.jpg" target="_blank" rel="external">http://ww4.sinaimg.cn/mw600/763f9322jw1duqu3vsy6wj.jpg</a> ）<br><img src="http://ww4.sinaimg.cn/large/666cc9e3gw1f496yskqn8j20f10m8q4f.jpg" alt=""></p>
<p>图三：<br>一个农场主说，我要一只羊，生小羊！<br>（来源于网络： <a href="http://cs.cq.gov.cn/upfiles/2009-3/20093293042143.jpg" target="_blank" rel="external">http://cs.cq.gov.cn/upfiles/2009-3/20093293042143.jpg</a> ）<br><img src="http://ww2.sinaimg.cn/large/666cc9e3gw1f496z8w5jqj20dw0abq3p.jpg" alt=""><br>看了上面这几幅图，相信你就大概明白了：客户会告诉我们他们的需求，但大部分情况都不会告诉你需求背后的问题。而需求分析的终极目的，就是要“<strong>挖掘客户的问题，实现客户价值</strong>”！</p>
<p>因为只有你提供的东西，最后能够解决客户的问题，客户才会满意。如果你提供的东西，没有解决客户的问题，就算你是一五一十的按照客户提的来做的，客户还是不会满意，客户不满意，你的BOSS就会不满意，你的BOSS不满意，你的上司就会不满意。。。。。。最后，损失最大的还是你！</p>
<p>但我们为什么费心费力的要去挖掘客户的问题呢？客户难道不会直接告诉我们么？<br>客户当然不会告诉你“我饿了”，因为这是他的问题，不是他的需求，他告诉你“我要一只羊”，这才是需求，只是这个需求是解决他的问题的。</p>
<p>但既然这样，我们为什么要管他的问题，直接满足他的需求不就得了？<br>这又涉及另外一个问题，大部分的客户都会基于自己的经验、知识、阅历等，自己设计一个解决方案，然后作为需求向你提出来。如果你碰上懂行的客户，那自然要谢天谢地了；<br>但是绝大部分情况你碰到的客户可能就是每天坐在办公室，一张报纸一杯茶，上上网打打牌，然后接到某个领导的“信息化”任务，然后就给你提了一个需求！</p>
<p>除此之外，深入了解客户的问题，有助于你更好的实现需求。就举前面的“我要一只羊”的例子，<br>如果客户是用来吃的，也许你更应该提供一顿烤羊肉，或者一只大羊腿，客户会更加满意；<br>如果客户是用来给他小孩做宠物的，那么给一只雪白的漂亮的小羊羔也许他的小孩更高兴；<br>如果客户是用来生小羊的，那么给一只强壮的成年母羊是更好的选择。</p>
<p>一般来说，需求分析有三重境界，分为“记录员”、“分析员”、“引导员”三个级别，我们以上面提到的“我要一只羊”的需求来作为样例：<br><strong>1） 第一重：记录员，记录客户的需求；</strong><br>需求分析人员记录下了如下需求：XX客户需要一只羊，品种：绵羊，颜色：白色，重量：20Kg。<br>点评：只是简单记录了客户的需求，没有明白客户的问题，如果真的提供了一只羊，肚子饿的客户可能会再次提出要将羊烤好（或者做羊肉汤）。</p>
<p><strong>2） 第二重：分析员，和客户一起分析问题，完善需求；</strong><br>需求分析人员记录下了如下需求：XX客户肚子饿了，需要一只羊烤着吃，由于客户并不会自己烤羊，因此我们需要提供一只烤好的羊。<br>点评：发现了客户的问题，需求调整为“烤好的羊”，这个已经能够解决客户的问题了，但还不够完美。</p>
<p><strong>3） 第三重：引导员，能够引导客户的需求；</strong><br>需求分析人员记录了如下需求：XX客户肚子饿了，需要一只羊烤着吃，但目前是夏天，烤羊火气太重，经过与客户沟通，客户更愿意吃一顿冰镇啤酒海鲜大餐。<br>点评：发现了客户的问题，并且引导客户将需求调整为更合理的需求。</p>
<p>我们可以看到，<strong>要想做好需求分析，要时刻抓住“客户的问题和价值”这个指导思想</strong>！</p>
<p>===============2015.02.17补充========================<br>网上看到一个更加生动和更加深入解读的文章，大家可以参考：<a href="http://www.yixieshi.com/ucd/20359.html" target="_blank" rel="external">用户都是骗子</a></p>
<h1 id="第十七章-需求分析518方法"><a href="#第十七章-需求分析518方法" class="headerlink" title="第十七章 需求分析518方法"></a>第十七章 需求分析518方法</h1><p>对于大部分人来说，可能并没有机会进行需求分析，因为在大部分的公司里面，需求分析都是有很多工作经验的资深人员，或者是对系统很熟悉的老的开发人员。</p>
<p>所以，很多人都会对需求分析有一种景仰的心态，认为既然做需求的人要求这么高，那么需求分析一定很复杂、很难、很高级了。而且很多需求分析人员动不动就会教训“你要站在客户的角度”、“你要全面的分析”等，然后再抛出几个需求建模之类的玩意吓吓你。。。。。。</p>
<p>但其实做需求分析一点都不高深，只要掌握正确的方法，大部分人都能够做需求分析，而且可以做的很好！</p>
<p>而且这个正确的方法掌握起来很简单，不需要你另外再去买一本书刻苦阅读，也不需要你花费大量的时间去实践，去探索。</p>
<p>下面我们就来看，这个简单的正确方法究竟是什么。</p>
<p>我总结起来就是“<strong>需求分析518方法</strong>”,简称“我要发”，具体来说就是5W1H8C！！<br>5：5W，即When、Where、Who、What、Why<br>1：1H，即How<br>8：8C，即8个Constraint，包括性能Performance、成本Cost、时间Time、可靠性Reliability、安全性Security、合规性Compliance、技术性Technology、兼容性Compatibility</p>
<p>下面我们来详细分析这几个点。<br>【5W】<br>5W：5W作为一组，首先是它们都以W开头，但这不是最关键，最关键的在于这些是一个需求产生的环境，或者说上下文（英文Context）。<br>为什么我们要关注需求产生的环境？很简单：环境影响需求。</p>
<p>举个很简单的例子：同样是垃圾桶，放在巴西贫民窟的要求和放在纽约帝国大厦肯定不一样。贫民窟可能有很多顽皮的小孩，将垃圾桶作为玩具，或者作为足球的射门目标；而帝国大厦都是文质彬彬的白领金领，对美学可能有特别的要求；因此，两个不同地方的垃圾桶，需求是完全不一样的。</p>
<p>有人会说，客户难道不是最明白他们需求的环境么？为什么他们不直接告诉我们？</p>
<p>前面我们提到，客户往往基于自己的经验、理解、学识等，给出一个解决方案，然后他们跟你说这是他们的需求。理想的情况，当然是客户非常在行，最好就是软件分析师出身的；但现实却往往不妙，很多客户对软件的理解可能仅仅停留在Windows甚至QQ上，甚至有客户会认为你会变魔法，只要他说一个简单需求，你就能变出他想要的！</p>
<p>客户当然不会是软件分析师，我们也不是魔法师，因此，我们必须亲自出马，弄清需求产生的环境。</p>
<p>==When==<br>这是和时间相关的环境信息，常见的时间信息有：<br>1） 季节信息：春夏秋冬等<br>2） 日期信息：节日、假日等<br>3） 作息事件：白天、晚上、凌晨、早晨、上午、下午、晚上、深夜等</p>
<p>一个简单的例子：我在以前公司做通讯设备的时候，如果是做数据倒换工具，都要求非常智能，最好是一键式操作？为什么呢，因为数据倒换都是在晚上凌晨2~4点进行，此时操作人员最困，思维最迟钝，如果你做的数据倒换工具需要操作七七四十九大步，九九八十一小步，而只要一步出错就全部重来，那么谁敢去操作？</p>
<p>==Where==<br>这个事和地点相关的环境信息，常见的地点信息有：<br>1） 国家、地区：不同的国家和地区有不同的文化、风俗、制度等；<br>2） 室内、室外、街道；<br>3） 建筑物</p>
<p>一个简单的例子：一个垃圾桶，放在室内就可能要求美观小巧（不占地方）；而放在室外就可能要求防晒、防雨、防风、防疯子，而且要求比较大。</p>
<p>==Who==<br>这是和参与者相关的，注意我这里用的是“参与者”来描述的，而不是说“人”，为什么呢？<br>因为很多外部参与者不一定是“人”，例如外系统、动物等都可以算作Who里面的。<br>常见的参与者信息有：<br>1） 投资者、管理者<br>2） 使用者、维护者<br>3） 监督者、评估者：例如政府机构、监管机构等<br>4） 其它系统</p>
<p>一个简单例子，银行的ATM机，参与者有如下几类：<br>顾客：使用ATM机器取款、存款；<br>银行维护人员：每天将钱放进ATM机器；<br>质检机构：根据XX法律对ATM机进行检查；</p>
<p>==What==<br>这个就是客户最终想要的输出。例如一个文档、一份报告、一个图片、一个系统等。<br>一般情况下，这也是我们看到的最原始的需求。</p>
<p>==Why==<br>这个就是客户遇到的问题、困难、阻碍等，也是客户提出需求的驱动力。<br>只要是客户觉得不爽的地方都是Why的范围。</p>
<p>【一个长颈鹿的实例：5W】<br>有一个建筑公司的需求分析人员收到了一个客户需求“给我建一栋很大的房子”，于是建筑公司就建了房子，房子是欧式风格，又大又宽敞，全套宜家家居，全木地板，进口电器。。。。。简直是应有尽有，结果客户来收房子的时候说了一句话，让建筑公司吐血，你知道是什么话么？<br>客户说：“先生们，我是要一栋房子给我们的长颈鹿住！”</p>
<p>因此即使是简单的一句话需求，我们也需要详细分析。例如：<br>Who：这套房子的购买者是动物园、管理者是动物园的饲养员、使用者是长颈鹿、评估者可能是动物管理协会、卫生局等政府部门”<br>When：这个可能要求一年四季了，如果长颈鹿知识运来展览一下，那么就是展览的这几个月。”<br>Where：这个房子要建在动物园，而不是其它居民小区，那么动物园肯定有一些相关的规定”<br>What：要求一套房子，但不是简单意义上的房子，而是长颈鹿住的房子，这就需要考虑高度、围栏等”<br>Why： 这个就可能动物园要临时展览，也可能要引进长颈鹿，也有可能是原来的长颈鹿房子破旧了”</p>
<p>虽然我们前面讲的时候，5W都是一视同仁的，但实际上有一个W是非常关键的，如果这个W错了，那么即使其它4W全部正确，也可能导致最后没有满足客户需求，客户不满意。</p>
<p>这个最关键的W就是Why，因为只有真正了解了客户的需求驱动力，才能解决客户的问题，而只有解决了客户的问题，那么客户才会真正的满意。这也是我们前面提到的需求分析的终极目的是“挖掘客户的问题，实现客户价值”！</p>
<p>如下图形象的描绘了5W的关系：<br> <img src="http://ww3.sinaimg.cn/large/666cc9e3gw1f4970ak4ybj2055055t8r.jpg" alt=""></p>
<p>【1H】<br>H代表How，但具体是指什么How呢？</p>
<p>很多人常犯的一个错误是在需求分析阶段分析了需求如何实现，这样做是不正确的。需求分析阶段的How不是指如何实现需求，而是指需求本身的流程，如何实现需求那是设计阶段的事情！</p>
<p>你可能会有疑问：“需求本身还有什么流程”？</p>
<p>需求又简单和复杂之分，有的需求可能很简单，客户想要的东西也很明确；但有的需求比较复杂，涉及到多次交互，或者多个状态变化等，这种情况就要把需求的流程描述清楚。<br>举个例子吧，取款是一个需求，但取款本身包含多次交互，要插卡、输入密码、输入金额、打印账单、取钱这些步骤，How就是用来描述这整个流程是如何运行的。</p>
<p>说起来How很简单，但实际上这是需求分析工作量最大的一部分，How分析的结果是需求分析的主要输出，而且How分析的质量直接影响最后需求实现的质量。</p>
<p>在前面进行5W分析的时候，我们没有什么具体的指导方法，分析时主要靠分析人员的经验、水平，而How则不一样，进行How分析时有一套成熟的方法，这就是“用例方法”！我们将在后续章节详细介绍用例方法。</p>
<p>【8C】<br>8C指的是8个约束和限制（Constraintes），具体如下：<br>| 性能Performance<br>性能是指系统提供相应服务的效率。一般而言，性能主要包括响应时间、吞吐量。<br>性能是很多系统<a href="http://lib.csdn.net/base/16" target="_blank" rel="external">架构</a>设计的关键约束条件之一。例如，同样一个Web网站，虽然都是提供信息给用户流浪，但一个日访问量1万的网站，和日访问量10亿的网站，两者的设计是完全不一样的。</p>
<p>l 成本Cost<br>成本指为了实现系统而需要付出的代价。<br>成本也是很多系统架构设计的关键约束之一。例如，客户只愿意出100万来买这个系统，最后我们却设计了一个耗费1000万的系统，要么客户不愿买，要么我们自己亏损。无论哪种情况，最后都是我们赔本了。</p>
<p>l 时间Time<br>指客户要求什么时候交付。</p>
<p>l 可靠性Reliability<br>指系统长时间正确运行的能力，银行、证券、电信这些公司，对宕机时间要求很严格的</p>
<p>l 安全性Security<br>指对信息安全的保护能力，涉及到钱、身份证、社会保险号等需求对这个要求很高</p>
<p>l 合规性Compliance<br>指满足各种行业标准、法律法规、规范等，例如3C、SOX、3GPP、ITUT等</p>
<p>l 技术性Technology<br>有的客户可能要求我们采用某种技术，例如客户现在都是Windows的机器，那么就可能要求我们基于Windows平台开发</p>
<p>l 兼容性Compatibility<br>指我们的产品与系统与客户其它已有的产品或者系统的兼容能力，要知道现在很少有产品是孤立运行的，特别是在大企业、大公司中，多个系统都是互相交互、互相配合的。新的系统必须能够和已有的系统配合，否则将无法运行。</p>
<p>为什么我们要将这8个C单独列出来呢？</p>
<p>需求分为功能属性和质量属性，前面的5W+1H是属于功能属性，而8C是属于质量属性，一个需求最终是否被正确的实现了，既要看功能属性是否正确，也要看质量属性是否正确，两者缺一不可！ </p>
<p>例如，你做了一个超牛逼的系统，功能超级强大，但一个操作需要10分钟，你觉得这样的系统客户有耐心用么？</p>
<h1 id="第十八章-用例分析"><a href="#第十八章-用例分析" class="headerlink" title="第十八章 用例分析"></a>第十八章 用例分析</h1><p>很多人在分析需求的时候，采用的是东扯葫芦西扯瓢的方式，列出了很多的需求点，但当你看完后，你还是不知道到底要干嘛！！  —- 写在前面</p>
<p>用例，英文名称Use Case，英文和中文都是很好理解，因为大家都这么用，我们暂且不去追究名称上的问题，只要知道“用例是用来描述需求的流程”，即：<strong>描述5W1H中的How</strong>。</p>
<p>看起来用例应该很好写，因为用例是描述需求的流程的，而需求的流程一般都是客户根据自己的业务总结出来，然后告诉我们的。我们只要将客户描述的内容记录下来即可，既简单又轻松！</p>
<p>但现实与理想总是有差距的，你可能会遇到一个对业务并不十分熟悉的客户，又或者和你交流的人员是客户的临时工，还有可能和你交流的人马上要休婚假了，他巴不得赶快了结这个无聊的事。。。。。。总之，各种各样的情况都可能出现，就是完美的情况不会出现！</p>
<p>这种情况下，我们如何才能做到完善的分析呢？我们怎么知道我们的分析是否正确，是否有遗漏，是否足够了？</p>
<p>一般的情况下，公司里负责需求分析得人员都是资深的员工，对领域、对系统有一定的积累和经验，即使面对这些情况，也可以通过自己的经验来弥补。</p>
<p>但对于一个菜鸟，遇到这种情况应该怎么办呢？难道菜鸟就不能做需求分析了么？</p>
<p>别慌，菜鸟虽然没有经验，但只要掌握正确的方法，一样可以做出很好的需求分析，这就是我总结的用例三部曲方法，又或叫做NEA方法。</p>
<p>我总结出的用例方法三段法（NEA方法）：<br>1） 正常处理（Normal）：通过和客户沟通，分析需求的正常流程；<br>2） 异常处理（Exception）：在正常处理流程的步骤上，分析每一步的各种异常情况和对应的处理；<br>3） 替代处理（Alternative）：在正常处理流程的步骤上，分析每一步是否有其它替代方法，以及替代方法如何做；</p>
<p>经过这简单三步后，How可以说分析得八九不离十了。<br>【用例的具体写法】<br>前面我们学习了518需求分析方法，而一个完整的用例，正好体现了518需求分析方法中涉及的内容。<br>一个完整的用例应该包含如下几个部分：<br>【用例名称】<br>一般情况下，用例的名称即需求的名称。<br>【场景】<br>场景即用例发生的环境，正好对应5W中的3个W：Who、Where、When<br>【用例描述】<br>描述详细的用例内容，对应5W中的What和How，即用户应该怎样做，以及每个步骤中的输出。但并不要求每个步骤都一定有输出，可以有也可以没有，也可以有多个。<br>【用例价值】<br>描述用例对应的客户价值，对应5W中的Why。<br>【约束和限制】<br>即整个需求流程中相关的约束和限制条件，对应518方法中的8C。</p>
<p>我们来看一个简单的样例：POS机。<br><strong>【第一步：正常处理】</strong><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">【用例名称】</span><br><span class="line">买单</span><br><span class="line">【场景】</span><br><span class="line">Who：顾客、收银员</span><br><span class="line">Where：商店的收银台</span><br><span class="line">When：营业时间</span><br><span class="line">【用例描述】</span><br><span class="line"><span class="bullet">1. </span>顾客携带选择好的商品到收银台；</span><br><span class="line"><span class="bullet">2. </span>收银员逐一扫描商品条形码，系统根据条形码查询商品信息；</span><br><span class="line"><span class="bullet">3. </span>扫描完毕，系统显示商品总额，收银员告诉顾客商品总额；</span><br><span class="line"><span class="bullet">4. </span>顾客将钱交给收银员；</span><br><span class="line"><span class="bullet">5. </span>收银员清点钱数，输入收到的款额，系统给出找零的数目；</span><br><span class="line"><span class="bullet">6. </span>收银员将找零的钱还给顾客，并打印小票；</span><br><span class="line"><span class="bullet">7. </span>买单完成，顾客携带商品和小票离开；</span><br><span class="line">【用例价值】</span><br><span class="line">顾客买完单以后，就可以携带商品离开，而超市也将得到收入；</span><br><span class="line">【约束和限制】</span><br><span class="line"><span class="bullet">1. </span>POS机必须符合国标XXX；</span><br><span class="line"><span class="bullet">2. </span>键盘使用中文，因为收银员都是中国人；</span><br><span class="line"><span class="bullet">3. </span>一次买单数额不能超过99999RMB；</span><br><span class="line"><span class="bullet">4. </span>POS机要非常稳定，至少一天内不要出现故障；</span><br></pre></td></tr></table></figure></p>
<p><strong>【第二步：异常处理】</strong><br>在第一步的基础上，我们增加相关步骤的异常情况说明和处理，例如如下的黑体字：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">【用例名称】</span><br><span class="line">买单</span><br><span class="line">【场景】</span><br><span class="line">Who：顾客、收银员</span><br><span class="line">Where：商店的收银台</span><br><span class="line">When：营业时间</span><br><span class="line">【用例描述】</span><br><span class="line"><span class="bullet">1. </span>顾客携带选择好的商品到收银台；</span><br><span class="line">（这一步没有异常）</span><br><span class="line"><span class="bullet">2. </span>收银员逐一扫描商品条形码，系统根据条形码查询商品信息；</span><br><span class="line">2.1 扫描仪坏了，必须支持手工输入条形码；</span><br><span class="line">2.2 <span class="strong">**商品的条形码无法扫描，必须支持手工输入条形码；**</span></span><br><span class="line">2.3 <span class="strong">**条形码能够扫描，但查询不到信息，需要收银员和顾客沟通，放弃购买此产品**</span></span><br><span class="line"><span class="bullet">3. </span>扫描完毕，系统显示商品总额，收银员告诉顾客商品总额；</span><br><span class="line">（这一步没有异常）</span><br><span class="line"><span class="bullet">4. </span>顾客将钱交给收银员；</span><br><span class="line">4.1 <span class="strong">**顾客的钱不够，顾客和收银员沟通，删除某商品**</span>；</span><br><span class="line">4.2 <span class="strong">**顾客的钱不够，顾客和收银员沟通，删除某类商品中的一个或几个（例如买了5包烟，去掉两包）**</span></span><br><span class="line">4.3 <span class="strong">**顾客觉得某个商品价格太高，要求删除某商品；**</span></span><br><span class="line"><span class="bullet">5. </span>收银员清点钱数，输入收到的款额，系统给出找零的数目；</span><br><span class="line">（这一步没有异常）</span><br><span class="line"><span class="bullet">6. </span>收银员将找零的钱还给顾客，并打印小票；</span><br><span class="line"><span class="bullet">7. </span>买单完成，顾客携带商品和小票离开；</span><br><span class="line">【用例价值】</span><br><span class="line">顾客买完单以后，就可以携带商品离开，而超市也将得到收入；</span><br><span class="line">【约束和限制】</span><br><span class="line"><span class="bullet">1. </span>POS机必须符合国标XXX；</span><br><span class="line"><span class="bullet">2. </span>键盘使用中文，因为收银员都是中国人；</span><br><span class="line"><span class="bullet">3. </span>一次买单数额不能超过99999RMB；</span><br><span class="line"><span class="bullet">4. </span>POS机要非常稳定，至少一天内不要出现故障；</span><br></pre></td></tr></table></figure></p>
<p>有的人可能会认为第3、第5、第6步都应该有异常，例如系统坏了应该怎么处理。<br>但实际上我们没有必要这么写，因为用例分析的目的是为了详细分析为了实现客户价值，系统应该怎么做，如果系统本身都坏了，这个就不是用例关注的内容了。</p>
<p>需要注意的是：用例分析中的“异常”是指流程的异常情况，而不包含系统本身的的异常。</p>
<p><strong>【第三步：替代处理】</strong><br>在第二步的基础上，我们增加替代处理。即：有的步骤可以换一种方式来实现。例如如下用例中的付款方式，可以有信用卡支付、会员卡支付、购物卡支付等。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">【用例名称】</span><br><span class="line">买单</span><br><span class="line">【场景】</span><br><span class="line">Who：顾客、收银员</span><br><span class="line">Where：商店的收银台</span><br><span class="line">When：营业时间</span><br><span class="line">【用例描述】</span><br><span class="line"><span class="bullet">1. </span>顾客携带选择好的商品到收银台；</span><br><span class="line">（这一步没有异常）</span><br><span class="line"><span class="bullet">2. </span>收银员逐一扫描商品条形码，系统根据条形码查询商品信息；</span><br><span class="line">2.1 扫描仪坏了，必须支持手工输入条形码；</span><br><span class="line">2.2 商品的条形码无法扫描，必须支持手工输入条形码；</span><br><span class="line">2.3 条形码能够扫描，但查询不到信息，需要收银员和顾客沟通，放弃购买此产品</span><br><span class="line"><span class="bullet">3. </span>扫描完毕，系统显示商品总额，收银员告诉顾客商品总额；</span><br><span class="line">（这一步没有异常）</span><br><span class="line"><span class="bullet">4. </span>顾客将钱交给收银员；</span><br><span class="line">4.1 顾客的钱不够，顾客和收银员沟通，删除某商品；</span><br><span class="line">4.2 顾客的钱不够，顾客和收银员沟通，删除某类商品中的一个或几个（例如买了5包烟，去掉两包）</span><br><span class="line">4.3 顾客觉得某个商品价格太高，要求删除某商品；</span><br><span class="line">4-A：<span class="strong">**顾客使用信用卡支付**</span></span><br><span class="line">4-A.1 信用卡支付流程（请读者自行思考完善，可以写在这里，如果太多，也可以另外写一个子用例）</span><br><span class="line">4-B：<span class="strong">**顾客使用购物卡支付**</span></span><br><span class="line">        4-B.1 购物卡支付流程</span><br><span class="line">4-C：<span class="strong">**顾客使用会员卡积分支付**</span></span><br><span class="line">        4-C.1 会员卡积分支付流程</span><br><span class="line"><span class="bullet">5. </span>收银员清点钱数，输入收到的款额，系统给出找零的数目；</span><br><span class="line">（这一步没有异常）</span><br><span class="line"><span class="bullet">6. </span>收银员将找零的钱还给顾客，并打印小票；</span><br><span class="line"><span class="bullet">7. </span>买单完成，顾客携带商品和小票离开；</span><br><span class="line">【用例价值】</span><br><span class="line">顾客买完单以后，就可以携带商品离开，而超市也将得到收入；</span><br><span class="line">【约束和限制】</span><br><span class="line"><span class="bullet">1. </span>POS机必须符合国标XXX；</span><br><span class="line"><span class="bullet">2. </span>键盘使用中文，因为收银员都是中国人；</span><br><span class="line"><span class="bullet">3. </span>一次买单数额不能超过99999RMB；</span><br><span class="line"><span class="bullet">4. </span>POS机要非常稳定，至少一天内不要出现故障；</span><br></pre></td></tr></table></figure>
<p>经过上面步步为营，逐步细化和求精，我们已经得到了一个比较完善的需求了，这个过程中并没有高深的技巧，也没有涉及需要丰富的经验。</p>
<p>有的读者可能会有疑问：我怎么知道第4步有那些异常、那些替代方案呢？<br>其实很简单：问你的客户！客户是最清楚了，但如果你不问，嘿嘿，客户倒不一定会告诉你：）</p>
<p>但只要我们掌握了NEA用例分析方法，即使客户忘记了，或者没有意识到，我们也会将需求挖出来，这样需求就不会遗漏。</p>
<p>【要画图么？】<br>大家可以看到，我们在前面进行用例分析的时候，并没有看到任何图，而是纯文本！</p>
<p>对于那些UML狂热分子来说，这可能是难以接受的，怎么能没有图呢？UML中的用例图不就是用来分析需求的么？</p>
<p>我们当然不怀疑UML的权威性，但任何东西都有局限性，UML也不例外。UML的局限就在于UML是一个建模的语言，就像汉语、英语一样，只是一种表达形式，而不是一种分析和创作方式。</p>
<p>比如说你会汉语，但并不代表你就能写小说，你会画UML用例图，但并不代表你就能做需求分析。相反，必须是有了需求和用例之后，才有用例图，说白了，用例图是用例的图形化描述，但是它并不能取代用例。</p>
<p>除了UML本身的局限性外，还有另外一个更重要的原因：用例是客户和公司关于产品的一个共同认识！一般情况下，市场人员和客户沟通交流，了解客户的需求，然后和客户一一确认，最后形成需求文档。在这个过程中，主要是客户和市场人员参与，而没有研发的人员参与。</p>
<p>对于客户来说，他肯定是以自然语言，而不会用UML来描述需求；对于市场人员来说也一样，他可能对UML一窍不通，甚至他以前可能都是卖医疗器械，甚至有可能是狗皮膏药的，他还管你什么软件工程，什么UML？</p>
<p>所以，采用用例方法分析需求的时候，我们都是采用纯文本来描述需求的，而不会采用用例图来分析需求</p>
<h1 id="第十九章-功能点提取"><a href="#第十九章-功能点提取" class="headerlink" title="第十九章 功能点提取"></a>第十九章 功能点提取</h1><p>完成了用例之后，需求分析的工作基本上已经完成，接下来我们需要趁热打铁，完成另外一个事情：<strong>提取功能点</strong>！</p>
<p>有了用例之后，提取功能可以说是一个水到渠成的事情，基本上只是一个文字工作，我们只需要将用例中那些需要系统完成的事情——更简单的说：是动词——提取出来，就成为了系统的功能。</p>
<p>以前面的POS机为例，我们看看如何提取功能，如下<strong>粗体</strong>字即为提取的功能：<br> <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">【用例名称】</span><br><span class="line">买单</span><br><span class="line">【场景】</span><br><span class="line">Who：顾客、收银员</span><br><span class="line">Where：商店的收银台</span><br><span class="line">When：营业时间</span><br><span class="line">【用例描述】</span><br><span class="line">1. 顾客携带选择好的商品到收银台；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">2. 收银员逐一*<span class="strong">*扫描商品条形码*</span><span class="strong">*，系统根据条形码*</span><span class="strong">*查询商品信息*</span><span class="strong">*；</span><br><span class="line">2.1 扫描仪坏了，必须支持*</span><span class="strong">*手工输入条形码*</span><span class="strong">*；</span><br><span class="line">2.2 商品的条形码无法扫描，必须支持*</span><span class="strong">*手工输入条形码*</span><span class="strong">*；</span><br><span class="line">2.3 条形码能够扫描，但查询不到信息，需要收银员和顾客沟通，放弃购买此产品</span><br><span class="line">3. 扫描完毕，系统*</span><span class="strong">*计算商品总额并显示*</span><span class="strong">*，收银员告诉顾客商品总额；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">4. 顾客将钱交给收银员；</span><br><span class="line">4.1 顾客的钱不够，顾客和收银员沟通，*</span><span class="strong">*删除某商品*</span><span class="strong">*；</span><br><span class="line">4.2 顾客的钱不够，顾客和收银员沟通，*</span><span class="strong">*删除某类商品中的一个或几个*</span><span class="strong">*（例如买了5包烟，去掉两包）</span><br><span class="line">4.3 顾客觉得某个商品价格太高，要求*</span><span class="strong">*删除某商品*</span><span class="strong">*；</span><br><span class="line">4-A：顾客使用信用卡支付</span><br><span class="line">4-A.1 信用卡支付流程（请读者自行思考完善，可以写在这里，如果太多，也可以另外写一个子用例）</span><br><span class="line">4-B：顾客使用购物卡支付</span><br><span class="line">        4-B.1 购物卡支付流程</span><br><span class="line">4-C：顾客使用会员卡积分支付</span><br><span class="line">        4-C.1 会员卡积分支付流程</span><br><span class="line">5. 收银员清点钱数，*</span><span class="strong">*输入收到的款额*</span><span class="strong">*，系统*</span><span class="strong">*给出找零的数目*</span><span class="strong">*；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">6. 收银员将找零的钱还给顾客，并*</span><span class="strong">*打印小票*</span><span class="strong">*；</span><br><span class="line">7. 买单完成，顾客*</span><span class="strong">*携带*</span><span class="strong">*商品和小票*</span><span class="strong">*离开*</span><span class="strong">*；</span><br><span class="line">【用例价值】</span><br><span class="line">顾客买完单以后，就可以携带商品离开，而超市也将得到收入；</span><br><span class="line">【约束和限制】</span><br><span class="line">1. POS机必须符合国标XXX；</span><br><span class="line">2. 键盘使用中文，因为收银员都是中国人；</span><br><span class="line">3. 一次买单数额不能超过99999RMB；</span><br><span class="line">4. POS机要非常稳定，至少一天内不要出现故障；</span></span><br></pre></td></tr></table></figure></p>
<p>我们将提取的功能列出来：</p>
<table>
<thead>
<tr>
<th style="text-align:center">功能编号</th>
<th style="text-align:center">功能描述</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">001</td>
<td style="text-align:center">扫描商品条形码</td>
<td style="text-align:center">NA</td>
</tr>
<tr>
<td style="text-align:center">002</td>
<td style="text-align:center">手工输入条形码</td>
<td style="text-align:center">在用例的几个步骤中有体现</td>
</tr>
<tr>
<td style="text-align:center">003</td>
<td style="text-align:center">删除某商品</td>
<td style="text-align:center">在用例的几个步骤中有体现</td>
</tr>
<tr>
<td style="text-align:center">004</td>
<td style="text-align:center">删除某类商品中的一个或几个</td>
<td style="text-align:center">NA</td>
</tr>
<tr>
<td style="text-align:center">005</td>
<td style="text-align:center">顾客使用信用卡支付</td>
<td style="text-align:center">这三个功能点比较大，如有需要，可以继续拆分。</td>
</tr>
<tr>
<td style="text-align:center">006</td>
<td style="text-align:center">顾客使用购物卡支付</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">007</td>
<td style="text-align:center">顾客使用会员卡积分支付</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">008</td>
<td style="text-align:center">计算找零的数目</td>
<td style="text-align:center">用例中是“给出”，对应系统功能是我们改为“计算”，因为这更加符合计算机的描述术语。</td>
</tr>
<tr>
<td style="text-align:center">009</td>
<td style="text-align:center">打印小票</td>
<td style="text-align:center">NA</td>
</tr>
</tbody>
</table>
<p>注意用例中可能同一个功能在不同的步骤中出现了多次（例如“手工输入条形码”、“删除某商品”），最后提取的时候要合并。</p>
<p>除了同一用例中某些功能要合并外，不同的用例中相同的功能也需要合并，我们以ATM机为例：</p>
<table>
<thead>
<tr>
<th style="text-align:center">功能编号</th>
<th style="text-align:center">功能描述</th>
<th style="text-align:center">涉及用例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">001</td>
<td style="text-align:center">银行卡验证</td>
<td style="text-align:center">取款、存款、查询余额</td>
</tr>
<tr>
<td style="text-align:center">002</td>
<td style="text-align:center">密码验证</td>
<td style="text-align:center">取款、存款、查询余额</td>
</tr>
<tr>
<td style="text-align:center">003</td>
<td style="text-align:center">点钞</td>
<td style="text-align:center">取款、存款</td>
</tr>
<tr>
<td style="text-align:center">004</td>
<td style="text-align:center">验钞</td>
<td style="text-align:center">存款</td>
</tr>
<tr>
<td style="text-align:center">005</td>
<td style="text-align:center">打印交易清单</td>
<td style="text-align:center">取款、存款</td>
</tr>
</tbody>
</table>
<p>有的同学可能会问：有了用例后，为什么还要将功能点单独提取出来呢？直接看用例不就可以了么？<br>这个问题要从多方面来回答：<br>首先，从美学的角度来看，看一个功能列表的表格，肯定比看一长篇用例文档，然后在脑袋里组织功能列表要方便很多；</p>
<p>其次，从项目管理的角度来看，功能列表更易于管理，例如任务分配时不可能基于用例进行分配的，因为不同用例间可能存在大量重复的功能点；</p>
<p>再次，从开发角度来说，开发是基于功能点的，而不是基于用例的；<br>最后，从测试的角度来说，虽然最后的验收测试是基于用例的，但产品测试主要还是基于功能点进行测试的</p>
<h1 id="第二十章-用例图的陷阱"><a href="#第二十章-用例图的陷阱" class="headerlink" title="第二十章 用例图的陷阱"></a>第二十章 用例图的陷阱</h1><p>你知道么，用例图 <strong>不是</strong> 用来描述 用例的哦！！！！</p>
<p>熟悉UML的朋友都肯定知道，UML有一个叫做用例图的东东。<br>单纯从名字上来看，你可能以为用例图是用来描述用例的，即：用例图 = 用例的图形化表示。</p>
<p>然而各位发明ＵＭＬ的大师们，却在无意中给我们设下了一个陷阱：所谓的用例图，不是用来描述用例，而是用来描述系统的图形。</p>
<p>听起来有点奇怪和别扭，既然是用来描述系统的图形，为什么叫做用例图，而不叫系统图呢？</p>
<p>这和用例图的画法有关，用例图虽然是用来描述系统的图形，但其内容主要就是用例。<br>我们来看用例图的定义：</p>
<blockquote>
<p>The use case view captures the behavior of a system, subsystem, or class as it appears to an outside user</p>
</blockquote>
<p>简单翻译一下：用例图用于捕获系统、子系统或者类相关的呈现给外部用户的行为。</p>
<p>单纯看这个定义有点难以理解，其实看看用例图的组成就很简单了。用例图的组成如下：<br>Actor：系统外的用户，对应5W中的Who，包括但不限于用户、外系统；<br>Use Case：用例，对应前面讲到的用例；<br>System：系统，所有用例的集合就是系统了。</p>
<p>我们以ATM取款机为样例，用例图如下：<br> <img src="http://ww3.sinaimg.cn/large/666cc9e3gw1f4970wn1e4j20h2097t8z.jpg" alt=""></p>
<p>从这个图可以清楚的看到，所谓用例图，可以简单的<strong>理解为系统用例的集合</strong>，而不是详细描述每个用例的具体步骤和流程。<br>这也是前面我们提到的为什么是用“用例”来分析需求，而不是用“用例图”来分析需求的原因</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[连载：面向对象葵花宝典：思想、技巧与实践(1-10章)]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/05/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B81.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>无意间发现这篇文章，文章讲解由浅入深，读完后感触很深<br>特全文转到自己的博客，方便以后自己随时查看<br>文章转载自爱技术的华仔的博客[<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">http://blog.csdn.net/yunhua_lee</a>]<br>非常感谢<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">爱技术的华仔</a></p>
</blockquote>
<h1 id="第一章-程序设计思想的发展"><a href="#第一章-程序设计思想的发展" class="headerlink" title="第一章 程序设计思想的发展"></a>第一章 程序设计思想的发展</h1><p><strong>史前时代：面向机器</strong><a id="more"></a><br>最早的程序设计都是采用机器语言来编写的，直接使用二进制码来表示机器能够识别和执行的指令和数据。简单来说，就是直接编写0和1的序列来代表程序语言。例如：使用0000 代表 加载（LOAD），0001 代表 存储（STORE）等。 </p>
<p>机器语言由机器直接执行，速度快，但一个很明显的缺点就是：写起来实在是太困难了，一旦你发现自己写错了，改起来更蛋疼！这样直接导致程序编写效率十分低下，编写程序花费的时间往往是实际运行时间的几十倍或几百倍。<br>有一个关于机器语言和比尔盖茨的笑话，是说比尔盖茨拿着绣花针在一张光盘上戳，把Windows给戳出来了！但如果真的让你去戳，不要说Windows，连一个简单的“Hello world”都要让人戳到眼睛冒烟！ </p>
<p>由于机器语言实在是太难编写了，于是就发展出了汇编语言。汇编语言亦称符号语言，用助记符代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址，。汇编语言由于是采用了助记符号来编写程序，比用机器语言的二进制代码编程要方便些，在一定程度上简化了编程过程。例如使用LOAD 来代替 0000，使用STORE来代替0001。 </p>
<p>即使汇编语言相比机器语言提升了可读性，但其本质上还是一种面向机器的语言，编写同样困难，也很容易出错。相信很多计算机毕业的学生至今都对学校的汇编课程中的练习程序心有余悸。 </p>
<p><strong>脱离机器第一步：面向过程</strong><br>面向机器的语言通常情况下被认为是一种“低级语言”，为了解决面向机器的语言存在的问题，计算机科学的前辈们又创建了面向过程的语言。面向过程的语言被认为是一种“高级语言”，相比面向机器的语言来说，面向过程的语言已经不再关注机器本身的操作指令、存储等方面，而是关注如何一步一步的解决具体的问题，即：解决问题的过程，这应该也是面向过程说法的来由。 </p>
<p>相比面向机器的思想来说，面向过程是一次思想上的飞跃，将程序员从复杂的机器操作和运行的细节中解放出来，转而关注具体需要解决的问题；面向过程的语言也不再需要和具体的机器绑定，从而具备了移植性和通用性；面向过程的语言本身也更加容易编写和维护。这些因素叠加起来，大大减轻了程序员的负担，提升了程序员的工作效率，从而促进了软件行业的快速发展。 </p>
<p>典型的面向过程的语言有：COBOL、FORTRAN、BASIC、C语言等。</p>
<p><strong>第一次软件危机：结构化程序设计</strong><br>随着计算机硬件的飞速发展，以及应用复杂度越来越高，软件规模越来越大，原有的程序开发方式已经越来越不能满足需求了。1960年代中期开始爆发了第一次软件危机，典型表现有软件质量低下、项目无法如期完成、项目严重超支等，因为软件而导致的重大事故时有发生。例如1963年美国（<a href="http://en.wikipedia.org/wiki/Mariner_1）" target="_blank" rel="external">http://en.wikipedia.org/wiki/Mariner_1）</a> 的水手一号火箭发射失败事故，就是因为一行FORTRAN代码错误导致的。 </p>
<p>软件危机最典型的例子莫过于IBM的System/360的操作系统开发。佛瑞德·布鲁克斯（Frederick P. Brooks, Jr.）作为项目主管，率领2000多个程序员夜以继日的工作，共计花费了5000人一年的工作量，写出将近100万行的源码，总共投入5亿美元，是美国的“曼哈顿”原子弹计划投入的1/4。尽管投入如此巨大，但项目进度却一再延迟，软件质量也得不到保障。布鲁克斯后来基于这个项目经验而总结的《人月神话》一书，成了史上最畅销的软件工程书籍。<br>为了解决问题，在1968、1969年连续召开两次著名的NATO会议，会议正式创造了“软件危机”一词，并提出了针对性的解决方法“软件工程”。虽然“软件工程”提出之后也曾被视为软件领域的银弹，但后来事实证明，软件工程同样无法解决软件危机。 </p>
<p>差不多同一时间，“结构化程序设计”作为另外一种解决软件危机的方案被提出来了。 Edsger Dijkstra 于1968发表了著名的《GOTO有害论》的论文，引起了长达数年的论战，并由此产生了结构化程序设计方法。同时，第一个结构化的程序语言Pascal也在此时诞生，并迅速流行起来。<br>结构化程序设计的主要特点是抛弃goto语句，采取“自顶向下、逐步细化、模块化”的指导思想。结构化程序设计本质上还是一种面向过程的设计思想，但通过“自顶向下、逐步细化、模块化”的方法，将软件的复杂度控制在一定范围内，从而从整体上降低了软件开发的复杂度。结构化程序方法成为了1970年代软件开发的潮流。 </p>
<p>科学研究证明，人脑存在人类短期记忆一般一次只能记住5-9个事物，这就是著名的 7+- 2原理。结构化程序设计是面向过程设计思想的一个改进，使得软件开发更加符合人类思维的7+-2特点。</p>
<p><strong>第二次软件危机：面向对象程序设计</strong><br>结构化编程的风靡在一定程度上缓解了软件危机，然而好景不长，随着硬件的快速发展，业务需求越来越复杂，以及编程应用领域越来越广泛，第二次软件危机很快就到来了。 </p>
<p>第二次软件危机的根本原因还是在于软件生产力远远跟不上硬件和业务的发展，相比第一次软件危机主要体现在“复杂性”，第二次软件危机主要体现在“可扩展性”、“可维护性”上面。传统的面向过程（包括结构化程序设计）方法已经越来越不能适应快速多变的业务需求了，软件领域迫切希望找到新的银弹来解决软件危机，在这种背景下，面向对象的思想开始流行起来。 </p>
<p>面向对象的思想并不是在第二次软件危机后才出现的，早在1967年的Simula语言中就开始提出来了，但第二次软件危机促进了面向对象的发展。 面向对象真正开始流行是在1980s年代，主要得益于C++的功劳，后来的Java、C#把面向对象推向了新的高峰。到现在为止，面向对象已经成为了主流的开发思想。 </p>
<p>虽然面向对象开始也被当做解决软件危机的银弹，但事实证明，和软件工程一样，面向对象也不是银弹，而只是一种新的软件方法而已。 </p>
<p>虽然面向对象并不是解决软件危机的银弹，但和面向过程相比，面向对象的思想更加贴近人类思维的特点，更加脱离机器思维，是一次软件设计思想上的飞跃。</p>
<h1 id="第二章-面向对象语言发展历史"><a href="#第二章-面向对象语言发展历史" class="headerlink" title="第二章 面向对象语言发展历史"></a>第二章 面向对象语言发展历史</h1><p><strong>Simula </strong><br>面向对象技术最早是在编程语言Simula中提出的。1967年5月20日，在挪威奥斯陆郊外的小镇莉沙布举行的IFIP TC-2 工作会议上，挪威科学家Ole-Johan Dahl和Kristen Nygaard正式发布了Simula 67语言。Simula 67被认为是最早的面向对象程序设计语言，是面向对象的开山祖师，它引入了所有后来面向对象程序设计语言所遵循的基础概念：对象、类、继承，但它的实现并不是很完整。<br>Simula虽然最早提出面向对象的概念，但因为其本身复杂，比较难学，而并没有大规模流行。但Simula提出的面向对象的概念对程序语言后继的发展产生了巨大和深远的影响。</p>
<p><strong>Smalltalk</strong><br>Smalltalk是公认为历史上第二个面向对象的程序语言，而且是第一个完整实现了面向对象技术的语言。<br>最早的Smalltalk原型由艾伦·凯于70年代初提出。类（来自Simula-67）、海龟绘图（来自MIT的LOGO）以及图形界面等概念的有机组合，构成了Smalltalk的最初的蓝图。在1971年到1975年之间，艾伦·凯在Xerox PARC的小组设计并实现了第一个真正的Smalltalk语言系统。<br>Smalltalk引领了面向对象的设计思想的思潮，对其它众多的程序设计语言的产生起到了极大的推动作用。C++，C#，Objective-C，Actor，Java和Ruby等，无一不受到Smalltalk的影响，这些程序语言中也随处可见Smalltalk的影子。<br>除了编程语言受到Smalltalk的影响外，90年代的许多软件开发思想得利于Smalltalk，例如设计模式、敏捷编程和代码重构等。</p>
<p><strong>C++</strong><br>C++是第一个大规模使用的面向对象语言，面向对象程序设计在80年代成为了一种主导思想，这很大程度上得益于C++的流行。而且与Simula、Smalltalk不同的是，C++到现在为止还是排名前三的编程语言，并没有湮没在历史的洪流中。<br>C++由贝尔实验室的Bjarne Strou-strup与1983年推出，C++进一步扩充和完善了C语言，成为一种面向 对象的程序设计语言。<br>C++最开始的时候不是叫做C++，而是C with class，这是把它当作一种C语言的有效扩充。由于当时C语言在编程界居于老大的地位，要想发展一种新的语言，最强大的竞争对手就是C语言，所以当时有两个问题最受关注：C++要在运行时间、代码紧凑性和数据紧凑性方面能够与C语言相媲美，但是还要尽量避免在语言应用领域的限制。在这种情况下，一个很自然的想法就是让C++从C语言继承过来，但如果只是简单继承的话，就不能有所突破了，因此Bjarne博士采取了拿来主义，参考了很多的语言，将它们的优点“继承”过来了。例如：从Simula继承了类的概念，从Algol68继承了运算符重载、引用以及在任何地方声明变量的能力，从BCPL获得了//注释，从Ada得到了模板、名字空间，从Ada、Clu和ML取来了异常。<br>正是因为C++兼容C，同时又具备了面向对象的能力，使得C++能够大行其道，广受欢迎；然而也正是C++是一个超级大杂烩，语言本身很复杂，导致针对C++存在很多批评和争议。有一个玩笑是说：Bjarne Strou-strup发明C++语言的时候就没有指望任何一个程序员能够完全掌握C++！</p>
<p><strong>Java</strong><br>Java是目前使用最广的面向对象编程语言，拥有全球最多的开发者，常年稳居开发语言排行榜第一名（偶尔和C交换一下位置）。如果说C++促进了面向对象的流行，那么Java就将面向对象推上了王座。比尔盖茨曾这样评价“Java是很长时间以来最优秀的程序设计语言”。<br>Java是由Sun Microsystems公司于 1995年5月推出，由“Java之父”James Gosling和一群技术天才创造，并在1995年正式推出。最初的Java被称为Oak —— 以Gosling办公室外的一棵橡树命名，后来由于商标版权问题，改名为Java —— 据说取名的灵感来自印尼爪哇岛味道优美的咖啡。<br>Sun 公司在推出 Java 之际就将其作为一种开放的技术，并且定位于互联网应用。因此随着互联网的发展和流行，加上开源运动的发展，Java逐渐成为了最流行的编程语言。<br>相比C++来说，Java语言是一个更加纯净、更加易用的面向对象编程语言。Java语言的编程风格和C++比较相似，但去掉了很多C++中复杂和容易出错的特性，例如指针，多继承等，同时增加了垃圾回收等大大提升生产率的特性。Sun公司对Java语言的解释是：“Java编程语言是个简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言”，虽然有点王婆卖瓜的味道，但Java针对C++的改进，确实大大提升了生产力，降低了复杂度，客观上也促进了Java的流行。</p>
<h1 id="第三章-面向过程-vs-面向对象"><a href="#第三章-面向过程-vs-面向对象" class="headerlink" title="第三章 面向过程 vs 面向对象"></a>第三章 面向过程 vs 面向对象</h1><h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><p>在介绍面向对象之前，我们首先要介绍“面向过程“，首先是因为”面向过程“是软件思想中的鼻祖；其次是因为只有了解了面向过程，你才能更好的了解面向对象！正所谓：知己知彼百战百胜！<br>面向过程是一种以“过程”作为中心的编程思想，其中过程的含义就是“完成一件事情的步骤”。<br>面向过程其实是一种“机械的思想”，它就像流水线一样，一个阶段衔接一个阶段，每个阶段都有自己的输入、处理、输出，而在流水线上流动的就是我们的原料或者中间产品，每个阶段都有一个机械进行处理，最后的输出就是我们的产品。<br> 在运用面向过程的方法时，你也需要设计这样一条程序流水线：将程序划分为不同的阶段，设计好各个阶段如何衔接，然后定义好每个阶段需要处理的数据。<br>但凡学过编程的都知道这么一个说法：程序=[算法]+ [数据结构]，这个总结其实正好契合了机械化的特征，“算法”=“流水线”，“数据结构”= “原料/中间产品”，“程序”= “产品”。<br>面向过程的这种特征其实是和计算机的本质相关的，计算机本质上是一台机器，其核心-CPU处理的是指令流水，简单点说就是01串，要让计算机跑起来，按照CPU的特点进行思考和处理是理所当然的。<br>即使我们使用面向对象的语言进行开发，最后转换为CPU能执行的指令，还是面向过程的，所以说，面向过程无处不在，是计算机的基石。<br>如下图片是啤酒生产线的全流程图，形象的说明了面向过程的处理方式：<br><img src="http://ww3.sinaimg.cn/large/666cc9e3gw1f496fheabmj20jg0c90to.jpg" alt=""></p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象是一种以“对象”作为中心的编程思想，其中对象的含义可以理解为“存在的东西”。<br>与面向过程的方法相比，面向对象不再局限于计算机的机器本质，而更加侧重于对现实世界的模拟。面向过程的方法中，有一套设计严格的操作顺序，有一个类似中央控制器的角色来进行统一调度；而面向对象的方法中，并没有明确的中央控制的角色，也不需要指定严格的操作顺序，而是设计了很多对象，并且指定了这些对象需要完成的任务，以及这些对象如何对外界的刺激做出反应。<br>如果说面向过程像一条流水生产线，那么面向对象就像是一个足球队。没有哪个人能够在一场比赛开始的时候，就精确指定每个队员的每一次跑动，每一次出脚，每一次传球。。。。。。而只能指定队员的角色（前锋、中场、后卫、门将），然后由队员门自己根据情况做出反应。所以世界上有两个一样的生产线，但绝对不会存在两场一模一样的比赛。<br>面向对象这种对现实世界的模拟的思想，其本质上就是“人的思想”，这是一个质的飞跃，意味着程序员可以按照人的思想来观察、分析、设计系统。<br>什么叫做“人的思想”？你可以放下书本，关上电脑，站起来，环顾四周，你看到的是什么？可能是你的同事、桌子、墙、电脑、花盆；或者是电话、窗子、书本。。。。。。怎么样，这些都是“对象”吧？除了观察目标聚焦于“对象”外，当我们观察人类世界各种事情的运作的时候，我们也不知不觉的聚焦于“对象”。例如，一个公司的运作，由董事长、经理、主管、员工等人分工合作，根据不同的任务或者外界竞争而去做各种各样的事情。<br>人大部分的时间都是按照面向对象的方式进行思考的，而且人类世界主要也是按照面向对象的方式进行运转的，所以说，“面向对象”其实更加符合人的思维习惯。<br>面向过程中有“程序=算法+数据结构”的经典总结，面向对象也有类似的总结：“程序=对象 + 交互”。其中对象就是具体存在的事物，而交互则是事物之间的相互作用、互动等。<br>如下是一张医院的组织结构图，形象的说明了面向对象的处理方式：<br><img src="http://ww2.sinaimg.cn/large/666cc9e3gw1f496gvb9j0j20in0b43zb.jpg" alt=""></p>
<h1 id="第四章-面向对象是瑞士军刀还是一把锤子？"><a href="#第四章-面向对象是瑞士军刀还是一把锤子？" class="headerlink" title="第四章 面向对象是瑞士军刀还是一把锤子？"></a>第四章 面向对象是瑞士军刀还是一把锤子？</h1><h2 id="为什么要面向对象？"><a href="#为什么要面向对象？" class="headerlink" title="为什么要面向对象？"></a>为什么要面向对象？</h2><p>可以说，面向过程和计算机是如影随形的。从计算机诞生之日起，面向过程就是占据着主导地位的思想，即使到了现在，面向过程也是无处不在的，C语言、操作系统、协议栈、驱动系统，都是面向过程的代表。 </p>
<p>那为什么还会有面向对象的诞生并流行呢？当然是面向过程存在某些不足，如果面向过程足够好，谁还费心费力的去搞另外一套呢？ </p>
<p>前面我们提到，面向过程是一种机器的思想，我们以流水线作为类比，那么我们先抛开面向过程，来看看流水线有什么不足。<br>举个简单的流水线例子：啤酒生产流水线。啤酒生产流水线分为“洗瓶”，“灌装”，“压盖”，“杀菌”等几个阶段，这些阶段总体上来说对生产一瓶醋是差不多的，但是一条啤酒生产线能够生产醋么？应该是不行的，即使行，估计也要换一些东西，但是换了东西后，又不能生产啤酒了。<br>面向过程同样就有流水线的这个缺点，即：流程和原料相对固定，扩展比较麻烦。 </p>
<p>对于工业系统来说，流水线的缺点几乎可以微不足道，因为工业化讲究的是效率，而扩展性却不是那么重要，一旦一条生产线建成，至少需要运行几年，甚至运行十几年都有。<br>而对于软件系统来说，很难想象一个软件开发完成后，几年都不变，大部分的情况是，软件可能是1年扩展多次，甚至还没有开发完，客户新的需求又来了。 </p>
<p>在软件系统这种环境下，面向过程显得就比较吃力了，每次需求的变更，可能都要将流程的每个步骤、原料、中间产品都进行修改，这样的代价在软件系统中几乎是不可接受的，因为每次修改都需要对全系统改动一次，不但工作量上大大增加，同时风险也是大大增加。 </p>
<p>而面向对象正是为了解决面向过程的这个缺点儿诞生的，因此面向对象其实也不是什么复杂和玄妙的技术，面向对象思想的核心是“可扩展性”！<br>注：中文“可扩展性”对应英文有两种解释：extensibility 和 scalability，extensibility指系统需求变化后，能够比较容易的扩展以支持新需求；scalability指系统访问压力增加后，能够通过简单的增加更多硬件设备以支撑访问压力，又翻译为“可伸缩性”。 本文的可扩展性是指extensibility。</p>
<h2 id="面向对象应用范围"><a href="#面向对象应用范围" class="headerlink" title="面向对象应用范围"></a>面向对象应用范围</h2><p>能做什么？<br>既然面向对象思想的核心是“可扩展性”，那么其适用范围就显而易见了：经常变化的地方就是面向对象应用的地方。<br>对于软件系统来说，常见的可变的主要集中在客户需求部分，而不变的一般都是属于计算机系统的基础。<br>因此，操作系统、数据库、协议（TCP、3GPP等）这些并不适合面向对象大展身手，因为这些基础软件一般都比较稳定（相对稳定，并不是不变）。而对于企业应用、互联网等应用，需求经常变更，功能不断扩展，这正是面向对象大展身手的地方。</p>
<p>不能做什么？<br>下图是一个软件质量属性的全图：<br> <img src="http://ww4.sinaimg.cn/large/666cc9e3gw1f496hjtldrj20a40a3t9d.jpg" alt=""><br>大家可以看到，“可扩展性”只是软件质量属性中很小的一部分，其它的属性都不是面向对象能够解决的。<br>明白了面向对象的特点和适用范围，是应用面向对象的关键，经过前面的分析，我们知道，面向对象不是瑞士军刀，而只是一个普通的锤子而已，千万不要拿着锤子到处敲！</p>
<h1 id="第五章-面向对象迷思：面向对象导致性能下降？"><a href="#第五章-面向对象迷思：面向对象导致性能下降？" class="headerlink" title="第五章 面向对象迷思：面向对象导致性能下降？"></a>第五章 面向对象迷思：面向对象导致性能下降？</h1><p><strong> 面向对象会导致性能降低？</strong><br>这是一个在IT江湖流传已久的传说，很多对面向对象不甚了解、或者一知半解的人，每当需要抵触面向对象时，就会把这条“金科玉律”拿出来救驾！</p>
<p>更要命的是，每个相信这个传说的人都会举一个看起来很显而易见的例子：C和Java的对比！</p>
<p>你可以到网上搜索一大堆C和Java的性能对比，你自己也可以做一个简单的对比测试，我毫不怀疑测试结果肯定是C快，但这能证明面向对象导致性能降低么？</p>
<p>从语言层面来说，面向对象的语言肯定要比面向过程的语言性能要低一些，毕竟这是由处理机制决定的，就像不同的人的差别由基因决定一样，这个很难改变。</p>
<p>但在实际应用中，除了上一章我们提到的专有系统（操作系统、驱动、嵌入式），对一般的业务系统来说，无论是企业级应用、还是互联网应用、还是电信银行应用，无一例外的都是复杂的系统，这些系统要和存储系统（磁盘、磁带等）打交道、要通过网络进行交互、要访问数据库。。。。。。等等。</p>
<p>我们看一下常见的一些性能数据（量级数据，不一定精确）：<br>CPU： 每秒10亿次，性能是纳秒级<br>内存：每秒1000万次，每次请求时间是微秒级<br>磁盘：每次请求5ms，请求时间是毫秒级<br>网络（TCP）：每次网络交互2ms，请求时间是毫秒级<br>数据库：基本等于网络和磁盘之和，甚至更慢</p>
<p>从上面的数据我们可以看出，如果你的业务流程中涉及了磁盘、网络、数据库等操作，那么性能就一下子降到了毫秒级。</p>
<p>而对于大部分开发语言来说，语言本身的运行速度至少是内存级别的</p>
<p>试想一下，你的整个流程中，语言本身的处理占了微妙级的时间，而一次磁盘或者网络的时间是毫秒级时间，那么全流程来看，就算你把语言本身的处理速度提高了10倍，对整个流程来说，性能几乎没有影响。</p>
<p>例如：假设C语言全流程处理时间：10微秒（语言部分） +  5ms（磁盘操作） =  5.01ms<br>如果换成Java，那么处理时间变成：100微秒（语言部分） + 5ms（磁盘操作） = 5.1 ms<br>从这个简单的样例可以看出，语言本省性能的提升，对整个流程中性能提升几乎没有影响！！</p>
<p>因此，对于复杂的业务系统来说，性能的好坏是由设计来决定的，而不是由语言来决定的，更不会因为采用了面向对象而导致性能的降低！</p>
<h1 id="第六章-不要说你懂“类”"><a href="#第六章-不要说你懂“类”" class="headerlink" title="第六章 不要说你懂“类”"></a>第六章 不要说你懂“类”</h1><blockquote>
<p>方以类聚，物以群分——《周易 易传》。 </p>
</blockquote>
<p>类是面向对象领域里最基础的一个概念，也是面向对象分析和设计的基石。<br>然而，如此重要的一个概念，竟然很难找到深入的说明，绝大部分介绍面向对象的书籍或者资料基本上都是这么解释的：“类是一组对象的抽象”，这个解释看起来清晰明了，但实际上犯了一个逻辑上的错误：以未明确的概念来解释待明确的概念，什么是对象，什么是抽象，我们都还不知道，你却用这个概念来解释类？那当然看不懂了。<br>还有另外一个解释：类就是属性和方法的集合！甚至还会给出如下这样的样例：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Class</span> Person&#123;</span><br><span class="line"><span class="attribute">Int</span>  age;</span><br><span class="line"><span class="attribute">String</span>  name;</span><br><span class="line"><span class="attribute">Void</span> play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种解释深究一下，其实很容易发现其犯了本末倒置的错误：类是本，代码是末，只有清晰地掌握了类的概念，才能写出好的代码。否则，即使写出了代码，也是一堆烂代码。</p>
<p>那究竟何为类呢？<br>其实，抛开面向对象，抛开程序开发，即使在我们的现实世界中，类也是无处不在的：<br>古语云： 物以类聚，人以群分，这里的“类”，其实和面向对象中的“类”的逻辑含义并无不同。<br>我们的生物学将生物分为动物、植物、微生物等种类，这里的“类”，和面向对象中的类概念也是一致的。<br>因此，当我们在定义什么才是“类”的时候，其实完全不需要和面向对象扯上关系。简单来说，类就是一组相似事物的统称。<br>这个定义看起来再简单不过了，但为了避免在实践过程中设计不合理的类，我们还要深挖背后的玄机，玄机在哪里呢？</p>
<p>玄机就在定义里面，我们来认真分析一下定义：<br>首先：请看“一组”，思考一下为什么是“一组”，不是“一个”？<br>其次：请看“相似”，思考一下为什么是“相似”，不是“相同”？<br>最后：请看“统称”，思考一下为什么是“统称”，不是“名称”？<br>第一个玄机——“一组”：一组的玄机在于“多个“，单个事物无法成为类。<br>一个很简单的例子：“人“可以是一类，但“我”就不是一个类（那又是什么呢，请看后文分解？）<br>第二个玄机——“相似”：相似的玄机在于“比较像，但不完全相同”。<br>还是“人”这个例子：奥巴马和克林顿都是美国总统，都是人，有很多相似的地方，但他们两个绝对不是完全相同的。<br>第三个玄机——“统称”：统称的玄机在于“统”，也可以叫做“通称”，统称要能够概括这多个事物。<br>还是上一个例子：奥巴马和克林顿的统称可以为“人”、“男人”、“总统”，但不会统称为“奥巴马”，因为奥巴马是一个具体的人了。<br>类的定义玄机我们已经基本解读，看起来已经比较清晰了，但不要高兴太早，还有一个更大的玄机：我们怎么划分类？</p>
<p>一个很简单的问题：你和我是一类么？<br>。。。应该是：）<br>再一个简单的问题：你和猪是一类么？<br>你肯定会跳起来：我怎么和猪是一类呢？<br>但我要说，我们和猪确实是一类，我们都是“哺乳动物“。<br>再一个简单的问题：你和松树是一类么？<br>这次你可能学乖了：也是一类，都是“生物“。<br>。。。。。。<br>到这里你可能已经迷惑了“到底我和什么是一类“？<br>这个问题引出了类最重要的一个玄机：“如何定义类“？<br>其实答案就隐藏在我们前面的问题中：“只要有相似点的就是同一类“！<br>我和你都是一类，是因为我们都是“人“；<br>你和猪是一类，是因为都是“哺乳动物“；<br>你和树一类，是因为都是“生物“；<br>。。。。。。</p>
<p>但这样又引出另外一个问题：如果只要有相似点就是同一类，那么最后是不是只要用一个类“事物”或者“东西”就可以了呢，干嘛还用得着分那么多类么？<br>万法归一，所有的事物当然最后都可以归为一类（例如在Java中就有一个大一统的类Class），但这显然远远不能满足我们的要求，实际应用中我们肯定需要不同的、多种多样的类，那么具体如何操作呢？<br>有一句广告词可以很好的概括：角度决定看法！<br>也就是说：站在你的观察角度，能够看到相似点就是同一类！<br>当你观察人时，我和你是一类，但你和猪就不是一类了；<br>当你观察动物时，我、你、猪都是一类，但树就不是了；<br>当你观察生物时，我、你、猪、树都是一类<br>。。。。。。。<br><strong>所以最后我们总结一下如何划分类：站在你的观察角度，具有相似点的事物就是同一类！</strong></p>
<h1 id="第七章-“对象”新解"><a href="#第七章-“对象”新解" class="headerlink" title="第七章 “对象”新解"></a>第七章 “对象”新解</h1><p>有了“类”的清晰定义后，“对象”就比较容易理解了。<br><strong>对象就是一个具体的类，一个真实存在的类。</strong><br>前面我们提到面向对象是对现实世界的模拟，那么对象就是现实世界中存在的“物体”。</p>
<p>例如，“人”是一个类，我就是一个“人”的对象，你也是“人”的对象，奥巴马也是“人”的对象。。。。。。<br>又比如：你去国美买冰箱，但国美肯定没有一个单独叫做“冰箱”的东西卖给你，而是具体的某台海尔XX型号的冰箱、西门子XX型号的冰箱等。这里的“冰箱”就是一个类，而具体的“某台海尔XX型号冰箱”、“某台西门子XX型号冰箱”就是一个具体的对象。</p>
<p>但是，我们要继续深究一下：有了类，为什么还会有对象？“类”和“对象”各自的作用是什么？</p>
<p>我们知道，在人类出现以前，世界上就有各种各样的物体了，有恐龙、老虎、鳄鱼、松树、青草、石头、空气。。。。。等等，也就是说，真实存在的是对象，而“类”，是有了人类文明后，根据观察分析，加以归纳总结而的出来的。</p>
<p>在软件世界也是这样的，真正存在于软件运行过程中的是“对象”，而不是“类”，“类”只是在程序编写中由程序员分析归纳出来的。这也是面向对象之所以叫做“面向对象”而不是“面向类”的一个原因吧。</p>
<p>虽然我们前面定义对象为“一个具体的类”，但这是否意味着必须是先有类后有对象呢？<br>要回答这个问题，我们首先要澄清几个概念：现实对象、现实类、软件对象、软件类。</p>
<p>现实对象：你能看到的物体都可以称为现实对象；<br>现实类：对现实对象的归纳总结；<br>软件对象：软件实际运行过程中存在的对象；<br>软件类：软件设计过程中归纳总结出来的类；</p>
<p>定义看起来很简单，但它们的区别和联系是什么呢？<br>如下图示清晰的描述了它们之间的关系：<br> <img src="http://ww3.sinaimg.cn/large/666cc9e3gw1f496k87jkhj20ii016wel.jpg" alt=""></p>
<p>也就是说，首先是存在现实对象，然后人们根据自己的观察角度和要求将现实对象抽象成现实类，然后软件设计人员基于现实类模拟出软件类，最后在程序中将软件类实例化成软件对象，最终的程序就是软件对象的活动和交互。</p>
<p>那这样是否意味着只有你能够看见、能够感知的对象才能抽象为类呢？<br>对于现实类和现实对象来说，可以说确实是这样的；但对于软件类和软件对象并不完全是这样的。<br>有一句名言叫做“电影来源于生活，但高于生活”，用在面向对象领域中就是“软件类来源于现实类，但高于现实类”，为什么这么说呢？</p>
<p>首先，现实类在软件类中必须有对应，但并不是完全一 一对应的，有的时候需要将现实类拆成几个软件类。<br>例如：比如说ATM机是现实世界真实存在的类，但在做软件设计的时候，可能将ATM机拆分为“ATM认证”、“ATM打印”、“ATM取款”等几个软件类，这些软件类互相配合，最后完成现实世界的ATM机器的功能。</p>
<p>其次：软件类并不一定是现实存在的<br>例如：策略（Strategy）是一个人的概念，但并不是你可以看见或者感知到的；但在软件领域中，这是一个很常见的类</p>
<p>也就是说，软件类是对现实类的模拟，但并不简单的等同，除了实现现实类相对应的功能外，我们还会创造出许多现实中并不存在的类，而这个创造过程，正是各种设计方法、设计模式、设计原则大显身手的地方。</p>
<p>当你创造出各种各样、丰富多彩的对象后，各种对象开始发挥自己的功能，并且相互作用，相互影响，软件世界就开始运作起来，呈现出多姿多彩的功能和作用，整个软件世界都处于你的控制之下，你甚至只需小小的修改几行代码，整个软件就可能呈现完全不同的功能。</p>
<p><strong>你，就是软件世界的上帝！</strong></p>
<p>一个简单的对象实例如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style="font-size:14px;"&gt;package com.oo.demo;  </span><br><span class="line">  </span><br><span class="line">public class Tester &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        // 奥巴马是一个“人”的对象  </span><br><span class="line">        Person obama = new Person();  </span><br><span class="line">        obama.setName("Obama");  </span><br><span class="line">        obama.playBasketball();  </span><br><span class="line">          </span><br><span class="line">        System.out.println();  </span><br><span class="line">          </span><br><span class="line">       // 我也是一个“人”的对象  </span><br><span class="line">        Person me = new Person();  </span><br><span class="line">        me.setName("Yunhua Lee");  </span><br><span class="line">        me.playFootball();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="第八章-“接口”-详解"><a href="#第八章-“接口”-详解" class="headerlink" title="第八章 “接口” 详解"></a>第八章 “接口” 详解</h1><p>“<strong>接口”是我见过的面向对象领域中滥用、乱用、误用最多的术语</strong>：<br>有的人说：兄弟，给我提供一个“查询XXX”的接口。。。。。。<br>有的人说：系统对外提供了“查询”、“插入”、“更新”、“删除”4个接口。。。。。。<br>有的人说：我们要基于“接口”编程。。。。。。<br>有的人说：你这样做破坏了我们的接口设计。。。。。。<br>。。。。。。。。。。。<br>倒不是在这里指责他们的水平有多差，而是接口这个属于的中文翻译确实难以理解。<br>台湾译为介面，仲介之面的意思；大陆译作界面，也译作接口，但无论是“界面”、“介面”、“仲介之面”还是“接口”，都远远没有“类”、“对象”那么直白和容易理解。</p>
<p>既然中文很难理解，那么我们从英文入手，看看是否会有什么新的发现。<br>“接口”英文为“interface”，按照英文的方法将其拆开，其实就是“inter – face”，也就是说其包含两层意思：<br><strong>【Inter】： 互相，与互相对应的是单个、多个，为什么这里要强调2个呢？</strong><br>首先，“单个”不存在交互，你自己玩自己的，别人管不了，也就没法交互了；<br>其次，“多个”交互就混乱了，比如说，假设一个USB接口能够同时接鼠标和键盘，那么怎么知道收到的信号时谁发出的，发出的信号又是要发给谁呢？</p>
<p>【Face】：面，与面对应的是点、线，这里为什么要强调“面”呢？<br> 首先，“面”很形象，围着你的电脑看一下，USB接口、网络接口、VGA接口，形状是不是都是“面”？<br>其次，“面”体现了功能的多样性。即：接口包含多个“功能点”，例如：USB接口有输入功能、输出功能、充电功能，这三个功能都是USB接口具备的，而不是三个接口。</p>
<p>基于上述分析，我们可以给接口下一个清晰和容易理解的定义：接口是一组相关的交互功能点定义的集合。<br>这个定义的三个关键点详细解析一下：<br><strong>【相关】</strong><br>接口中包含的功能点是相关的，而不是一堆无关功能的堆砌。<br>例如USB接口，你见过既支持USB协议、又支持VGA协议、还支持PS/2的接口么？</p>
<p><strong>【交互】</strong><br>接口是用于不同物体交互，如果只是自己玩，那么就不能成为接口；</p>
<p><strong>【定义】</strong><br>接口中的功能点只是定义，并不涉及具体实现。<br>也就是说，接口是一个交互协议，是交互双方的一个约定，但具体如何实现，由具体的交互实体各自实现即可。<br>就像USB接口，张三可以接鼠标、李四可以接键盘、王五可以接散热风扇，但无论是鼠标、键盘还是风扇，都必须遵循USB接口的协议标准。</p>
<p><strong>【集合】</strong><br>接口是多个功能点的集合，而不是一个具体的功能点。</p>
<p>但如果你说要我重新将interface翻译成简单易理解的中文，恕我才能不够，我也没法翻译。</p>
<p>回过头来看本章前面提到的关于接口的不同说法：<br>有的人说：兄弟，给我提供一个“查询XXX”的接口——这里说的是一个功能<br>有的人说：系统对外提供了“查询”、“插入”、“更新”、“删除”4个接口——这里说的是多个功能，这些功能合起来才是一个完整的接口<br>有的人说：我们要基于“接口”编程——这个符合接口的定义<br>有的人说：你这样做破坏了我们的接口设计——这个可能符合接口的定义，也可能不符合，关键看这里的接口是指某个功能还是一组功能。</p>
<p>Java语言中的接口很好的展现了接口的含义：<br>IAnimal.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.oo.demo;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAnimal</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* </span><br><span class="line">     * Java的Interface很好的体现了我们前面分析的接口的特征： </span><br><span class="line">     * 1）是一组功能的集合，而不是一个功能 </span><br><span class="line">     * 2）接口的功能用于交互，所有的功能都是public，即别的对象可操作 </span><br><span class="line">     * 3）接口只定义函数，但不涉及函数实现 </span><br><span class="line">     * 4）这些功能是相关的，都是动物相关的功能，但光合作用就不适宜放到IAnimal里面了 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pig.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oo.demo;  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “猪”的类设计,实现了IAnnimal接口 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pig</span> <span class="keyword">implements</span> <span class="title">IAnimal</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//如下每个函数都需要详细实现  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"Pig like to eat grass"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"Pig run: front legs, back legs"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"Pig sleep 16 hours every day"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"Pig can not speak"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Person2.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oo.demo;  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 实现了IAnimal的“人”，有几点说明一下： </span><br><span class="line"> * 1）同样都实现了IAnimal的接口，但“人”和“猪”的实现不一样， </span><br><span class="line"> *    为了避免太多代码导致影响阅读，这里的代码简化成一行，但输出的内容不一样， </span><br><span class="line"> *    实际项目中同一接口的同一功能点，不同的类实现完全不一样 </span><br><span class="line"> * 2）这里同样是“人”这个类，但和前面介绍类时给的类“Person”完全不一样， </span><br><span class="line"> *    这是因为同样的逻辑概念，在不同的应用场景下，具备的属性和功能是完全不一样的 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person2</span> <span class="keyword">implements</span> <span class="title">IAnimal</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"Person like to eat meat"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"Person run: left leg, right leg"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"Person sleep 8 hours every dat"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"Hellow world, I am a person"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Tester03.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oo.demo;  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * <span class="doctag">@author</span> liyunhua </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester03</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"===This is a person==="</span>);  </span><br><span class="line">        IAnimal person = <span class="keyword">new</span> Person2();  </span><br><span class="line">        person.eat();  </span><br><span class="line">        person.run();  </span><br><span class="line">        person.sleep();  </span><br><span class="line">        person.speak();  </span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">"\n===This is a pig==="</span>);  </span><br><span class="line">        IAnimal pig = <span class="keyword">new</span> Pig();  </span><br><span class="line">        pig.eat();  </span><br><span class="line">        pig.run();  </span><br><span class="line">        pig.sleep();  </span><br><span class="line">        pig.speak();  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有了类之后为什么还要有接口呢？我直接用类不行么？<br>例如，我想操作人的时候就用Person，我想操作猪的时候就用Pig</p>
<p>大部分情况下这样做是可以的，但有的时候，你可能并不知道你面对的是一个人还是一头猪，因为这个动物可能是别人创建的，或者是上帝创建的。你只知道这是个动物，但你又希望这个动物按照你的要求进行活动。这就是接口的用处所在，即：你不知道一个对象所属的具体“类”，只知道这些对象都具备某种功能</p>
<h1 id="第九章-“抽象类”-详解"><a href="#第九章-“抽象类”-详解" class="headerlink" title="第九章 “抽象类” 详解"></a>第九章 “抽象类” 详解</h1><p>抽象类是一种特殊的类，其特殊性在于<strong>抽象类只能用于继承，不能被实例化为具体的对象</strong>。例如在Java中不能new一个抽象类，但可以extends一个抽象类。</p>
<p>抽象类的定义其实很简单，但其使用并不那么简单，有几个问题我们需要深入研究一下。</p>
<p><strong>第一个问题是：有了类，为什么还要抽象类，为什么设计一种只能继承，不能实例化的类？</strong><br>答案就在于：某些场景下普通类不够用。例如，“苹果”、“桔子”、“香蕉”都是“水果”，这里的“水果”就是一个抽象类。你可以说你喜欢吃“水果”，但你真正吃“水果”的时候，要么是“苹果”，要么是“桔子”，要么是“香蕉”。。。。。。但你绝不可能真正吃到一个叫做“水果”的东东。</p>
<p>从设计的角度来看，抽象类是更高层次的抽象。如果说普通类是从现实对象抽象出来的，那么抽象类就是基于类而抽象出来的。例如上面的样例，从“苹果”、“桔子”、“香蕉”这几个普通类，抽象出了“水果”这个类。</p>
<p>从实现的角度来看，抽象类与普通类不同的地方在于：抽象类有的存在抽象方法（方法只有声明，没有定义），子类必须自己定义这些抽象方法，而不能像普通的方法一样，通过继承就可以获得父类的方法。这一点上来看，抽象类和接口有点类似。</p>
<p><strong>第二个问题是：抽象类和接口有什么区别，为什么有了接口，还要有抽象类？</strong><br>答案就在于：抽象类本质上还是类，强调一组事物的相似性，包括属性和方法的相似性；而接口只强调方法的相似性，并且仅仅体现在方法声明上的相似性，而没有方法定义上的相似性。</p>
<p>例如：假设我们设计一个游戏，其中使用“苹果”、“桔子”、“香蕉”来做“补血”，“苹果”、“桔子”、“香蕉”都有“颜色”、“重量”这样的属性，但每种水果的补血方式是不一样的。这种情况下，使用抽象类可以很好的表达，我们设计一个抽象类“水果”，将“颜色”、“重量”作为“水果”的属性，“获取颜色”、“获取重量”、“减少重量”等方法作为“水果”的方法，将“补血”作为“水果”的抽象方法。这样设计能够大大减少“苹果”、“桔子”、“香蕉”几个普通类的实现工作量，它们只需要实现“补血”方法，其它的属性和方法都只需继承“水果”类即可。而如果采用接口的方式实现，则“苹果”、“桔子”、“香蕉”每个类都需要自己增加“颜色”、“重量”属性，增加“获取颜色”、“获取重量”、“减少重量”、“补血”等方法，工作量和代码量大大增加。</p>
<p>综合上述的分析，我们可以看出，抽象类看起来是一个介于类和接口之间的一个概念，同时具备类和接口的部分特性。</p>
<h1 id="第十章-“抽象”-详解"><a href="#第十章-“抽象”-详解" class="headerlink" title="第十章 “抽象” 详解"></a>第十章 “抽象” 详解</h1><p>抽象的中文概念非常形象，简单来说就是“抽取出来比较像的部分”。</p>
<p>那么，在面向对象的领域里，抽取什么东西比较像的部分？</p>
<p>还记得前面给类下的定义么？我们一起来回顾一下：类就是一组相似事物的统称。<br>再结合我们对象的定义：对象就是一个具体的类，一个真实存在的类。<br>我们就很容易发现了抽象的详细含义：抽取多个对象或者类中比较像的部分。</p>
<p> <img src="http://ww4.sinaimg.cn/large/666cc9e3gw1f496l00uzrj20ge07wgmc.jpg" alt=""></p>
<p>注：<br>史派克：《猫和老鼠》中的斗牛犬</p>
<p>这里的抽象分为两个层次：<br><strong>第一个层次：对象 抽象成 类。</strong><br>例如奥巴马和梅西抽象成“人”，这一层的抽象主要是将“属性类似”的对象抽取成类。<br>注意这里的属性类似是指属性类别一致，而属性的取值是不一样的。例如如果将“奥巴马”和“梅西”都抽象成“人”，那么其属性有身高、体重、性别、年龄等，但“奥巴马”和“梅西”的这些属性取值肯定是不同的。</p>
<p><strong>第二个层次（或更高层次）：将 类 抽象成超类</strong>（或者说父类，其实就是更高一级的类），<br>例如人和猪抽象成“动物”，这一层的抽象主要是将“行为类似”的类抽象成父类。<br>注意这里是“行为类似”，而不是第一层抽象的那样“属性类似”，因为在面向对象领域，行为一致的话就认为是同一类的，当然也不能是完全不同，完全不同的话就没有相似点，也就无法抽象成类了，所以这一层抽象的重点是“相似”。</p>
<p>实际应用中，抽象的层次是不限的，根据业务的需要，或者不同的观察角度，可以抽象出很多层。</p>
<p><strong>【抽象的作用】</strong><br>抽象并不是面向对象领域特有的概念和方法，在人类的科学研究中，抽象是再常见不过的技术了：生物学将猪马牛羊等生物抽象为“动物”，将花草树木等抽象为“植物”，医学将心肝脾肺肾抽象为“内脏”，化学将碳氢氧氮等抽象为“元素”，物理学上将地球、火星、水星等抽象为“行星”。。。。。。等等。</p>
<p>又比如我们的高中学习课程，也抽象出“语文、数学、物理、化学”等学科，我们的大学课程，又分为了几十上百个专业。</p>
<p>在人类的科学研究，以及日常生活和学习中，抽象最主要的作用是“划分类别”，而划分类别的主要目的其实还是“隔离关注点，降低复杂度”。因为这个世界太复杂了，复杂到一个人不可能同时关注所有的内容。心理学上的研究证实，人同时能关注的事务不超过 7+/-2个。可以想象，如果没有抽象分类，我们将面对一个混沌的世界，同时关注如此多的内容，即使是天才，估计也要崩溃。</p>
<p>在面向对象领域，抽象也不例外。抽象的主要作用也是划分类别，所以，<strong>抽象是面向对象领域里面发现类的主要方法</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[pythonの读取excel内容]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/05/10/python%E3%81%AE%E8%AF%BB%E5%8F%96excel%E5%86%85%E5%AE%B9.html</url>
      <content type="html"><![CDATA[<h2 id="任务要求：读取excel内数据，并对数据进行校验后返回数据"><a href="#任务要求：读取excel内数据，并对数据进行校验后返回数据" class="headerlink" title="任务要求：读取excel内数据，并对数据进行校验后返回数据"></a>任务要求：读取excel内数据，并对数据进行校验后返回数据</h2><a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="comment">#类使用方法：用来查询excel表中数据名称（name）、数据类型(type_code)、数据大小(internal_size)</span></span><br><span class="line"><span class="comment">#return [状态位，错误信息,col_data]</span></span><br><span class="line"><span class="comment">#col_data=[name, type_code internal_size]</span></span><br><span class="line"><span class="comment">#状态位 0为正确 1为错误</span></span><br><span class="line"><span class="comment">#若状态位为0，则错误信息为空，</span></span><br><span class="line"><span class="comment">#若状态位为1，则只返回错误信息，不返回查询值</span></span><br><span class="line"><span class="comment">#-------目前只支持一下数据类型的插入----------</span></span><br><span class="line"><span class="comment">#         oracle_type=["CHAR","VARCHAR2","NCHAR",</span></span><br><span class="line"><span class="comment">#                      "NVARCHAR2","DATE","TIMESTAMP",</span></span><br><span class="line"><span class="comment">#                      "LONG","RAW","LONG RAW",</span></span><br><span class="line"><span class="comment">#                      "BLOB","CLOB","NCLOB",</span></span><br><span class="line"><span class="comment">#                      "BFILE","ROWID","NROWID",</span></span><br><span class="line"><span class="comment">#                      "NUMBER","DECIMAL","INTEGER",</span></span><br><span class="line"><span class="comment">#                      "FLOAT","REAL"]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EXCEL_ALL</span>:</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Open_Excel</span><span class="params">(self,excel_name,excel_sheet=<span class="string">"Sheet1"</span>)</span>:</span></span><br><span class="line">        self.fname = excel_name.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        self.fsheet = excel_sheet</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.bk = xlrd.open_workbook(self.fname)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>,<span class="string">"no %s named excel"</span> % self.fname]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sh = self.bk.sheet_by_name(self.fsheet)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>,<span class="string">"no sheet in %s named %s"</span> % (self.fname,self.fsheet)]</span><br><span class="line">        <span class="comment">#获取行数</span></span><br><span class="line">        nrows = sh.nrows</span><br><span class="line">        <span class="comment">#获取列数</span></span><br><span class="line">        ncols = sh.ncols</span><br><span class="line"><span class="comment">#-----------校验----------</span></span><br><span class="line">    <span class="comment">#---校验数据是否完整 是否有空值---</span></span><br><span class="line">        <span class="comment">#获取各列数值  </span></span><br><span class="line">        col_0=sh.col_values(<span class="number">0</span>)</span><br><span class="line">        col_1=sh.col_values(<span class="number">1</span>)  </span><br><span class="line">        col_2=sh.col_values(<span class="number">2</span>)</span><br><span class="line">        col_3=sh.col_values(<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,nrows):</span><br><span class="line">            <span class="keyword">if</span>(col_0[i]==<span class="string">''</span> <span class="keyword">or</span> col_1[i]==<span class="string">''</span> <span class="keyword">or</span> col_2[i]==<span class="string">''</span> <span class="keyword">or</span> col_3[i]==<span class="string">''</span>):  </span><br><span class="line">                msg=<span class="string">'Data length is not consistent'</span></span><br><span class="line">                <span class="keyword">return</span> [<span class="number">1</span>,msg]</span><br><span class="line">    <span class="comment">#---校验导入数据类型---</span></span><br><span class="line">        <span class="comment">#获取第一列数值</span></span><br><span class="line">        col_1=sh.col_values(<span class="number">1</span>)  </span><br><span class="line">        n_col_1=len(col_1)</span><br><span class="line">        <span class="comment">#ORACLE 数据库所有数据类型</span></span><br><span class="line">        oracle_type=[<span class="string">"CHAR"</span>,<span class="string">"VARCHAR2"</span>,<span class="string">"NCHAR"</span>,</span><br><span class="line">                     <span class="string">"NVARCHAR2"</span>,<span class="string">"DATE"</span>,<span class="string">"TIMESTAMP"</span>,</span><br><span class="line">                     <span class="string">"LONG"</span>,<span class="string">"RAW"</span>,<span class="string">"LONG RAW"</span>,</span><br><span class="line">                     <span class="string">"BLOB"</span>,<span class="string">"CLOB"</span>,<span class="string">"NCLOB"</span>,</span><br><span class="line">                     <span class="string">"BFILE"</span>,<span class="string">"ROWID"</span>,<span class="string">"NROWID"</span>,</span><br><span class="line">                     <span class="string">"NUMBER"</span>,<span class="string">"DECIMAL"</span>,<span class="string">"INTEGER"</span>,</span><br><span class="line">                     <span class="string">"FLOAT"</span>,<span class="string">"REAL"</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n_col_1):</span><br><span class="line">            col_type=col_1[i].upper()   <span class="comment">#最大化</span></span><br><span class="line">            <span class="keyword">if</span> col_type <span class="keyword">not</span> <span class="keyword">in</span> oracle_type:</span><br><span class="line">                msg=<span class="string">"Some data type does not belong to the oracle database"</span></span><br><span class="line">                <span class="keyword">return</span> [<span class="number">1</span>,msg]</span><br><span class="line">    <span class="comment">#---校验第三、四列是否为整数类型----</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,nrows): </span><br><span class="line">            cc_2=sh.cell_value(i,<span class="number">2</span>)</span><br><span class="line">            cc_3=sh.cell_value(i,<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">if</span> cc_2%<span class="number">1</span>!=<span class="number">0</span> <span class="keyword">or</span> cc_3%<span class="number">1</span>!=<span class="number">0</span>:</span><br><span class="line">                msg=<span class="string">'internal_size is not int'</span></span><br><span class="line">                <span class="keyword">return</span> [<span class="number">1</span>,msg]</span><br><span class="line">                  </span><br><span class="line">        col_data = [[<span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> range(ncols)] <span class="keyword">for</span> row <span class="keyword">in</span> range(nrows)]  </span><br><span class="line">        <span class="comment">#获取各行数据</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,nrows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,ncols):</span><br><span class="line">                col_data[i][j]=str(sh.cell_value(i,j)).decode(<span class="string">'utf-8'</span>).encode(<span class="string">'gb2312'</span>)       </span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>,<span class="string">''</span>,col_data]</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[pythonの读取oracle数据库字段名类型等]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/05/05/python%E3%81%AE%E8%AF%BB%E5%8F%96oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E6%AE%B5%E5%90%8D%E7%B1%BB%E5%9E%8B%E7%AD%89.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>完成任务：通过给出的SQL语句，获得所操作表的字段名类型等信息</p>
</blockquote>
<h2 id="安装cx-oracle插件-确定返回值类型"><a href="#安装cx-oracle插件-确定返回值类型" class="headerlink" title="安装cx_oracle插件  确定返回值类型"></a>安装cx_oracle插件  确定返回值类型</h2><a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cx_Oracle</span><br><span class="line"><span class="comment">#类使用方法：用来查询数据库表中name, type_code, display_size, internal_size</span></span><br><span class="line"><span class="comment">#return [状态位，错误信息,col_data]</span></span><br><span class="line"><span class="comment">#col_data=[name, type_code, display_size, internal_size]</span></span><br><span class="line"><span class="comment">#状态位 0为正确 1为错误</span></span><br><span class="line"><span class="comment">#若状态位为0，则错误信息为空，</span></span><br><span class="line"><span class="comment">#若状态位为1，则只返回错误信息，不返回查询值</span></span><br></pre></td></tr></table></figure>
<h2 id="DB-ALL类执行对数据库的操作"><a href="#DB-ALL类执行对数据库的操作" class="headerlink" title="DB_ALL类执行对数据库的操作"></a>DB_ALL类执行对数据库的操作</h2><h4 id="输入是一个表名"><a href="#输入是一个表名" class="headerlink" title="输入是一个表名"></a>输入是一个表名</h4><blockquote>
<p>首先获取数据库登录信息 登录数据库<br>若输入时一段表名 则首先校验此表是否在数据库内  若不在 则直接返回<br>若表在数据库内 则通过SQL语句 直接查询该表 获得返回信息</p>
</blockquote>
<h4 id="输入时一段SQL语句"><a href="#输入时一段SQL语句" class="headerlink" title="输入时一段SQL语句"></a>输入时一段SQL语句</h4><blockquote>
<p>执行此SQL语句 获得返回值<br>若SQL语句执行有错误  则返回oracle数据库返回的错误信息</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#-------DB Class------------------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DB_ALL</span>:</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,Execute_Sql)</span>:</span>  <span class="comment">#初始化</span></span><br><span class="line">        <span class="comment">#----读取Oracle配置信息------------</span></span><br><span class="line">        F_Config=open(<span class="string">'Config.txt'</span>)</span><br><span class="line">        Connect_Oracle=F_Config.readline()</span><br><span class="line">        F_Config.close()</span><br><span class="line">        <span class="comment">#参数初始化</span></span><br><span class="line">        self.con_Oracle=Connect_Oracle</span><br><span class="line">        self.exe_Sql=Execute_Sql</span><br><span class="line">        self.exe_Sql_temp=<span class="string">'select * from '</span>+self.exe_Sql                         </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_Get_Name_List</span><span class="params">(self)</span>:</span> </span><br><span class="line">        conn=cx_Oracle.connect(self.con_Oracle)     <span class="comment">#链接数据库</span></span><br><span class="line">        cursor = conn.cursor ()                     <span class="comment">#获取操作符</span></span><br><span class="line">        Check_Sql=<span class="string">'SELECT count(*) FROM dba_OBJECTS WHERE OBJECT_NAME = UPPER(\''</span>+self.exe_Sql+<span class="string">'\')'</span>  <span class="comment">#执行此SQL</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cursor.execute (Check_Sql)        <span class="comment">#校验SQL </span></span><br><span class="line">            check_row = cursor.fetchone ()</span><br><span class="line">            <span class="keyword">if</span> (check_row[<span class="number">0</span>]==<span class="number">0</span>):</span><br><span class="line">                <span class="keyword">return</span> [<span class="number">1</span>,<span class="string">"DatabaseError(table name is error)"</span>]</span><br><span class="line">        <span class="keyword">except</span> cx_Oracle.DatabaseError, msg:  <span class="comment">#输出Oracle错误信息</span></span><br><span class="line">            cursor.close ()</span><br><span class="line">            conn.close ()</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>,msg]</span><br><span class="line">        cursor.execute (self.exe_Sql_temp)     <span class="comment">#执行SQL          </span></span><br><span class="line">        <span class="comment">#一行行读取SQL结果</span></span><br><span class="line">        col_name_list = [tuple[<span class="number">0</span>] <span class="keyword">for</span> tuple <span class="keyword">in</span> cursor.description]</span><br><span class="line">        col_type_code_temp = [tuple[<span class="number">1</span>] <span class="keyword">for</span> tuple <span class="keyword">in</span> cursor.description]</span><br><span class="line">        col_display_size = [tuple[<span class="number">2</span>] <span class="keyword">for</span> tuple <span class="keyword">in</span> cursor.description]</span><br><span class="line">        col_internal_size = [tuple[<span class="number">3</span>] <span class="keyword">for</span> tuple <span class="keyword">in</span> cursor.description]</span><br><span class="line">        <span class="comment">#对col_type_code数据进行处理</span></span><br><span class="line">        col_type_code=col_type_code_temp  <span class="comment">#映射后修改值</span></span><br><span class="line">        n=len(col_type_code_temp)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            aa=str(col_type_code_temp[i])</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"STRING"</span> <span class="keyword">in</span> aa:</span><br><span class="line">                col_type_code[i]=<span class="string">"STRING"</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="string">"DATETIME"</span> <span class="keyword">in</span> aa:</span><br><span class="line">                col_type_code[i]=<span class="string">"DATE"</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="string">"NUMBER"</span> <span class="keyword">in</span> aa:</span><br><span class="line">                col_type_code[i]=<span class="string">"NUMBER"</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="string">"BLOB"</span> <span class="keyword">in</span> aa:</span><br><span class="line">                col_type_code[i]=<span class="string">"BLOB"</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="string">"CHAR"</span> <span class="keyword">in</span> aa:</span><br><span class="line">                col_type_code[i]=<span class="string">"CHAR"</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="string">"CLOB"</span> <span class="keyword">in</span> aa:</span><br><span class="line">                col_type_code[i]=<span class="string">"CLOB"</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                col_type_code[i]=<span class="string">"unknown type"</span></span><br><span class="line">        cursor.close ()</span><br><span class="line">        conn.close ()</span><br><span class="line">        <span class="comment">#对col_name_list,col_type_code,col_display_size,col_internal_size数据进行打包</span></span><br><span class="line">        col_temp=map(<span class="keyword">lambda</span> x:[[e[<span class="number">1</span>]] <span class="keyword">for</span> e <span class="keyword">in</span> enumerate(x)],[col_name_list,col_type_code,col_display_size,col_internal_size])</span><br><span class="line">        col_data=[col_temp[<span class="number">0</span>][i[<span class="number">0</span>]]+col_temp[<span class="number">1</span>][i[<span class="number">0</span>]]+col_temp[<span class="number">2</span>][i[<span class="number">0</span>]]+col_temp[<span class="number">3</span>][i[<span class="number">0</span>]] <span class="keyword">for</span> i <span class="keyword">in</span> enumerate(col_temp[<span class="number">0</span>])]</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>,<span class="string">''</span>,col_data]</span><br><span class="line"><span class="comment">#--------执行SQL语句并输出-------------</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_Get_Other_List</span><span class="params">(self)</span>:</span></span><br><span class="line">        conn=cx_Oracle.connect(self.con_Oracle)     <span class="comment">#链接数据库</span></span><br><span class="line">        cursor = conn.cursor ()                     <span class="comment">#获取操作符</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cursor.execute (self.exe_Sql)          <span class="comment">#执行SQL</span></span><br><span class="line">            <span class="comment">#一行行读取SQL结果</span></span><br><span class="line">            col_name_list = [tuple[<span class="number">0</span>] <span class="keyword">for</span> tuple <span class="keyword">in</span> cursor.description]</span><br><span class="line">            col_type_code_temp = [tuple[<span class="number">1</span>] <span class="keyword">for</span> tuple <span class="keyword">in</span> cursor.description]</span><br><span class="line">            col_display_size = [tuple[<span class="number">2</span>] <span class="keyword">for</span> tuple <span class="keyword">in</span> cursor.description]</span><br><span class="line">            col_internal_size = [tuple[<span class="number">3</span>] <span class="keyword">for</span> tuple <span class="keyword">in</span> cursor.description]</span><br><span class="line">            <span class="comment">#对col_type_code数据进行处理</span></span><br><span class="line">            col_type_code=col_type_code_temp  <span class="comment">#映射后修改值</span></span><br><span class="line">            n=len(col_type_code_temp)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">                aa=str(col_type_code_temp[i])</span><br><span class="line">                <span class="keyword">if</span> <span class="string">"STRING"</span> <span class="keyword">in</span> aa:</span><br><span class="line">                    col_type_code[i]=<span class="string">"STRING"</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="string">"DATETIME"</span> <span class="keyword">in</span> aa:</span><br><span class="line">                    col_type_code[i]=<span class="string">"DATE"</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="string">"NUMBER"</span> <span class="keyword">in</span> aa:</span><br><span class="line">                    col_type_code[i]=<span class="string">"NUMBER"</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="string">"BLOB"</span> <span class="keyword">in</span> aa:</span><br><span class="line">                    col_type_code[i]=<span class="string">"BLOB"</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="string">"CHAR"</span> <span class="keyword">in</span> aa:</span><br><span class="line">                    col_type_code[i]=<span class="string">"CHAR"</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="string">"CLOB"</span> <span class="keyword">in</span> aa:</span><br><span class="line">                    col_type_code[i]=<span class="string">"CLOB"</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    col_type_code[i]=<span class="string">"unknown type"</span></span><br><span class="line">            cursor.close ()</span><br><span class="line">            conn.close ()</span><br><span class="line">            <span class="comment">#对col_name_list,col_type_code,col_display_size,col_internal_size数据进行打包</span></span><br><span class="line">            col_temp=map(<span class="keyword">lambda</span> x:[[e[<span class="number">1</span>]] <span class="keyword">for</span> e <span class="keyword">in</span> enumerate(x)],[col_name_list,col_type_code,col_display_size,col_internal_size])</span><br><span class="line">            col_data=[col_temp[<span class="number">0</span>][i[<span class="number">0</span>]]+col_temp[<span class="number">1</span>][i[<span class="number">0</span>]]+col_temp[<span class="number">2</span>][i[<span class="number">0</span>]]+col_temp[<span class="number">3</span>][i[<span class="number">0</span>]] <span class="keyword">for</span> i <span class="keyword">in</span> enumerate(col_temp[<span class="number">0</span>])]  </span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>,<span class="string">''</span>,col_data]</span><br><span class="line">        <span class="keyword">except</span> cx_Oracle.DatabaseError, msg:      <span class="comment">#输出Oracle错误信息</span></span><br><span class="line">            cursor.close ()</span><br><span class="line">            conn.close ()</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>,msg]</span><br></pre></td></tr></table></figure>
<h3 id="完成对SQL语句的判断"><a href="#完成对SQL语句的判断" class="headerlink" title="完成对SQL语句的判断"></a>完成对SQL语句的判断</h3><blockquote>
<p>判断是表名还是一段SQL语句</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Exe_Sql</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">E_Sql</span><span class="params">(self,Execute_Sql)</span>:</span></span><br><span class="line">        <span class="comment">#------SQL 预处理-------</span></span><br><span class="line">        Execute_Sql=Execute_Sql.lstrip()           <span class="comment">#去除最左侧空格</span></span><br><span class="line">        Separate_Name=Execute_Sql.split(<span class="string">' '</span>)       <span class="comment">#按照空格分隔字符串</span></span><br><span class="line">        Separate_Name[<span class="number">0</span>]=Separate_Name[<span class="number">0</span>].upper()  <span class="comment">#将第一个全部字符串大写</span></span><br><span class="line">        <span class="keyword">if</span> Separate_Name[<span class="number">0</span>]==<span class="string">'SELECT'</span>:             <span class="comment">#判断输入语句是表名还是SQL语句</span></span><br><span class="line">            <span class="comment">#对SQL语句进行预处理</span></span><br><span class="line">            p=DB_ALL(Execute_Sql)            </span><br><span class="line">            <span class="keyword">return</span> p.db_Get_Other_List()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#查询表名</span></span><br><span class="line">            Execute_Sql=Execute_Sql.upper()            <span class="comment">#全部大写</span></span><br><span class="line">            p=DB_ALL(Execute_Sql)</span><br><span class="line">            <span class="keyword">return</span> p.db_Get_Name_List()</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[pythonのoracle数据库操作]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/04/30/python%E3%81%AEoracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C.html</url>
      <content type="html"><![CDATA[<h2 id="下载cx-Oracle"><a href="#下载cx-Oracle" class="headerlink" title="下载cx_Oracle"></a>下载cx_Oracle</h2><p>　　想用python链接数据库首先需要安装cx_Oracle插件，<br>下载地址：<a href="http://cx-oracle.sourceforge.net/" target="_blank" rel="external">http://cx-oracle.sourceforge.net/</a></p>
<h2 id="测试是否cx-Oracle安装成功"><a href="#测试是否cx-Oracle安装成功" class="headerlink" title="测试是否cx_Oracle安装成功 "></a>测试是否cx_Oracle安装成功 <a id="more"></a></h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import cx_Oracle  </span><br><span class="line">  </span><br><span class="line">conn = cx_Oracle.<span class="built_in">connect</span>(<span class="string">'username/passwd@host:port/sid'</span>)    <span class="meta">#你自己的数据库信息</span></span><br><span class="line"><span class="built_in">cursor</span> = conn.<span class="built_in">cursor</span> ()  </span><br><span class="line"><span class="built_in">cursor</span>.execute (<span class="string">"select * from table_name"</span>)   <span class="meta">#数据库表</span></span><br><span class="line">row = <span class="built_in">cursor</span>.fetchone ()  </span><br><span class="line"><span class="built_in">print</span> row[<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">cursor</span>.<span class="built_in">close</span> ()  </span><br><span class="line">conn.<span class="built_in">close</span> ()</span><br></pre></td></tr></table></figure>
<h2 id="Oracle数据库操作"><a href="#Oracle数据库操作" class="headerlink" title="Oracle数据库操作"></a>Oracle数据库操作</h2><ol>
<li><p>连接数据库</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">db1</span>=cx_Oracle.connect(<span class="string">'username'</span>,<span class="string">'pwd'</span>,<span class="string">'host:port/sid'</span>)</span><br><span class="line"><span class="attr">db2</span>=cx_Oracle.connect(<span class="string">'username/pwd@host:port/sid'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取游标</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cursor</span> = db1.<span class="built_in">cursor</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行SQL语句</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cursor</span>.<span class="keyword">execute</span>(<span class="string">'select * from talbe'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取查询结果<br><strong> fetchall() ——-获取所有结果 </strong><br><strong> fetchone()——获取一行结果 </strong><br><strong> fetchmang(N)—获取N行结果 </strong><br>使用fetchone()可通过迭代获取所有行</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cursor</span>.execute (SQL)          <span class="meta">#执行SQL</span></span><br><span class="line"> <span class="meta">#一行行读取SQL结果</span></span><br><span class="line"><span class="built_in">while</span> (<span class="number">1</span>):</span><br><span class="line">      row = <span class="built_in">cursor</span>.fetchone ()</span><br><span class="line">      <span class="built_in">if</span>  row==None:</span><br><span class="line">           <span class="built_in">break</span></span><br><span class="line">      <span class="built_in">print</span> row</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cursor.execute ("<span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TEST</span> (<span class="keyword">ID</span>, COL1, COL2, COL3)<span class="keyword">VALUES</span>(<span class="number">3</span>, <span class="string">'aaa'</span>, <span class="string">'bbb'</span>, <span class="string">'ccc'</span>)<span class="string">")  </span><br><span class="line">conn.commit()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>断开数据库<br>需要先关闭游标连接，在关闭数据库连接</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cursor</span>.<span class="built_in">close</span> ()</span><br><span class="line">conn.<span class="built_in">close</span> ()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>7、如何获取Oracle返回的错误信息<br><strong> 示例一 </strong><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Python cx_Oracle.DatabaseError Examples</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">cursor</span>.<span class="keyword">execute</span>(SQL)</span><br><span class="line">except cx_Oracle.DatabaseError, ms<span class="variable">g:</span></span><br><span class="line">    <span class="keyword">print</span> msg</span><br></pre></td></tr></table></figure></p>
<p><strong> 示例二 </strong><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">cursor</span>.<span class="keyword">execute</span>(sql)</span><br><span class="line">except cx_Oracle.DatabaseError, exc:</span><br><span class="line">    <span class="keyword">if</span> str(exc).<span class="keyword">find</span>(<span class="string">'ORA-01442'</span>) == -<span class="number">1</span>:</span><br><span class="line">            raise</span><br></pre></td></tr></table></figure></p>
<p><a href="http://www.programcreek.com/python/example/63817/cx_Oracle.DatabaseError" target="_blank" rel="external">Python cx_Oracle.DatabaseError Examples  </a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PythonのEclipse+PyDev环境搭建]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/04/28/Python%E3%81%AEEclipse+PyDev%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
      <content type="html"><![CDATA[<h2 id="编译器：Eclipse-Pydev插件"><a href="#编译器：Eclipse-Pydev插件" class="headerlink" title="编译器：Eclipse+Pydev插件"></a>编译器：Eclipse+Pydev插件</h2><ol>
<li>Eclipse 功能强大 跨平台</li>
<li>Eclipse 时写Java的IDE，使用方便</li>
<li>PyDev插件让Eclipse支持python代码编写及编译<a id="more"></a>
<h2 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h2>下载地址 <a href="http://www.python.org/" target="_blank" rel="external">http://www.python.org/</a><br>Python 有 Python 2 和 Python 3 两个版本。  语法有些区别。<br>例如：<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">python2</span>: print "Hello World!"</span><br><span class="line"></span><br><span class="line"><span class="vim"><span class="keyword">python3</span>: <span class="keyword">print</span> (<span class="string">"Hello world!"</span>)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="安装JAVA-JDK"><a href="#安装JAVA-JDK" class="headerlink" title="安装JAVA JDK"></a>安装JAVA JDK</h2><p>Eclipse 需要这个安装好JAVA JDK后才能运行。  <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">JAVA JDK下载地址</a></p>
<h2 id="在Eclipse中安装pydev插件"><a href="#在Eclipse中安装pydev插件" class="headerlink" title="在Eclipse中安装pydev插件"></a>在Eclipse中安装pydev插件</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SQL入门教程（一）]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2016/04/15/SQL.html</url>
      <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>　　1、说明：创建数据库</p>
<p>　　CREATE DATABASE database-name</p>
<p>　　2、说明：删除数据库</p>
<p>　　drop database dbname</p>
<p>　　3、说明：备份sql server</p>
<p>　　— 创建 备份数据的 device</p>
<p>　　USE master</p>
<p>　　EXEC sp_addumpdevice ‘disk’, ‘testBack’, ‘c:\mssql7backup\MyNwind_1.dat’</p>
<p>　　— 开始 备份</p>
<p>　　BACKUP DATABASE pubs TO testBack<br><a id="more"></a></p>
<p>　　4、说明：创建新表</p>
<p>　　create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)</p>
<p>　　根据已有的表创建新表：</p>
<p>　　A：create table tab_new like tab_old (使用旧表创建新表)</p>
<p>　　B：create table tab_new as select col1,col2… from tab_old definition only</p>
<p>　　5、说明：删除新表</p>
<p>　　drop table tabname</p>
<p>　　6、说明：增加一个列</p>
<p>　　Alter table tabname add column col type</p>
<p>　　注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。</p>
<p>　　7、说明：添加主键： Alter table tabname add primary key(col)</p>
<p>　　说明：删除主键： Alter table tabname drop primary key(col)</p>
<p>　　8、说明：创建索引：create [unique] index idxname on tabname(col….)</p>
<p>　　删除索引：drop index idxname</p>
<p>　　注：索引是不可更改的，想更改必须删除重新建。</p>
<p>　　9、说明：创建视图：create view viewname as select statement</p>
<p>　　删除视图：drop view viewname</p>
<p>　　10、说明：几个简单的基本的sql语句</p>
<p>　　选择：select * from table1 where 范围</p>
<p>　　插入：insert into table1(field1,field2) values(value1,value2)</p>
<p>　　删除：delete from table1 where 范围</p>
<p>　　更新：update table1 set field1=value1 where 范围</p>
<p>　　查找：select * from table1 where field1 like ’%value1%’ —like的语法很精妙，查资料!</p>
<p>　　排序：select * from table1 order by field1,field2 [desc]</p>
<p>　　总数：select count as totalcount from table1</p>
<p>　　求和：select sum(field1) as sumvalue from table1</p>
<p>　　平均：select avg(field1) as avgvalue from table1</p>
<p>　　最大：select max(field1) as maxvalue from table1</p>
<p>　　最小：select min(field1) as minvalue from table1</p>
<p>　　11、说明：几个高级查询运算词</p>
<p>　　A： UNION 运算符</p>
<p>　　UNION 运算符通过组合其他两个结果表(例如 TABLE1 和 TABLE2)并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时(即 UNION ALL)，不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。</p>
<p>　　B： EXCEPT 运算符</p>
<p>　　EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。</p>
<p>　　C： INTERSECT 运算符</p>
<p>　　INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。</p>
<p>　　注：使用运算词的几个查询结果行必须是一致的。</p>
<p>　　12、说明：使用外连接</p>
<p>　　A、left (outer) join：</p>
<p>　　左外连接(左连接)：结果集几包括连接表的匹配行，也包括左连接表的所有行。</p>
<p>　　SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c</p>
<p>　　B：right (outer) join:</p>
<p>　　右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。</p>
<p>　　C：full/cross (outer) join：</p>
<p>　　全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。</p>
<p>　　12、分组:Group by:</p>
<p>　　一张表，一旦分组 完成后，查询后只能得到组相关的信息。</p>
<p>　　组相关的信息：(统计信息) count,sum,max,min,avg 分组的标准)</p>
<p>　　在SQLServer中分组时：不能以text,ntext,image类型的字段作为分组依据</p>
<p>　　在selecte统计函数中的字段，不能和普通的字段放在一起;</p>
<p>　　13、对数据库进行操作：</p>
<p>　　分离数据库： sp_detach_db; 附加数据库：sp_attach_db 后接表明，附加需要完整的路径名</p>
<p>　　14.如何修改数据库的名称:</p>
<p>　　sp_renamedb ‘old_name’, ‘new_name’</p>
<h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><p>　　1、说明：复制表(只复制结构,源表名：a 新表名：b) (Access可用)</p>
<p>　　法一：select * into b from a where 1&lt;&gt;1(仅用于SQlServer)</p>
<p>　　法二：select top 0 * into b from a</p>
<p>　　2、说明：拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用)</p>
<p>　　insert into b(a, b, c) select d,e,f from b;</p>
<p>　　3、说明：跨数据库之间表的拷贝(具体数据使用绝对路径) (Access可用)</p>
<p>　　insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件</p>
<p>　　例子：..from b in ‘“&amp;Server.MapPath(“.”)&amp;”\data.mdb” &amp;”‘ where..</p>
<p>　　4、说明：子查询(表名1：a 表名2：b)</p>
<p>　　select a,b,c from a where a IN (select d from b ) 或者: select a,b,c from a where a IN (1,2,3)</p>
<p>　　5、说明：显示文章、提交人和最后回复时间</p>
<p>　　select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b</p>
<p>　　6、说明：外连接查询(表名1：a 表名2：b)</p>
<p>　　select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c</p>
<p>　　7、说明：在线视图查询(表名1：a )</p>
<p>　　select * from (SELECT a,b,c FROM a) T where t.a &gt; 1;</p>
<p>　　8、说明：between的用法,between限制查询数据范围时包括了边界值,not between不包括</p>
<p>　　select * from table1 where time between time1 and time2</p>
<p>　　select a,b,c, from table1 where a not between 数值1 and 数值2</p>
<p>　　9、说明：in 的使用方法</p>
<p>　　select * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’)</p>
<p>　　10、说明：两张关联表，删除主表中已经在副表中没有的信息</p>
<p>　　delete from table1 where not exists ( select * from table2 where table1.field1=table2.field1 )</p>
<p>　　11、说明：四表联查问题：</p>
<p>　　select * from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d on a.a=d.d where …..</p>
<p>　　12、说明：日程安排提前五分钟提醒</p>
<p>　　SQL: select * from 日程安排 where datediff(‘minute’,f开始时间,getdate())&gt;5</p>
<p>　　13、说明：一条sql 语句搞定数据库分页</p>
<p>　　select top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 = a.主键字段 order by a.排序字段</p>
<p>　　具体实现：</p>
<p>　　关于数据库分页：</p>
<p>　　declare @start int,@end int</p>
<p>　　@sql nvarchar(600)</p>
<p>　　set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’</p>
<p>　　exec sp_executesql @sql</p>
<p>　　注意：在top后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。Rid为一个标识列，如果top后还有具体的字段，这样做是非常有好处的。因为这样可以避免 top的字段如果是逻辑索引的，查询的结果后实际表中的不一致(逻辑索引中的数据有可能和数据表中的不一致，而查询时如果处在索引则首先查询索引)</p>
<p>　　14、说明：前10条记录</p>
<p>　　select top 10 * form table1 where 范围</p>
<p>　　15、说明：选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)</p>
<p>　　select a,b,c from tablename ta where a=(select max(a) from tablename tb where tb.b=ta.b)</p>
<p>　　16、说明：包括所有在 TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个结果表</p>
<p>　　(select a from tableA ) except (select a from tableB) except (select a from tableC)</p>
<p>　　17、说明：随机取出10条数据</p>
<p>　　select top 10 * from tablename order by newid()</p>
<p>　　18、说明：随机选择记录</p>
<p>　　select newid()</p>
<p>　　19、说明：删除重复记录</p>
<p>　　1),delete from tablename where id not in (select max(id) from tablename group by col1,col2,…)</p>
<p>　　2),select distinct * into temp from tablename</p>
<p>　　delete from tablename</p>
<p>　　insert into tablename select * from temp</p>
<p>　　评价： 这种操作牵连大量的数据的移动，这种做法不适合大容量但数据操作</p>
<p>　　3),例如：在一个外部表中导入数据，由于某些原因第一次只导入了一部分，但很难判断具体位置，这样只有在下一次全部导入，这样也就产生好多重复的字段，怎样删除重复字段</p>
<p>　　alter table tablename</p>
<p>　　–添加一个自增列</p>
<p>　　add column_b int identity(1,1)</p>
<p>　　delete from tablename where column_b not in(</p>
<p>　　select max(column_b) from tablename group by column1,column2,…)</p>
<p>　　alter table tablename drop column column_b</p>
<p>　　20、说明：列出数据库里所有的表名</p>
<p>　　select name from sysobjects where type=’U’ // U代表用户</p>
<p>　　21、说明：列出表里的所有的列名</p>
<p>　　select name from syscolumns where id=object_id(‘TableName’)</p>
<p>　　22、说明：列示type、vender、pcs字段，以type字段排列，case可以方便地实现多重选择，类似select 中的case。</p>
<p>　　select type,sum(case vender when ‘A’ then pcs else 0 end),sum(case vender when ‘C’ then pcs else 0 end),sum(case vender when ‘B’ then pcs else 0 end) FROM tablename group by type</p>
<p>　　显示结果：</p>
<p>　　type vender pcs</p>
<p>　　电脑 A 1</p>
<p>　　电脑 A 1</p>
<p>　　光盘 B 2</p>
<p>　　光盘 A 2</p>
<p>　　手机 B 3</p>
<p>　　手机 C 3</p>
<p>　　23、说明：初始化表table1</p>
<p>　　TRUNCATE TABLE table1</p>
<p>　　24、说明：选择从10到15的记录</p>
<p>　　select top 5 <em> from (select top 15 </em> from table order by id asc) table_别名 order by id desc</p>
<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p>　　1、1=1，1=2的使用，在SQL语句组合时用的较多</p>
<p>　　“where 1=1” 是表示选择全部 “where 1=2”全部不选，</p>
<p>　　如：</p>
<p>　　if @strWhere !=’’</p>
<p>　　begin</p>
<p>　　set @strSQL = ‘select count(*) as Total from [‘ + @tblName + ‘] where ‘ + @strWhere</p>
<p>　　end</p>
<p>　　else</p>
<p>　　begin</p>
<p>　　set @strSQL = ‘select count(*) as Total from [‘ + @tblName + ‘]’</p>
<p>　　end</p>
<p>　　我们可以直接写成</p>
<p>　　错误!未找到目录项。</p>
<p>　　set @strSQL = ‘select count(*) as Total from [‘ + @tblName + ‘] where 1=1 安定 ‘+ @strWhere 2、收缩数据库</p>
<p>　　–重建索引</p>
<p>　　DBCC REINDEX</p>
<p>　　DBCC INDEXDEFRAG</p>
<p>　　–收缩数据和日志</p>
<p>　　DBCC SHRINKDB</p>
<p>　　DBCC SHRINKFILE</p>
<p>　　3、压缩数据库</p>
<p>　　dbcc shrinkdatabase(dbname)</p>
<p>　　4、转移数据库给新用户以已存在用户权限</p>
<p>　　exec sp_change_users_login ‘update_one’,’newname’,’oldname’</p>
<p>　　go</p>
<p>　　5、检查备份集</p>
<p>　　RESTORE VERIFYONLY from disk=’E:\dvbbs.bak’</p>
<p>　　6、修复数据库</p>
<p>　　ALTER DATABASE [dvbbs] SET SINGLE_USER</p>
<p>　　GO</p>
<p>　　DBCC CHECKDB(‘dvbbs’,repair_allow_data_loss) WITH TABLOCK</p>
<p>　　GO</p>
<p>　　ALTER DATABASE [dvbbs] SET MULTI_USER</p>
<p>　　GO</p>
<p>　　7、日志清除</p>
<p>　　SET NOCOUNT ON</p>
<p>　　DECLARE @LogicalFileName sysname,</p>
<p>　　@MaxMinutes INT,</p>
<p>　　@NewSize INT</p>
<p>　　USE tablename – 要操作的数据库名</p>
<p>　　SELECT @LogicalFileName = ‘tablename_log’, – 日志文件名</p>
<p>　　@MaxMinutes = 10, – Limit on time allowed to wrap log.</p>
<p>　　@NewSize = 1 – 你想设定的日志文件的大小(M)</p>
<p>　　Setup / initialize</p>
<p>　　DECLARE @OriginalSize int</p>
<p>　　SELECT @OriginalSize = size</p>
<p>　　FROM sysfiles</p>
<p>　　WHERE name = @LogicalFileName</p>
<p>　　SELECT ‘Original Size of ‘ + db_name() + ‘ LOG is ‘ +</p>
<p>　　CONVERT(VARCHAR(30),@OriginalSize) + ‘ 8K pages or ‘ +</p>
<p>　　CONVERT(VARCHAR(30),(@OriginalSize*8/1024)) + ‘MB’</p>
<p>　　FROM sysfiles</p>
<p>　　WHERE name = @LogicalFileName</p>
<p>　　CREATE TABLE DummyTrans</p>
<p>　　(DummyColumn char (8000) not null)</p>
<p>　　DECLARE @Counter INT,</p>
<p>　　@StartTime DATETIME,</p>
<p>　　@TruncLog VARCHAR(255)</p>
<p>　　SELECT @StartTime = GETDATE(),</p>
<p>　　@TruncLog = ‘BACKUP LOG ‘ + db_name() + ‘ WITH TRUNCATE_ONLY’</p>
<p>　　DBCC SHRINKFILE (@LogicalFileName, @NewSize)</p>
<p>　　EXEC (@TruncLog)</p>
<p>　　– Wrap the log if necessary.</p>
<p>　　WHILE @MaxMinutes &gt; DATEDIFF (mi, @StartTime, GETDATE()) – time has not expired</p>
<p>　　AND @OriginalSize = (SELECT size FROM sysfiles WHERE name = @LogicalFileName)</p>
<p>　　AND (@OriginalSize * 8 /1024) &gt; @NewSize</p>
<p>　　BEGIN – Outer loop.</p>
<p>　　SELECT @Counter = 0</p>
<p>　　WHILE ((@Counter &lt; @OriginalSize / 16) AND (@Counter &lt; 50000))</p>
<p>　　BEGIN – update</p>
<p>　　INSERT DummyTrans VALUES (‘Fill Log’) DELETE DummyTrans</p>
<p>　　SELECT @Counter = @Counter + 1</p>
<p>　　END</p>
<p>　　EXEC (@TruncLog)</p>
<p>　　END</p>
<p>　　SELECT ‘Final Size of ‘ + db_name() + ‘ LOG is ‘ +</p>
<p>　　CONVERT(VARCHAR(30),size) + ‘ 8K pages or ‘ +</p>
<p>　　CONVERT(VARCHAR(30),(size*8/1024)) + ‘MB’</p>
<p>　　FROM sysfiles</p>
<p>　　WHERE name = @LogicalFileName</p>
<p>　　DROP TABLE DummyTrans</p>
<p>　　SET NOCOUNT OFF</p>
<p>　　8、说明：更改某个表</p>
<p>　　exec sp_changeobjectowner ‘tablename’,’dbo’</p>
<p>　　9、存储更改全部表</p>
<p>　　CREATE PROCEDURE dbo.User_ChangeObjectOwnerBatch</p>
<p>　　@OldOwner as NVARCHAR(128),</p>
<p>　　@NewOwner as NVARCHAR(128)</p>
<p>　　AS</p>
<p>　　DECLARE @Name as NVARCHAR(128)</p>
<p>　　DECLARE @Owner as NVARCHAR(128)</p>
<p>　　DECLARE @OwnerName as NVARCHAR(128)</p>
<p>　　DECLARE curObject CURSOR FOR</p>
<p>　　select ‘Name’ = name,</p>
<p>　　‘Owner’ = user_name(uid)</p>
<p>　　from sysobjects</p>
<p>　　where user_name(uid)=@OldOwner</p>
<p>　　order by name</p>
<p>　　OPEN curObject</p>
<p>　　FETCH NEXT FROM curObject INTO @Name, @Owner</p>
<p>　　WHILE(@@FETCH_STATUS=0)</p>
<p>　　BEGIN</p>
<p>　　if @Owner=@OldOwner</p>
<p>　　begin</p>
<p>　　set @OwnerName = @OldOwner + ‘.’ + rtrim(@Name)</p>
<p>　　exec sp_changeobjectowner @OwnerName, @NewOwner</p>
<p>　　end</p>
<p>　　– select @name,@NewOwner,@OldOwner</p>
<p>　　FETCH NEXT FROM curObject INTO @Name, @Owner</p>
<p>　　END</p>
<p>　　close curObject</p>
<p>　　deallocate curObject</p>
<p>　　GO</p>
<p>　　10、SQL SERVER中直接循环写入数据</p>
<p>　　declare @i int</p>
<p>　　set @i=1</p>
<p>　　while @i&lt;30</p>
<p>　　begin</p>
<p>　　insert into test (userid) values(@i)</p>
<p>　　set @i=@i+1</p>
<p>　　end</p>
<p>　　案例：</p>
<p>　　有如下表，要求就裱中所有沒有及格的成績，在每次增長0.1的基礎上，使他們剛好及格:</p>
<p>　　Name score</p>
<p>　　Zhangshan 80</p>
<p>　　Lishi 59</p>
<p>　　Wangwu 50</p>
<p>　　Songquan 69</p>
<p>　　while((select min(score) from tb_table)&lt;60)</p>
<p>　　begin</p>
<p>　　update tb_table set score =score*1.01</p>
<p>　　where score&lt;60</p>
<p>　　if (select min(score) from tb_table)&gt;60</p>
<p>　　break</p>
<p>　　else</p>
<p>　　continue</p>
<p>　　end</p>
<h1 id="数据开发-经典"><a href="#数据开发-经典" class="headerlink" title="数据开发-经典"></a>数据开发-经典</h1><p>　　1.按姓氏笔画排序:</p>
<p>　　Select * From TableName Order By CustomerName Collate Chinese_PRC_Stroke_ci_as //从少到多</p>
<p>　　2.数据库加密:</p>
<p>　　select encrypt(‘原始密码’)</p>
<p>　　select pwdencrypt(‘原始密码’)</p>
<p>　　select pwdcompare(‘原始密码’,’加密后密码’) = 1–相同;否则不相同 encrypt(‘原始密码’)</p>
<p>　　select pwdencrypt(‘原始密码’)</p>
<p>　　select pwdcompare(‘原始密码’,’加密后密码’) = 1–相同;否则不相同</p>
<p>　　3.取回表中字段:</p>
<p>　　declare @list varchar(1000),</p>
<p>　　@sql nvarchar(1000)</p>
<p>　　select @list=@list+’,’+b.name from sysobjects a,syscolumns b where a.id=b.id and a.name=’表A’</p>
<p>　　set @sql=’select ‘+right(@list,len(@list)-1)+’ from 表A’</p>
<p>　　exec (@sql)</p>
<p>　　4.查看硬盘分区:</p>
<p>　　EXEC master..xp_fixeddrives</p>
<p>　　5.比较A,B表是否相等:</p>
<p>　　if (select checksum_agg(binary_checksum(*)) from A)</p>
<p>　　=</p>
<p>　　(select checksum_agg(binary_checksum(*)) from B)</p>
<p>　　print ‘相等’</p>
<p>　　else</p>
<p>　　print ‘不相等’</p>
<p>　　6.杀掉所有的事件探察器进程:</p>
<p>　　DECLARE hcforeach CURSOR GLOBAL FOR SELECT ‘kill ‘+RTRIM(spid) FROM master.dbo.sysprocesses</p>
<p>　　WHERE program_name IN(‘SQL profiler’,N’SQL 事件探查器’)</p>
<p>　　EXEC sp_msforeach_worker ‘?’</p>
<p>　　7.记录搜索:</p>
<p>　　开头到N条记录</p>
<p>　　Select Top N * From 表</p>
<p>　　——————————-</p>
<p>　　N到M条记录(要有主索引ID)</p>
<p>　　Select Top M-N * From 表 Where ID in (Select Top M ID From 表) Order by ID Desc</p>
<p>　　———————————-</p>
<p>　　N到结尾记录</p>
<p>　　Select Top N * From 表 Order by ID Desc</p>
<p>　　案例</p>
<p>　　例如1：一张表有一万多条记录，表的第一个字段 RecID 是自增长字段， 写一个SQL语句， 找出表的第31到第40个记录。</p>
<p>　　select top 10 recid from A where recid not in(select top 30 recid from A)</p>
<p>　　分析：如果这样写会产生某些问题，如果recid在表中存在逻辑索引。</p>
<p>　　select top 10 recid from A where……是从索引中查找，而后面的select top 30 recid from A则在数据表中查找，这样由于索引中的顺序有可能和数据表中的不一致，这样就导致查询到的不是本来的欲得到的数据。</p>
<p>　　解决方案</p>
<p>　　1， 用order by select top 30 recid from A order by ricid 如果该字段不是自增长，就会出现问题</p>
<p>　　2， 在那个子查询中也加条件：select top 30 recid from A where recid&gt;-1</p>
<p>　　例2：查询表中的最后以条记录，并不知道这个表共有多少数据,以及表结构。</p>
<p>　　set @s = ‘select top 1 * from T where pid not in (select top ‘ + str(@count-1) + ‘ pid from T)’</p>
<p>　　print @s exec sp_executesql @s</p>
<p>　　9：获取当前数据库中的所有用户表</p>
<p>　　select Name from sysobjects where xtype=’u’ and status&gt;=0</p>
<p>　　10：获取某一个表的所有字段</p>
<p>　　select name from syscolumns where id=object_id(‘表名’)</p>
<p>　　select name from syscolumns where id in (select id from sysobjects where type = ‘u’ and name = ‘表名’)</p>
<p>　　两种方式的效果相同</p>
<p>　　11：查看与某一个表相关的视图、存储过程、函数</p>
<p>　　select a.* from sysobjects a, syscomments b where a.id = b.id and b.text like ‘%表名%’</p>
<p>　　12：查看当前数据库中所有存储过程</p>
<p>　　select name as 存储过程名称 from sysobjects where xtype=’P’</p>
<p>　　13：查询用户创建的所有数据库</p>
<p>　　select * from master..sysdatabases D where sid not in(select sid from master..syslogins where name=’sa’)</p>
<p>　　或者</p>
<p>　　select dbid, name AS DB_NAME from master..sysdatabases where sid &lt;&gt; 0x01</p>
<p>　　14：查询某一个表的字段和数据类型</p>
<p>　　select column_name,data_type from information_schema.columns</p>
<p>　　where table_name = ‘表名’</p>
<p>　　15：不同服务器数据库之间的数据操作</p>
<p>　　–创建链接服务器</p>
<p>　　exec sp_addlinkedserver ‘ITSV ‘, ‘ ‘, ‘SQLOLEDB ‘, ‘远程服务器名或ip地址 ‘</p>
<p>　　exec sp_addlinkedsrvlogin ‘ITSV ‘, ‘false ‘,null, ‘用户名 ‘, ‘密码 ‘</p>
<p>　　–查询示例</p>
<p>　　select * from ITSV.数据库名.dbo.表名</p>
<p>　　–导入示例</p>
<p>　　select * into 表 from ITSV.数据库名.dbo.表名</p>
<p>　　–以后不再使用时删除链接服务器</p>
<p>　　exec sp_dropserver ‘ITSV ‘, ‘droplogins ‘</p>
<p>　　–连接远程/局域网数据(openrowset/openquery/opendatasource)</p>
<p>　　–1、openrowset</p>
<p>　　–查询示例</p>
<p>　　select * from openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)</p>
<p>　　–生成本地表</p>
<p>　　select * into 表 from openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)</p>
<p>　　–把本地表导入远程表</p>
<p>　　insert openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)</p>
<p>　　select *from 本地表</p>
<p>　　–更新本地表</p>
<p>　　update b</p>
<p>　　set b.列A=a.列A</p>
<p>　　from openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)as a inner join 本地表 b</p>
<p>　　on a.column1=b.column1</p>
<p>　　–openquery用法需要创建一个连接</p>
<p>　　–首先创建一个连接创建链接服务器</p>
<p>　　exec sp_addlinkedserver ‘ITSV ‘, ‘ ‘, ‘SQLOLEDB ‘, ‘远程服务器名或ip地址 ‘</p>
<p>　　–查询</p>
<p>　　select *</p>
<p>　　FROM openquery(ITSV, ‘SELECT * FROM 数据库.dbo.表名 ‘)</p>
<p>　　–把本地表导入远程表</p>
<p>　　insert openquery(ITSV, ‘SELECT * FROM 数据库.dbo.表名 ‘)</p>
<p>　　select * from 本地表</p>
<p>　　–更新本地表</p>
<p>　　update b</p>
<p>　　set b.列B=a.列B</p>
<p>　　FROM openquery(ITSV, ‘SELECT * FROM 数据库.dbo.表名 ‘) as a</p>
<p>　　inner join 本地表 b on a.列A=b.列A</p>
<p>　　–3、opendatasource/openrowset</p>
<p>　　SELECT *</p>
<p>　　FROM opendatasource( ‘SQLOLEDB ‘, ‘Data Source=ip/ServerName;User ID=登陆名;Password=密码 ‘ ).test.dbo.roy_ta</p>
<p>　　–把本地表导入远程表</p>
<p>　　insert opendatasource( ‘SQLOLEDB ‘, ‘Data Source=ip/ServerName;User ID=登陆名;Password=密码 ‘).数据库.dbo.表名</p>
<p>　　select * from 本地表</p>
<p>　　SQL Server基本函数</p>
<p>　　SQL Server基本函数</p>
<p>　　1.字符串函数 长度与分析用</p>
<p>　　1,datalength(Char_expr) 返回字符串包含字符数,但不包含后面的空格</p>
<p>　　2,substring(expression,start,length) 取子串，字符串的下标是从“1”，start为起始位置，length为字符串长度，实际应用中以len(expression)取得其长度</p>
<p>　　3,right(char_expr,int_expr) 返回字符串右边第int_expr个字符，还用left于之相反</p>
<p>　　4,isnull( check_expression , replacement_value )如果check_expression為空，則返回replacement_value的值，不為空，就返回check_expression字符操作类</p>
<p>　　5,Sp_addtype 自定義數據類型</p>
<p>　　例如：EXEC sp_addtype birthday, datetime, ‘NULL’</p>
<p>　　6,set nocount {on|off}</p>
<p>　　使返回的结果中不包含有关受 Transact-SQL 语句影响的行数的信息。如果存储过程中包含的一些语句并不返回许多实际的数据，则该设置由于大量减少了网络流量，因此可显著提高性能。SET NOCOUNT 设置是在执行或运行时设置，而不是在分析时设置。</p>
<p>　　SET NOCOUNT 为 ON 时，不返回计数(表示受 Transact-SQL 语句影响的行数)。</p>
<p>　　SET NOCOUNT 为 OFF 时，返回计数</p>
<p>　　常识</p>
<p>　　在SQL查询中：from后最多可以跟多少张表或视图：256</p>
<p>　　在SQL语句中出现 Order by,查询时，先排序，后取</p>
<p>　　在SQL中，一个字段的最大容量是8000，而对于nvarchar(4000),由于nvarchar是Unicode码。</p>
<p>#　　SQLServer2000同步复制技术实现步骤</p>
<h2 id="预备工作"><a href="#预备工作" class="headerlink" title="预备工作"></a>预备工作</h2><p>　　1.发布服务器,订阅服务器都创建一个同名的windows用户,并设置相同的密码,做为发布快照文件夹的有效访问用户</p>
<p>　　–管理工具</p>
<p>　　–计算机管理</p>
<p>　　–用户和组</p>
<p>　　–右键用户</p>
<p>　　–新建用户</p>
<p>　　–建立一个隶属于administrator组的登陆windows的用户(SynUser)</p>
<p>　　2.在发布服务器上,新建一个共享目录,做为发布的快照文件的存放目录,操作:</p>
<p>　　我的电脑–D:\ 新建一个目录,名为: PUB</p>
<p>　　–右键这个新建的目录</p>
<p>　　–属性–共享</p>
<p>　　–选择”共享该文件夹”</p>
<p>　　–通过”权限”按纽来设置具体的用户权限,保证第一步中创建的用户(SynUser) 具有对该文件夹的所有权限</p>
<p>　　–确定</p>
<p>　　3.设置SQL代理(SQLSERVERAGENT)服务的启动用户(发布/订阅服务器均做此设置)</p>
<p>　　开始–程序–管理工具–服务</p>
<p>　　–右键SQLSERVERAGENT</p>
<p>　　–属性–登陆–选择”此账户”</p>
<p>　　–输入或者选择第一步中创建的windows登录用户名(SynUser)</p>
<p>　　–”密码”中输入该用户的密码</p>
<p>　　4.设置SQL Server身份验证模式,解决连接时的权限问题(发布/订阅服务器均做此设置)</p>
<p>　　企业管理器</p>
<p>　　–右键SQL实例–属性</p>
<p>　　–安全性–身份验证</p>
<p>　　–选择”SQL Server 和 Windows”</p>
<p>　　–确定</p>
<p>　　5.在发布服务器和订阅服务器上互相注册</p>
<p>　　企业管理器</p>
<p>　　–右键SQL Server组</p>
<p>　　–新建SQL Server注册…</p>
<p>　　–下一步–可用的服务器中,输入你要注册的远程服务器名 –添加</p>
<p>　　–下一步–连接使用,选择第二个”SQL Server身份验证”</p>
<p>　　–下一步–输入用户名和密码(SynUser)</p>
<p>　　–下一步–选择SQL Server组,也可以创建一个新组</p>
<p>　　–下一步–完成</p>
<p>　　6.对于只能用IP,不能用计算机名的,为其注册服务器别名(此步在实施中没用到)</p>
<p>　　(在连接端配置,比如,在订阅服务器上配置的话,服务器名称中输入的是发布服务器的IP)</p>
<p>　　开始–程序–Microsoft SQL Server–客户端网络实用工具</p>
<p>　　–别名–添加</p>
<p>　　–网络库选择”tcp/ip”–服务器别名输入SQL服务器名</p>
<p>　　–连接参数–服务器名称中输入SQL服务器ip地址</p>
<p>　　–如果你修改了SQL的端口,取消选择”动态决定端口”,并输入对应的端口号</p>
<h2 id="正式配置"><a href="#正式配置" class="headerlink" title="正式配置"></a>正式配置</h2><p>　　1、配置发布服务器</p>
<p>　　打开企业管理器，在发布服务器(B、C、D)上执行以下步骤:</p>
<p>　　(1) 从[工具]下拉菜单的[复制]子菜单中选择[配置发布、订阅服务器和分发]出现配置发布和分发向导</p>
<p>　　(2) [下一步] 选择分发服务器 可以选择把发布服务器自己作为分发服务器或者其他sql的服务器(选择自己)</p>
<p>　　(3) [下一步] 设置快照文件夹</p>
<p>　　采用默认\servername\Pub</p>
<p>　　(4) [下一步] 自定义配置</p>
<p>　　可以选择:是,让我设置分发数据库属性启用发布服务器或设置发布设置</p>
<p>　　否,使用下列默认设置(推荐)</p>
<p>　　(5) [下一步] 设置分发数据库名称和位置 采用默认值</p>
<p>　　(6) [下一步] 启用发布服务器 选择作为发布的服务器</p>
<p>　　(7) [下一步] 选择需要发布的数据库和发布类型</p>
<p>　　(8) [下一步] 选择注册订阅服务器</p>
<p>　　(9) [下一步] 完成配置</p>
<p>　　2、创建出版物</p>
<p>　　发布服务器B、C、D上</p>
<p>　　(1)从[工具]菜单的[复制]子菜单中选择[创建和管理发布]命令</p>
<p>　　(2)选择要创建出版物的数据库，然后单击[创建发布]</p>
<p>　　(3)在[创建发布向导]的提示对话框中单击[下一步]系统就会弹出一个对话框。对话框上的内容是复制的三个类型。我们现在选第一个也就是默认的快照发布(其他两个大家可以去看看帮助)</p>
<p>　　(4)单击[下一步]系统要求指定可以订阅该发布的数据库服务器类型,</p>
<p>　　SQLSERVER允许在不同的数据库如 orACLE或ACCESS之间进行数据复制。</p>
<p>　　但是在这里我们选择运行”SQL SERVER 2000”的数据库服务器</p>
<p>　　(5)单击[下一步]系统就弹出一个定义文章的对话框也就是选择要出版的表</p>
<p>　　注意: 如果前面选择了事务发布 则再这一步中只能选择带有主键的表</p>
<p>　　(6)选择发布名称和描述</p>
<p>　　(7)自定义发布属性 向导提供的选择:</p>
<p>　　是 我将自定义数据筛选,启用匿名订阅和或其他自定义属性</p>
<p>　　否 根据指定方式创建发布 (建议采用自定义的方式)</p>
<p>　　(8)[下一步] 选择筛选发布的方式</p>
<p>　　(9)[下一步] 可以选择是否允许匿名订阅</p>
<p>　　1)如果选择署名订阅,则需要在发布服务器上添加订阅服务器</p>
<p>　　方法: [工具]-&gt;[复制]-&gt;[配置发布、订阅服务器和分发的属性]-&gt;[订阅服务器] 中添加</p>
<p>　　否则在订阅服务器上请求订阅时会出现的提示:改发布不允许匿名订阅</p>
<p>　　如果仍然需要匿名订阅则用以下解决办法</p>
<p>　　[企业管理器]-&gt;[复制]-&gt;[发布内容]-&gt;[属性]-&gt;[订阅选项] 选择允许匿名请求订阅</p>
<p>　　2)如果选择匿名订阅,则配置订阅服务器时不会出现以上提示</p>
<p>　　(10)[下一步] 设置快照 代理程序调度</p>
<p>　　(11)[下一步] 完成配置</p>
<p>　　当完成出版物的创建后创建出版物的数据库也就变成了一个共享数据库</p>
<p>　　有数据</p>
<p>　　srv1.库名..author有字段:id,name,phone,</p>
<p>　　srv2.库名..author有字段:id,name,telphone,adress</p>
<p>　　要求：</p>
<p>　　srv1.库名..author增加记录则srv1.库名..author记录增加</p>
<p>　　srv1.库名..author的phone字段更新，则srv1.库名..author对应字段telphone更新</p>
<p>　　–*/</p>
<p>　　–大致的处理步骤</p>
<p>　　–1.在 srv1 上创建连接服务器,以便在 srv1 中操作 srv2,实现同步</p>
<p>　　exec sp_addlinkedserver ‘srv2’,’’,’SQLOLEDB’,’srv2的sql实例名或ip’</p>
<p>　　exec sp_addlinkedsrvlogin ‘srv2’,’false’,null,’用户名’,’密码’</p>
<p>　　go</p>
<p>　　–2.在 srv1 和 srv2 这两台电脑中,启动 msdtc(分布式事务处理服务),并且设置为自动启动</p>
<p>　　。我的电脑–控制面板–管理工具–服务–右键 Distributed Transaction Coordinator–属性–启动–并将启动类型设置为自动启动</p>
<p>　　go</p>
<p>　　–然后创建一个作业定时调用上面的同步处理存储过程就行了</p>
<p>　　企业管理器</p>
<p>　　–管理</p>
<p>　　–SQL Server代理</p>
<p>　　–右键作业</p>
<p>　　–新建作业</p>
<p>　　–”常规”项中输入作业名称</p>
<p>　　–”步骤”项</p>
<p>　　–新建</p>
<p>　　–”步骤名”中输入步骤名</p>
<p>　　–”类型”中选择”Transact-SQL 脚本(TSQL)”</p>
<p>　　–”数据库”选择执行命令的数据库</p>
<p>　　–”命令”中输入要执行的语句: exec p_process</p>
<p>　　–确定</p>
<p>　　–”调度”项</p>
<p>　　–新建调度</p>
<p>　　–”名称”中输入调度名称</p>
<p>　　–”调度类型”中选择你的作业执行安排</p>
<p>　　–如果选择”反复出现”</p>
<p>　　–点”更改”来设置你的时间安排</p>
<p>　　然后将SQL Agent服务启动,并设置为自动启动,否则你的作业不会被执行</p>
<p>　　设置方法:</p>
<p>　　我的电脑–控制面板–管理工具–服务–右键 SQLSERVERAGENT–属性–启动类型–选择”自动启动”–确定.</p>
<p>　　–3.实现同步处理的方法2,定时同步</p>
<p>　　–在srv1中创建如下的同步处理存储过程</p>
<p>　　create proc p_process</p>
<p>　　as</p>
<p>　　–更新修改过的数据</p>
<p>　　update b set name=i.name,telphone=i.telphone</p>
<p>　　from srv2.库名.dbo.author b,author i</p>
<p>　　where b.id=i.id and</p>
<p>　　(b.name &lt;&gt; i.name or b.telphone &lt;&gt; i.telphone)</p>
<p>　　–插入新增的数据</p>
<p>　　insert srv2.库名.dbo.author(id,name,telphone)</p>
<p>　　select id,name,telphone from author i</p>
<p>　　where not exists(</p>
<p>　　select * from srv2.库名.dbo.author where id=i.id)</p>
<p>　　–删除已经删除的数据(如果需要的话)</p>
<p>　　delete b</p>
<p>　　from srv2.库名.dbo.author b</p>
<p>　　where not exists(</p>
<p>　　select * from author where id=b.id)</p>
<p>　　go</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[别了！华为8年理工女硕离职感言]]></title>
      <url>http://i90s.vip/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/2016/01/18/%E5%88%AB%E4%BA%86%EF%BC%81%E5%8D%8E%E4%B8%BA8%E5%B9%B4%E7%90%86%E5%B7%A5%E5%A5%B3%E7%A1%95%E7%A6%BB%E8%81%8C%E6%84%9F%E8%A8%80.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>作者简介：理工女硕，应届华为8年半，目前已经离开一年有余。<br>本文首发于个人公众号：末末书屋</p>
</blockquote>
<p>文章分了五个部分：</p>
<ol>
<li>毕业了（为什么离开）</li>
<li>那些挺尸而过的鸡血岁月（1~2年）</li>
<li>看上去很美（3~4年）</li>
<li>女汉子是怎样炼成的（5~6年）</li>
<li>你纵虐我千百遍，我亦待你如初恋（7~8年）</li>
</ol>
<p>一年前的十月，我离开了华为，不咸不淡。这个十月，和我一同入职的先生也离开了，心里的五味杂陈却异常凶猛的翻涌起来。过去的一年里，我还是称华为我们公司，因为我还是华为家属，生活里依然弥漫着熟悉的华为味道，还有机会在上研所美丽的园区溜达。可是从此以后，就真的和这里没有关系了，真真的告别了。于是提起笔，整理此刻的情绪和之前在华为的种种，留作纪念。</p>
<p>青春的纪念，家庭的纪念，一种生活方式的纪念。<a id="more"></a></p>
<h2 id="01-毕业了"><a href="#01-毕业了" class="headerlink" title="01 毕业了"></a>01 毕业了</h2><p>每个华为人都有过这样的感受：当身边有人离开的时候，就会不由得问自己，什么时候是我呢？是的，华为于我们而言，只是另一所大学，每年大批的小鲜肉投身而来，淬炼成精或自废武功之后又回归社会，我们称之为“毕业了”。我的学制八年半，研发系里几次调动，综合成绩B+，中规中矩的老实学生。</p>
<p>当主管问及离开原因的时候，我说，因为内心不平静。这是实话。白岩松说，不平静，就不会有幸福。我确实正在经历幸福感知迟钝。因为内心不平静，人在工作心在漫游，感觉在飘着，没有根基没有营养没有热情，只剩下麻木和日复一日的机械劳作。</p>
<p>为什么会不平静？</p>
<p>外因1：好奇害死猫。</p>
<p>从学校出来，就一头扎进华为的深渊，这么多年也不曾抬头看路。在华为这所大学里，基层小兵就像螺丝钉一样，严格的流程下，耕作自己的一亩三分田，不敢懈怠。而公司也像贴身保姆一样，提供了一整套的服务：食堂、便利店、健身房、机票、宿舍、协议酒店、不定期的文体活动、相亲、内部租房……于是从象牙塔里出来的孩子们，又换了象牙塔继续生活，这次还有酬劳。自从华为的自有酒庄莫赛尔出来后，探亲访友都改红酒了，高端大气上档次。</p>
<p>正是这些看似的好和方便，造就了一批有着特殊标签的“华为人”。大家一面享受着公司为提高工作效率而敞开的便捷，一面憧憬着外面的花花世界。对于已经看透的人来说，Hi，这一切就够了，干嘛自己浪费精力去折腾呢。可是——</p>
<p>每个人都是一条欲望之河，深浅不一而已，不经历一遭，定欲壑难平。而华为，其特殊之处恰恰在于，单纯和封闭。当然，加上占据一个人绝大多数醒着的时间，让这一体验丰富生活的环节缺失了。</p>
<p>于是，这只听到一星半点外边故事的猫，终于忍不住一跃而出，管它外面是什么。</p>
<p>外因2：狼和小羊的天然冲突。</p>
<p>华为的狼性众所周知。曾经有那么一年，还在我鸡血未凉的时候，做了个小主管，试图把自己改造成狼，以获取晋级擢升的通行证。发现自己狠不下来之后，就买来各种经典的管理书籍，企图成为一只按照文明社会规则行事的优雅的狼。无奈难行其道。一阵撕扯之后，继续做回小羊。</p>
<p>狼群里有一个著名的法则：“忍、狠、滚”。初入狼群，根基不稳，只能忍着。然后有两种选择，要么把自己训成更凶残的狼，这不光是对手下狠，对合作链的各个环节狠，更要对自己狠；要么滚蛋。三观不同，忍自难耐。那就滚吧。</p>
<p>小羊打心里还是更喜欢温润如玉，想春赏百花秋望月，一抔红泥悦身心。</p>
<p>内因1：温饱思淫欲。</p>
<p>有一次，在菲律宾和客户吃饭，对方一小伙让我教他说汉语。我问：“你都会说什么汉语啊”？“温饱思淫欲”，他教的，手指着对面正一脸坏笑的Jeff。“什么意思你知道吗”？“就是吃饱穿暖了开始想不该想的事”。正解！</p>
<p>人类一思考，上帝就发笑。可是吃饱穿暖了不想入非非还能干点啥呢。</p>
<p>这两年我最常琢磨的事：按照当前的节奏下去，再过十年，我会是什么样的一种状态？放眼身边年长的同事，无休止的加班，时间不能自主支配；脾气暴躁，纠结在无数细碎的事件里；茶余饭后抱怨公司的种种，然后继续隐忍做事。</p>
<p>以我在本领域的这点资质，真的可以预见到未来，这不是我想看到的自己。如果说一时的隐忍能换来以后的升华，或许还能坚持，但是我看不到。</p>
<p>当这个念头一闪，我就不能淡定了：这就是传说中一眼望穿的生活啊，任由残留的好年华继续原地打转？</p>
<p>内因2：所谓身心不一。</p>
<p>身边一直也不乏这样的同事：你跟他谈新技术，他眼里就发光。他工作起来，就像燃烧着的火球，熠熠生辉。让人好生羡慕。这就是所谓的干着自己所爱的事了吧，燃料自备，根本不需要外面煽风点火。可我不是，我越来越清楚自己的天赋不在这里。从骨子里说，我首先不热爱科学，更向往“采菊东篱下，悠然现南山”的农耕生活。直观点说呢，我对文字的热爱远远大于数字。这颗一直被我小心掩埋着的种子，这两年迅速膨胀，有种呼之欲出的感觉，再不由它抽枝展叶，恐怕要内伤了。</p>
<p>台湾作家小野的一篇“就算选错，人生也不会毁了”的文章火遍朋友圈，大概是因为大家都经历过那样的一种意识的变化。人生旅途的种种岔路选择，从了心，最终都会殊途同归。唯有经历和内化才能和自己归一，也唯有内外归一，内心才能平静。</p>
<p>所以，我想停下来，去寻找那件能让我满血复活并一路发光的事。很多人说，放弃多年的积累重新开始，机会成本太高了，而这个年龄也尴尬。我也没什么底气，只能自己上鸡汤：“每一天都是余生最年轻的一天”，“人生永远没有太晚的开始”。再也回不到二八芳龄重新选择人生的时候，就从了心吧，更何况——</p>
<p>过去的岁月也并非没有意义，这是人生旅程中最重要的一站，解决了温饱，锻炼了解决复杂问题的能力，宏观看事微观待物，思维缜密，抗压。这些都是生存的基础。</p>
<p>如我在告别信中写到：“当离别的时刻终于到来的时候，反而很平静，那些平日里的不满或者抱怨都随着时间的远去而平复了，剩下的只是眉间那习惯性的紧蹙，看来需要等待内心足够的阳光来舒展了。公司/工作无关好坏，只有适不适合自己，终日相伴，真的就像伴侣一样。你在这里呼吸和连接，这些氛围最终塑造了我们看到的彼此，我们是彼此的磁场。与其说这里不好，不如说在这里看不到更好的自己。”</p>
<p>那么，再见了，华为！最美的年华相遇，亦不曾辜负。从此开启后青春时代的新生活，遇见幸福，遇见更好的自己！</p>
<h2 id="那些挺尸而过的鸡血岁月"><a href="#那些挺尸而过的鸡血岁月" class="headerlink" title="那些挺尸而过的鸡血岁月"></a>那些挺尸而过的鸡血岁月</h2><p>多年前，一次七天长假过后，我问组里的同事，放假干嘛了。“挺尸七日”，守友说。何谓“挺尸”？就是每天都躺在床上，醒着就打游戏看电影，困了就睡觉，饿得不行了叫个外卖。</p>
<p>挺尸，够形象！虽说夸张了点，却是刚毕业的单身华为男的真实生活。可是为什么要这样呢？26岁的豆蔻年华，手里还有点小钱！</p>
<p>一、两遭</p>
<p>我试图把记忆拉回到2006年，那是四月初，北方春寒料峭。第一次乘飞机，前往深圳总部参加大队培训，就是外界说的洗脑。南国的湿气和热气一起涌来，青翠的草木，湛蓝的天空，那么温暖那么美。华为坂田基地，好阔。俨然非洲大陆华丽分割出的欧式庄园。我的小心脏是一阵乱颤。</p>
<p>早上五点起床，穿着短裤短袖跟着高大帅气的教官跑圈，强度挑战我的极限，反正每天都有人晕倒。然后火速在最近的食堂早饭。再一路狂奔回百草园宿舍冲澡换正装。临近八点，高跟鞋西服裙叮当蹁跹在华为大学培训中心的路上，春风无力杨柳纤，从此粉黛无颜色。上课内容无非是企业文化、信息安全、军训。大家的状态呢，打打瞌睡，悄悄议论下哪个班的教官更帅。这些传说中的国旗班退役士兵，可都颜值爆表。</p>
<p>说好的亮点呢？</p>
<p>每天第一节课前，教官点名，叫到名字的必须立马起立，用丹田之气发出最浑厚有力的“到”。这可难为了那些公主般纤弱矜持的女孩子和高冷忧郁的小王子，往往憋的满脸通红，连喊很多次才能通过。点名都能成为阴影？！女汉子和牲口修炼的第一步。点名完毕，开始分组展现前一天的学习内容。十八般武艺同台竞技，小品相声吹拉弹唱，我有一次也被组长安排朗诵了一首自己写的诗，至今想起来都脸红啊。</p>
<p>紧锣密鼓热血澎湃的两周，以一场辩论赛和一场华丽的文艺汇演结束。辩论赛的主题依旧，正方：“干一行爱一行”，反方：“爱一行干一行”。那当然是我所在的正方赢了，公司的文化导向。重点是，我们每天晚上排练改稿到十二点以后，那个缺觉，缺觉啊！可是我后来发现，我们辩论队的其他队员居然还参加了文艺汇演，午夜继续赶场。还没进入工作状态，已经弓拔弩张。</p>
<p>培训之初，辅导员就告知了加分扣分的规则，并扬言后面百分之五是要被淘汰的。而事实是，培训尚未结束，主动离开的人都占满名额了。公司更怕你走。但是我觉得这次洗脑极其成功，把学校时的一身懒散从筋骨里扒拉出来一顿锤炼，再灌上一脑子的鸡血，从此激情满怀，一颗红心向菊花。</p>
<p>回到上研所，开始为期三个月的实习。头几天，我是逍遥自在，每天八点到公司，然后六点就闪了。没有传说中的硝烟战火和无下限的加班啊。直到周五，阿贵委婉的跟我说：“咱们周二和周四是默认加班的，实习期呢，最好每天都加，多学点”。哦哦哦，我这才醒悟过来，原来我的导师出差不在，还没人跟我讲规则呢。好吧，就此开始加班生活。</p>
<p>导师为我制定了一份三个月的学习计划，Excel表格详细列着每周的学习重点，要有输出。于是，每周一就着主题，从前辈那里收集资料，周一到周四边看边总结，周五写学习笔记。接下来的一周会安排一晚给同事分享，当然，主要是前辈提问，说白了就是检验学习效果。那三个月里，毫无疑问，我是打足了鸡血，所有材料精读总结，学习笔记详尽规范。从第二个月开始，也接手一些简单的工作，不管繁琐还是无聊，我都当做圣旨一样认真完成。然后如愿，实习期结束，转正答辩成绩A，加了500元工资，评为优秀新员工。实习之初说的百分之五淘汰率呢？大概也是人家自己拍拍屁股走了。</p>
<p>二、三招</p>
<p>经过以上两遭，有主见有门路的孩子该走的都走了。留下来的可都根正苗红：接受华为文化、吃苦耐劳，关键是也没有其他退路可选，继续在这个大熔炉里修炼，不出两年活脱脱一个“华为人”。以下简称“华为男挺尸速成绝招”：</p>
<p>第一招：断网。公司不能上外网，不能用带摄像头的手机（华为智能手机横空出世后取消了），当然那会手机上网还没有，非工作电话不能超过五分钟。于是大家唯一的娱乐，就是午休前看行政服务之窗，主要是征婚栏目，一起品评美女。那个时候华为男挺受欢迎，有女人喜欢的几个优良品质：话少钱多闷骚。于是乎，审美社交慢慢也就局限在这个小圈子里了。江湖传言：如果你有同学长期联系不到，要么是死了，要么就是在华为。言之凿凿。</p>
<p>第二招：午睡。不是趴在桌上小憩。每个人方寸大小的办公桌底下卷着铺盖，午饭过后，铺盖一拉，关灯，男男女女相邻而眠，壮观且有仪式感，想起初中在学校的桌子椅子午睡的盛况。从医学角度来讲，午睡对身体有好处。对公司而言，午睡可以保证下午精力充沛的工作，这种精力还可以延续到晚上加班。反正午睡时间是从工作时长中扣除的，何乐而不为呢。完美实现所有醒着的时间都交给公司。</p>
<p>第三招：黑布鞋。不知道大队培训的时候为什么要着正装，装B两周后，来到自己工作的办公室，傻眼了。人家都是黑衣黑裤黑布鞋，你整个西装领带白衬衣，要不是挂着工牌还真像卖房的。从此这身行头压箱子底，从此跟时尚说Byebye。身处煤坑里的为数不多的小女子我也就不动穿衣打扮的念头了。这可省了不少银子，两年逛街的次数一只手都能数过来。那个时候人家老说我看起来还像个学生，现在才反应过来，言下之意就是你好土。</p>
<p>在闭关修炼的路上，每天的日子快得只能以眼睛的一开一合来记。全身心交给了公司，学习能力也前所未有的强大。带着项目边学边干，一个人跑供应商的生产线现学现卖，在自己的领域建立起品牌人脉。这种感觉就是竹子在地下伸展根茎四年后，呼啸而出，一日冲天。累是累，但丹田有股气心中有种希望，人是绽放的。有人说这个时候的成长一年顶五年，此言不虚。转眼两年就过去了，华为男挺尸之功练成。</p>
<p>一个普通人家的孩子在华为这个平台上鸡血奋斗的一段历程。表面上沉默着、黯淡着，但是内在悄悄的收获着，也喜悦着。所以当我回首之时，心里热热的，分明看到的是青春的光彩，在暗夜里，微微的闪耀着。这也许是华为能够给予的最值得经历的一段岁月。</p>
<p>初入职场，干货分享：<br>一、谦卑，空杯。不管在学校怎样叱咤风云，初入职场，不熟悉游戏规则，不熟悉业务的情况下，多听多问少说。</p>
<p>二、工作无小事。越是简单的工作越要用心做好，这是取得信任的垫脚石。</p>
<p>三、建立关系网。把自己工作相关的自下而上的链条打通，且先施人与方便。</p>
<h2 id="看上去很美"><a href="#看上去很美" class="headerlink" title="看上去很美"></a>看上去很美</h2><p>图片故事：华为今年初大规模投放的“烂脚”广告，我们的人生，痛，并快乐着。</p>
<p>挺尸而过的两年后，小鲜肉已经形容饱满，到了最好用的时候。配股分红，收入上扬。逢鸡血未凉之时，又是信心满怀之势，大有独步武林之心。看着年终晚会上那些获得总裁金牌的同事，西装革履体面的站在光环下，自己也踌躇满志。如果故事就此发展下去，一切看起来很美！</p>
<p>就像这样的一个下午，阳光刚刚收敛锋芒，我握着一杯从华为Coffee Inn买的柠檬百花红茶，在食堂的窗边坐下，摊开纸笔……</p>
<p>眼前，一整面的玻璃窗临水而落，窗外湖光山色：层次丰富的人工湖，垂柳拂过水面，清波荡漾，湖里随意摆放着石头，任鱼儿嬉戏。湖边缓坡，青草依依，各色树木各就其位。一幢石墙木梁的茅草屋静静伏在山坡上，质朴大气。抬起头，阳光从玻璃的屋顶倾洒下来，暖暖的，柔柔的。</p>
<p>偌大的食堂异常安静。操作间在封闭的区域，看不到大厨烹饪的场景也闻不到油烟。几位阿姨在拖地，远处传来摆放餐盘的碰撞声，几十条不同风味的餐线静候人潮。Coffee Inn小小的角落有些热闹，高脚椅上倚着喝咖啡的同事，或者和客户低声交谈，或者讨论问题。</p>
<p>食堂中心的墙壁上，大幅海报张贴着P7团队的功臣照片，无线的Fellow，高级专家介绍。英气睿智，一副功成名就的光鲜。</p>
<p>第一次以旁观者的身份自外端详，心若恍然。这真的是传说中劳动密集型，盛产屌丝的大菊厂吗？如果我是一个新来的求职者，就这短短的一瞥，或许会爱上这朵菊花。如果我的身份是记者，那么这一瞥以后，文字和舆论导向会发生什么变化呢。</p>
<p>你蜻蜓点水的一瞥，看上去很美。我身居其中，看到了什么？</p>
<p>作为体力好的中流砥柱，频繁被异地研发，少则三个月，多则一年。是和妻儿分离的深深的孤独感，以及无力改变跌入深渊的自责。“再不放我回去老婆就要离婚了”也不能成为筹码，这里最不缺的就是螺丝钉；</p>
<p>担任模块负责人，每每攻关到深夜毫无头绪的无助感，以及担心来日无法交差的焦虑。没有哪个项目是按部就班完成的，抢占先机靠的就是血肉长城；</p>
<p>成为项目经理，向上，应对领导们的一句句“我只要结果”、“不要告诉我理由”。向下，厮杀在各个领域，撞开部门墙，搅动僵化的流程，这是时时处处推动扯皮的支离破碎感。每经历一个项目就是一次皮开肉绽后的重生；</p>
<p>所谓的办公位，一张大长桌十几个人，是肩并肩眼对眼而坐的尴尬和嘈杂；</p>
<p>月末周六的例行加班延伸到每周六跑来公司，永远亏欠家人一个陪伴和假期；<br>婚假拖到快过期的日子才敢开口提出，只为了给伴侣一个交代；</p>
<p>心不甘情不愿的签下“奋斗者协议”，声称自愿放弃带薪年假和加班费时的屈辱。</p>
<p>没有社交没有朋友没有内心丰盈，遗立于世的惶惑不安……</p>
<p>十六万人，十六万个不容易的故事。有爱有恨，有荣耀有失落，有成长蜕变有麻木自弃。</p>
<p>而我，也由于部门业务的拆分，开始了差不多一年的深圳生活。那是蜜月的最后一天，我在丽江，接到领导电话：直接主管调离，由我顶上。在官本位思想盛行的中国，已然是好事。于是假期一结束就奔向深圳。短短一年，经历了三任主管，业务混乱，状况层出不穷。</p>
<p>然后有一天，在上班的途中，边骑自行车边想几件急需解决的棘手的事情，在进入地下车库全是细棱角的大坡时居然没有下车，而想起刹车时发现刹车坏了。然后我就飞了出去，脸朝地降落，顿时血腥四溅。我有点手足无措的站在地库入口，保安跑过来，塞给我一大团卫生纸，然后帮我叫了出租车。素不相识的同事一个个从身边漠然而过，带着华为人典型的目不斜视的表情。自己打车去了医院，车上短信请假交代工作。清洗缝针拍片，我也终于看到了自己的面目：左半边脸几乎全是伤，缝了六针。有一处掉了块肉，没法缝，医生说让它自己长吧，留疤在所难免。再检查其他地方，手掌、胳膊、腿、肩部也有多处创伤，青一块紫一块的。</p>
<p>后来一位我十分敬重的专家讲起，他曾经有一天早上，家中有事耽误了一会，为了赶上自己主持的重要会议，车子骑得飞快，然后在转弯的时候飞了，髋骨碎了。神奇的是，在家休养一年后回来，发现原来他认为极其重要的事情还是在他手里，毫无进展。看来，我们都高估了自己的重要性了。</p>
<p>多么痛的领悟！</p>
<p>再回到题图的“烂脚”，右脚看上去很美，是柔软华贵的鞋子和优美修长的脚踝，而舞者看到的却是左脚，一对变了形的支撑物。就像朋友离开体制内去大理写作经营客栈，你看到的是洱海的湖波和惬意的午后读书时光，而朋友眼里却是主妇般的琐碎劳作和生活脱离主航道的不安。</p>
<p>任老板说：“我们除了比别人少喝咖啡，多干点儿活，其实我们不比别人有什么长处。就是因为我们起步太晚，我们成长的年限太短，积累的东西太少，我们得比别人多吃苦一点，所以我们这有一只是芭蕾脚，一只很烂的脚，我觉得就是华为的人，痛并快乐着，华为就是那么一只烂脚”。</p>
<p>罗曼.罗兰说：“人生是艰苦的。对不甘于平庸凡俗的人那是一场无日无夜的斗争，往往是悲惨的、没有光华的、没有幸福的，在孤独与静寂中展开的斗争。……他们只能依靠自己，可是有时连最强的人都不免于在苦难中蹉跎”。</p>
<p>任何一件超越平凡的事情背后，都是超乎寻常的付出。乔布斯的“只有偏执狂才能生存”，不仅自虐也虐人。富士康无比精准高效的产线，生产着奢侈电子产品的同时，也扼杀着工业时代一个个年轻孩子生命的光芒。而华为，在成长为民族自豪的路上，又践踏着多少普通人的尊严和梦想。他们却在不同的维度推动着文明的发展，丰富着人们的生活。无疑又是伟大的。</p>
<p>夕阳开始下斜，要下班了，好吧，收笔，最后一瞥窗外的惊艳。多么美好的年华，如春林初盛，春草初长，可纵是莺歌燕舞春风十里也不如你呀。前行的路上，好自珍重！</p>
<p>此文初稿于2014.8.22下午，上研所食堂</p>
<p>独挡一面、渐成中流砥柱，干货分享：<br>一、不要拿自己的身体健康当筹码，除非人命关天，否则“必须、马上”是不成立的；</p>
<p>二、察人用人，让团队里的每个人发挥特有的价值，“扬长避短”为上策；</p>
<p>三、做自己长期的职业规划，不适合就转身，机会成本还不算高。</p>
<h2 id="女汉子是怎样炼成的"><a href="#女汉子是怎样炼成的" class="headerlink" title="女汉子是怎样炼成的"></a>女汉子是怎样炼成的</h2><p>一整天的忙碌，会议、电话、问题确认、方案分析…..感觉大脑就像一个立体的交通枢纽，各种交通工具飞驰而过，危险重重又不容喘息懈怠。</p>
<p>突然抬起头，下意识的扫了眼时间，下午五点整。看着办公室里处处忙碌着的同事们，就像刚从一场耗费体力的梦中醒来，有点不真实。我站起身，试图舒展一下僵硬的肩颈，一个女同事吸引了我的目光：她正在和一群高大的男同事讨论问题，个个言辞激烈，瘦瘦小小的她站在中间，极力维持场面。总是这样的，每天的我也是在这样一个男性军团里奋战。我认真注视她的脸，这是一张枯黄的脸，没有血色，缺乏水分，脑子里突然冒出一个词，枯叶。是的，就像无数个加完班的夜晚，我在镜子里近距离看到的自己的脸一样。脸上没有任何粉饰，甚至连润肤露滋润过的痕迹都没有。也许清晨是有高级护肤品涂抹的，经过近十个小时和电脑屏幕的亲密对视，现在已然失效。这张脸除了清瘦的轮廓，扎着的马尾辫，似乎找不到其它女性特质了。我又开始注意她的衣着，中规中矩的毛衣，牛仔裤，平底皮鞋，松松垮垮，色调黯淡。没有明艳和婀娜，更谈不上时尚，跟大多数的研发女孩一样。</p>
<p>目力所及，也活动着其它女同事的身影，我行着注目礼一一扫过。一位新晋级的妈妈，正急匆匆的从水房拿了吸奶器奔进旁边的小黑屋，一个从外研所派过来的新婚燕尔的女孩，灌了一保温杯的白开水离开了。一样心事重重的眼睛，少有神采，是谁说的，就好像蒙着一层灰。哎呦，刚刚应届入职的小龙女走过，气场非凡。稚气未脱的脸上洋溢着光彩，眼里多少有点诚惶诚恐，但还是冒着光。我不禁莞尔，就像看到多年前那个鲜活的自己。</p>
<p>叮铃铃，电话响起，三分钟的走神时间结束。一边拿起电话，一边把小心脏抚慰妥帖。在狼群里混战六年，慢慢学着放过自己。但凡所发之事，一定有解，时间机缘而已。对着电话里的怒吼也好，争辩罢好，平心静气。</p>
<p>转眼，下班时间到了，办公室没有出现瞬间喧闹的景象，反正晚上不是培训就是开会，那种颤抖着小心肝等待下班的事情是没有的。如果你下定决心正常下班，那一定得捱着墙角悄悄开溜，否则拎着包的你会在楼道里在电梯间听到诸如此类的祝福：“好幸福啊，晚上不用加班”、“这么早就走了”、“回家了”……有时候挺羡慕隔离写字楼里的女孩子，踩着恨天高挤在打卡机旁，叽叽喳喳，然后相约逛街呀美食呀，一派世俗的烟火味，却也热气腾腾。而我们，走到几步之遥的公司食堂完成果腹这件事，然后接着工作。</p>
<p>记得刚入职的一天，在办公位接到一个电话，我一应声，人家就问我是不是秘书。“不是的，你为什么这么说呢”？“这个部门除了秘书都是男的呀”。我才知道，一百多人的部门，从我们那年开始，招了三个女的。此后，一批批高学历的理工女，幼时父亲怀里温柔的小情人，求学路上的学霸，前赴后继，投身到这狼性十足的雄性军团。撇去女性特质，收敛起美丽的羽翼，隐匿感性的一面，和男人一起撸起袖子扛仪器、独自海外现场调试、通宵攻关……从一个角度看，这是另一种美，我曾经深深向往的美，经济独立，和男人同工同酬，工作带娃两不误，社会戏称的女汉子。怎么听着跟大跃进时期的“铁姑娘”有点渊源呢。先生说这可是千百年来女人们自己争取的；从另一个角度看，就像今天我从梦魇中跳出来当一个旁观者，看到的是一支支花期错失阳光雨露而过早枯萎的花。</p>
<p>如果说高压工作的磨砺，给了女人一件硬朗的外壳，伪装成汉子，那么妈妈这个身份，使女汉子既成事实。研究生毕业工作个五六年，已过而立，该生孩子了。别人说一孕傻三年，我们是一孕毁三年。没时间让你傻，孕期该干啥干啥，哺乳期那是战斗着的生活。华为规定，女性自怀孕之日起三年内不配股。从此，女汉子的职业生涯急转直下。是的，孩子不在爸爸肚子里，但生出来了也是在同一个家庭里，爸爸却被真空了。妈妈可以一晚上多次哺乳哄睡，然后第二天更努力的工作，以免不被公司待见。爸爸自个在清净地方酣睡。家长会、兴趣班那也是妈妈们的天下。</p>
<p>都说女人的母性是天生的，再经过十个月孕期的亲密共振，一发不可收拾。于是，抚育幼子这事自古而今天然的落到了女人身上，即使在这个女人也同样外出狩猎的年代。而对男人来讲，那颗射中的子弹和其他的并无二致，所以父性是靠社会来培养的。一直以来的社会和职场环境只给了男人狩猎的压力，并没有做父亲的压力。自动自发的父性都不够，就在这不够里还参差不齐。女人就只能自行加血升级，炼成女汉子。随着二胎政策的放开，不知道会有多少女超人横空出世。</p>
<p>“巧笑倩兮，美目盼兮”、“含辞未吐，气若幽兰”，老祖宗笔下的女子若生活在这个时代，想必也虎虎生威了，不过怎么看着那么可爱呢！所谓伊人，即使已经修炼成了女汉子，也不妨时时窥视一下自己的内心：可是二八芳龄时，心之所往的那个人？</p>
<p>此文初稿于2012.12.12，西安研究所</p>
<p>职场妈妈，干货分享：<br>一、能享受到的假期，该请就请，不同阶段，收获不同；</p>
<p>二、如果还准备在职场打拼，孩子的吃喝拉撒能外包的就外包，有限的时间和孩子进行高效的陪伴和精神沟通；</p>
<p>三、不是你对家庭付出的越多就越好，你的快乐明媚更重要。你就是家庭的气场，先照管好自己的身心。</p>
<h2 id="你纵虐我千百遍，我亦待你如初恋"><a href="#你纵虐我千百遍，我亦待你如初恋" class="headerlink" title="你纵虐我千百遍，我亦待你如初恋"></a>你纵虐我千百遍，我亦待你如初恋</h2><p>华为心声社区上有个帖子：一句话说说你对华为的感受，排名第一的是：“Welcome to join the conference”（欢迎加入电话会议）。众望所归吧！一天24小时内，不管何时何地，只要手机开机，都有听到这个美妙声音的可能，是女士甜美又职业的声音，邀您参加不知何故的各种电话会议。</p>
<p>某周六，晚上11:50分，伺候了一天孩子的我，刚收拾完，把自己摆到床上，手机响了（忘记静音了，罪过罪过），一看号码8100，立马接通。里面响起了悦耳的“Welcome to join the conference”，接着是一群男声的争吵。版本经理：“你还记得×××吗”？“不记得了，要查文档”。“那你现在能到公司来一趟吗”？被扰了睡眠的女儿此时正在旁边撕心裂肺的哭喊。“我……”沉默了一下：“这个数据我之前邮件发给过大家了，谁在公司查看一下就可以了”。“还有谁清楚”？……沉默，实在不想拉别人下水。“这个问题今晚必须解决”。“×××”。然后，电话里传来了呼叫别人的声音，“×××，你现在马上到公司来一趟……”“嗯，现在吗？……好吧”。我挂上电话，继续安慰身边哭啼不止的女儿，心有不安。</p>
<p>华为的男人已经沦为牲口，女汉子侥幸为人，窃喜吧。</p>
<p>某周六的下午，我正独自开车载着孩子在拥挤的二环，手机响了，没接。以我开车的水平，不到红灯停车是万不敢接的。过了一会又响了，没接。第三次、第四次响起。天哪，什么十万火急的大事啊！也不顾安危了，拿起手机，8100，接通以后“Welcome to join the conference”。一个男低音响起：“我在写×××特性文档，有个地方想跟你讨论下”。“着急吗？不急的话请发个邮件，我周一处理，这会开车不方便，或者到家了我给你打过去”。“就简单问一句……巴拉巴拉”。“你这个问题我两句话说不清楚，抱歉，回去打给你”。挂电话，还是性命要紧啊。</p>
<p>华为逻辑：我加班的时候，你也在加班吧，不然也得候着！</p>
<p>此般相虐之下，说实话，能在公司待个七、八年的，那必须是真爱。不管怎样的千疮百孔，依然不离不弃。即使最终因为各种各样的原因离开了，也是满怀不舍。更何况，于职场而言，华为还真是我的初恋，虽然并非一见钟情，但我是个没啥追求的人，一旦被相中了，就死心塌地的跟着了，这一恋就是八年。忽而转身，已是貌合神离，渐行渐远。</p>
<p>此篇翻过，再无后文。这个机会我就扎扎实实总结一下：你为何如此成功，又是如何情非所愿的将我抛弃？</p>
<p>第一，老板神一样存在的感召力。八年多的基层老兵，就连远距离瞻仰老板容颜的机会也没有过，但是老人家的那张脸却深深的刻在我的脑海里，如神明一般。记得大队培训的时候，观看老板的讲话视频，活生生一部英雄举重若轻的史诗。然后每人发了一本老板的文集，“华为的冬天”、“我的父亲母亲”等等，笔力洗练简洁又不乏侠骨柔肠，有力道有内涵，让我这个文青崇拜不已。之后每逢岁末或是变革，老板定会书文，指点江山，激扬文字。只要看到老板的文字，就能感受到华为热气腾腾的心跳，华为生命力正旺，老人家眼力正毒，华为大船航道很正。心里满满的安全感。</p>
<p>第二，执行力。上面的两件小事可管中窥豹。多年以来自上而下一脉相承，带着军队的色彩。比如项目变动，大领导会立刻电话给分管的领导，分管的领导再找到责任主管，然后一层层传递到具体的执行人员，往往就是半个小时的事。于是，周末接到主管电话，交代下周一急需处理的事情很常见。我们响应快、效率高，对外深得客户喜欢；但也经常虚惊一场，对内给人的感觉是，领导们闻风而动，甚至草木皆兵。而这种执行力到了基层，往往还要用过头。自称炮灰的基层员工似乎成了成全领导业绩或者产品成功的机器，被用到没有尊严。“忍狠滚”法则顺势而生，基层员工一面隐忍，一面在有机会走上管理层后，更用力的效仿“狠”术，这简直就是职业通道晋升的不二法宝。简单粗暴成风。</p>
<p>第三，团体作战。这是一幅群狼共舞的画卷，势如破竹。常规项目，自运作之日起组成联合舰队，封闭起来头脑风暴，协作开发，头狼拥有绝对的领导权。遇上突发或重量级项目，人力和资源分分钟到位，豪华顶配。接下来就是不眠不休的混战。于是战无不胜攻无不克的神话，对于这个时刻都处于一级战备状态的狼群来说，毫不意外。去年，三星中国撤掉一些研发中心，被裁人员说到以后的出路时笑称：“归顺大华为”。</p>
<p>第四，流程。保证了运作的稳定性，产品的可靠性，缺谁都可以，每个环节的人在上层看来就是流水线上的螺丝钉。这是工业文明发展的必经之路，而我们的文化，却还蒙昧在官本位，管人比做技术有钱途，基层研发人员囿于一隅，却不能沉淀下来深耕，躁动又压抑着。自称研发狗，把公司称为脑力劳动密集型的大菊厂。我“司”改我“厂”，一把辛酸泪。</p>
<p>第五，物质刺激。对付屌丝有奇效。我们多数人来自农村或者小城市，曾经埋头苦读，现在吃苦耐劳，物质上缺乏安全感。就智力见解来讲，我们来自985和211，以西交大、西工大、西电、成电、哈工大居多。也就是说，我们不是最拔尖的一茬，那一茬已经被北大清华收获，毕业后由麦肯锡、四大、微软谷歌等知名外企收割。我们是次高的一茬，卑微的认定了自己的宿命。华为给予的物质刺激，在我们初步建立经济基础阶段，起着至关重要的作用，七到八年，跻身中产阶级，在一线城市站稳脚跟。傍着大船，闷在船舱，很多人就此不再扑闪，一门心思待下去。</p>
<p>第六、折腾。官方术语：艰苦奋斗。再形象点，就是长勺一直在华为的大锅里搅动，谁都别想安分。再或者说大老虎在狼群里追赶，谁都不敢停下喘息。在这里，你别妄想着找到一个又有钱又有闲的位置，然后老婆孩子热炕头的欢乐下去。舒服了会打瞌睡，会丧失斗志，所以稍有苗头就变革。不管是CEO轮值，地区部总裁平调，还是产品线合并重构，又及考评体系变革，无一不是为了人人不爽。为了保持新鲜血液，规避劳动法的十五年终身服役，员工满八年离职重新入职。薪酬体系，工作时间越长固定工资占总收入的比例越低，谁心里都清楚，除了工资，其他收入都是靠绩效获得的，好的绩效从哪里来呢？智力相差不大的时候，那就拼体力拼命吧。</p>
<p>记得工作的头四年，一到周日下午整个人就开始神经质，心跳加快，心神不安，因为宝贵的周末要结束了，接下来的工作就像巨石压在心头。到后来的麻木，因为习惯而麻木，这比当初的神经质更可怕。我心里明白，麻木的时候就是爱已疲劳了。八年多来，活得太用力。爱已淡，身已倦。</p>
<p>罗曼.罗兰说：“世界上只有一种真正的英雄主义，就是在认清生活真相之后仍然热爱生活”。大浪淘沙，向留下来的英雄们致以深深的敬意！</p>
<p>而我，就此别过。 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu下sublime 3安装Package Control的超简单方法]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2015/12/28/ubuntu%E4%B8%8Bsublime%203%E5%AE%89%E8%A3%85Package%20Control%E7%9A%84%E8%B6%85%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95.html</url>
      <content type="html"><![CDATA[<h3 id="简单的安装方法"><a href="#简单的安装方法" class="headerlink" title="简单的安装方法"></a>简单的安装方法</h3><p>使用Ctrl+`快捷键或者通过View-&gt;Show Console菜单打开命令行，粘贴如下代码：</p>
<blockquote>
<p>   import urllib.request,os; pf = ‘Package Control.sublime-package’; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf),’wb’).write(urllib.request.urlopen( ‘<a href="http://sublime.wbond.net/" target="_blank" rel="external">http://sublime.wbond.net/</a>‘ + pf.replace(‘ ‘,’%20’)).read())<br><a id="more"></a><br>如果顺利的话，此时就可以在Preferences菜单下看到Package Settings和Package Control两个菜单了。</p>
</blockquote>
<p>顺便贴下Sublime Text2 的代码：</p>
<blockquote>
<p>   import urllib2,os; pf=’Package Control.sublime-package’; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler( ))); open( os.path.join( ipp, pf), ‘wb’ ).write( urllib2.urlopen( ‘<a href="http://sublime.wbond.net/" target="_blank" rel="external">http://sublime.wbond.net/</a>‘ +pf.replace( ‘ ‘,’%20’ )).read()); print( ‘Please restart Sublime Text to finish installation’)</p>
</blockquote>
<h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><p>可能由于各种原因，无法使用代码安装，那可以通过以下步骤手动安装Package Control：</p>
<p>1.点击Preferences &gt; Browse Packages菜单</p>
<p>2.进入打开的目录的上层目录，然后再进入Installed Packages/目录</p>
<p>3.下载Package Control.sublime-package并复制到Installed Packages/目录</p>
<p>4.重启Sublime Text。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[结构体和链表（2）]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2015/12/28/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E9%93%BE%E8%A1%A8%EF%BC%882%EF%BC%89.html</url>
      <content type="html"><![CDATA[<p>我们以上面的程序为基础，但为了我们方便学习删除我们休整结构体为<br>struct test<br>{<br>int number;<br>float socre;<br>test *next;<br>};<br>number为唯一的编号每一个节点的。<br>删除的我就不多说了，里面重要部分有注解。<a id="more"></a><br>　 　特别注意deletel函数的参数意义，指针的引用在这里很重要，如果只是指针，或者只是应用都是不行的，为什么仔细思考，很多知名的教材在这一问题上 都很模糊，而且很多书还有错误，程序不错，但思路是错的，我这里特别不说，请大家仔细阅读程序，如果还是有问题，可以回此帖，我会回答的。</p>
<p>　　完整代码如下：</p>
<p>#include <iostream><br>using namespace std;<br>struct test<br>{<br>    int number;<br>    float socre;<br>     test <em>next;<br>};<br>test </em>head;//创建一个全局的引导进入链表的指针<br>test <em>create()<br>{<br>     test </em>ls;//节点指针<br>     test <em>le;//链尾指针<br>     ls = new test;//把ls指向动态开辟的堆内存地址<br>    cin&gt;&gt;ls-&gt;number&gt;&gt;ls-&gt;socre;<br>     head=NULL;//进入的时候先不设置head指针指向任何地址,因为不知道是否一上来就输入null跳出程序<br>     le=ls;//把链尾指针设置成刚刚动态开辟的堆内存地址,用于等下设置le-&gt;next,也就是下一个节点的位置<br>    while(ls-&gt;number!=0)//创建循环条件为ls-&gt;number的值不是null,用于循环添加节点<br>     {<br>        if(head==NULL)//判断是否是第一次进入循环<br>         {<br>             head=ls;//如果是第一次进入循环,那么把引导进入链表的指针指向第一次动态开辟的堆内存地址<br>         }<br>        else<br>         {<br>             le-&gt;next=ls;//如果不是第一次进入那么就把上一次的链尾指针的le-&gt;next指向上一次循环结束前动态创建的堆内存地址<br>         }<br>         le=ls;//设置链尾指针为当前循环中的节点指针,用于下一次进入循环的时候把上一次的节点的next指向上一次循环结束前动态创建的堆内存地址<br>         ls=new test;//为下一个节点在堆内存中动态开辟空间<br>        cin&gt;&gt;ls-&gt;number&gt;&gt;ls-&gt;socre;<br>     }<br>     le-&gt;next=NULL;//把链尾指针的next设置为空,因为不管如何循环总是要结束的,设置为空才能够在循环显链表的时候不至于死循环<br>    delete ls;//当结束的时候最后一个动态开辟的内存是无效的,所以必须清除掉<br>    return head;//返回链首指针<br>}<br>void showl(test </em>head)<br>{<br>    cout&lt;&lt;”链首指针:”&lt;<head<<endl; while(head)="" 以内存指向为null为条件循环显示先前输入的内容="" {="" cout<<head-="">number&lt;&lt;”|”&lt;<head->socre&lt;<endl; head="head-">next;<br>     }<br>}<br>void deletel(test <em>&amp;head,int number)//这里如果参数换成test </em>head,意义就完全不同了,head变成了复制而不是原有链上操作了,特别注意,很多书上都不对这里<br>{<br>     test <em>point;//判断链表是否为空<br>    if(head==NULL)<br>     {<br>        cout&lt;&lt;”链表为空,不能进行删除工作!”;<br>        return;<br>     }<br>    if(head-&gt;number==number)//判删除的节点是否为首节点<br>     {<br>         point=head;<br>        cout&lt;&lt;”删除点是链表第一个节点位置!”;<br>         head=head-&gt;next;//重新设置引导指针<br>        delete point;<br>        return;<br>     }<br>     test </em>fp=head;//保存连首指针<br>    for(test *&amp;mp=head;mp-&gt;next;mp=mp-&gt;next)<br>     {<br>        if(mp-&gt;next-&gt;number==number)<br>         {<br>             point=mp-&gt;next;<br>             mp-&gt;next=point-&gt;next;<br>            delete point;<br>             head=fp;//由于head的不断移动丢失了head,把进入循环前的head指针恢复!<br>            return;<br>         }<br>     }<br>}<br>void main()<br>{<br>     head=create();//调用创建<br>     showl(head);<br>    int dp;<br>    cin&gt;&gt;dp;<br>     deletel(head,dp);//调用删除<br>     showl(head);<br>    cin.get();<br>    cin.get();<br>}<br>最后我学习一下如何在已有的链表上插入节点<br>我们要考虑四中情况,<br>1.链表为空!<br>2.插入点在首节点前<br>3.插入点找不到的情况我们设置放在最后!<br>4.插入点在中间的情况!<br>今天的程序在昨天的基础上做了进一步的修改,可以避免删除点找不到的情况,如果找不到删除点就退出函数!</endl;></head-></head<<endl;></iostream></p>
<p>#include <iostream><br>using namespace std;<br>struct test<br>{<br>    int number;<br>    float socre;<br>     test <em>next;<br>};<br>test </em>head;//创建一个全局的引导进入链表的指针<br>test <em>create()<br>{<br>     test </em>ls;//节点指针<br>     test <em>le;//链尾指针<br>     ls = new test;//把ls指向动态开辟的堆内存地址<br>    cout&lt;&lt;”请输入第一个节点number和节点score,输入0.0跳出函数”&lt;<endl; cin="">&gt;ls-&gt;number&gt;&gt;ls-&gt;socre;<br>     head=NULL;//进入的时候先不设置head指针指向任何地址,因为不知道是否一上来就输入null跳出程序<br>     le=ls;//把链尾指针设置成刚刚动态开辟的堆内存地址,用于等下设置le-&gt;next,也就是下一个节点的位置<br>    while(ls-&gt;number!=0)//创建循环条件为ls-&gt;number的值不是null,用于循环添加节点<br>     {<br>        if(head==NULL)//判断是否是第一次进入循环<br>         {<br>             head=ls;//如果是第一次进入循环,那么把引导进入链表的指针指向第一次动态开辟的堆内存地址<br>         }<br>        else<br>         {<br>             le-&gt;next=ls;//如果不是第一次进入那么就把上一次的链尾指针的le-&gt;next指向上一次循环结束前动态创建的堆内存地址<br>         }<br>         le=ls;//设置链尾指针为当前循环中的节点指针,用于下一次进入循环的时候把上一次的节点的next指向上一次循环结束前动态创建的堆内存地址<br>         ls=new test;//为下一个节点在堆内存中动态开辟空间<br>        cout&lt;&lt;”请下一个节点number和节点score,输入0.0跳出函数”&lt;<endl; cin="">&gt;ls-&gt;number&gt;&gt;ls-&gt;socre;<br>     }<br>     le-&gt;next=NULL;//把链尾指针的next设置为空,因为不管如何循环总是要结束的,设置为空才能够在循环显链表的时候不至于死循环<br>    delete ls;//当结束的时候最后一个动态开辟的内存是无效的,所以必须清除掉<br>    return head;//返回链首指针<br>}<br>void showl(test </endl;></endl;></em>head)<br>{<br>    cout&lt;&lt;”链首指针:”&lt;<head<<endl; while(head)="" 以内存指向为null为条件循环显示先前输入的内容="" {="" cout<<head-="">number&lt;&lt;”|”&lt;<head->socre&lt;<endl; head="head-">next;<br>     }<br>}<br>void deletel(test <em>&amp;head,int number)//这里如果参数换成test </em>head,意义就完全不同了,head变成了复制而不是原有链上操作了,特别注意,很多书上都不对这里<br>{<br>     test <em>point;//判断链表是否为空<br>    if(head==NULL)<br>     {<br>        cout&lt;&lt;”链表为空,不能进行删除工作!”;<br>        return;<br>     }<br>    int derror=1;//设置找不到的情况的条件,预先设置为真<br>     test </em>check=head;<br>    while(check)//利用循环进行查找<br>     {<br>        if (check-&gt;number==number)<br>         {<br>             derror=0;//条件转为假<br>         }<br>         check=check-&gt;next;<br>     }<br>    if(derror)//如果为假就跳出函数<br>     {<br>        return;<br>     }<br>    if(head-&gt;number==number)//判删除的节点是否为首节点<br>     {<br>         point=head;<br>        cout&lt;&lt;”删除点是链表第一个节点位置!”;<br>         head=head-&gt;next;//重新设置引导指针<br>        delete point;<br>        return;<br>     }<br>     test <em>fp=head;//保存连首指针<br>    for(test </em>&amp;mp=head;mp-&gt;next;mp=mp-&gt;next)<br>     {<br>        if(mp-&gt;next-&gt;number==number)<br>         {<br>             point=mp-&gt;next;<br>             mp-&gt;next=point-&gt;next;<br>            delete point;<br>             head=fp;//由于head的不断移动丢失了head,把进入循环前的head指针恢复!<br>            return;<br>         }<br>     }<br>}<br>void insterl(int number)<br>{<br>     test <em>point=new test;<br>    cout&lt;&lt;”请输入节点number和节点score”&lt;<endl; cin="">&gt;point-&gt;number&gt;&gt;point-&gt;socre;<br>    if(head==NULL)//链表为空的情况下插入<br>     {<br>         head=point;<br>         point-&gt;next=NULL;<br>        return;<br>     }<br>    int ierror=1;//设置找不到的情况的条件,预先设置为真<br>     test </endl;></em>le;<br>     test <em>check=head;<br>    while(check)//利用循环进行查找<br>     {<br>        if (check-&gt;number==number)<br>         {<br>             ierror=0;//条件转为假<br>         }<br>         le=check;<br>         check=check-&gt;next;<br>     }<br>    if(ierror)<br>     {<br>        cout&lt;<le->number;<br>         le-&gt;next=point;<br>         point-&gt;next=NULL;<br>        return;<br>     }<br>   if(head-&gt;number==number)//检测是否是在第一个节点处插入<br>     {<br>         point-&gt;next=head;<br>         head=point;<br>        return;<br>     }<br>    for(test </le-></em>&amp;mp=head;mp-&gt;next;mp=mp-&gt;next)//在链表中间插入<br>     {<br>        if(mp-&gt;next-&gt;number==number)<br>         {<br>             point-&gt;next=mp-&gt;next;<br>             mp-&gt;next=point;<br>            return;<br>         }<br>     }<br>}<br>void main()<br>{<br>     head=create();//调用创建<br>     showl(head);<br>    int dp;<br>    cout&lt;&lt;”请输入删除点如果找不到就跳出函数”&lt;<endl; cin="">&gt;dp;<br>     deletel(head,dp);//调用删除<br>     showl(head);<br>    int ip;<br>    cout&lt;&lt;”请输入插入点如果找不到就在链尾添加”&lt;<endl; cin="">&gt;ip;<br>     insterl(ip);<br>     showl(head);<br>    cin.get();<br>    cin.get();<br>}</endl;></endl;></endl;></head-></head<<endl;></iostream></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[结构体和链表（1）]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2015/12/28/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E9%93%BE%E8%A1%A8%EF%BC%881%EF%BC%89.html</url>
      <content type="html"><![CDATA[<p>结构体可以看做是一种自定义的数据类型，它还有一个很重要的特性，就是结构体可以相互嵌套使用，但也是有条件的，结构体可以包含结构体指针，但绝对不能在结构体中包含结构体变量。<br>struct test<br>{<br>    char name[10];<br>    float socre;<br>     test *next;<br>};//这样是正确的!<a id="more"></a><br>struct test<br>{<br>    char name[10];<br>    float socre;<br>     test next;<br>};//这样是错误的!<br>　　利用结构体的这点特殊特性，我们就可以自己生成一个环环相套的一种射线结构，一个指向另一个。</p>
<p>链表的学习不像想象的那么那么容易，很多人学习到这里的时候都会碰到困难，很多人也因此而放弃了学习，在这里我说,一定不能放弃，对应它的学习我们要进 行分解式学习，方法很重要，理解需要时间，不必要把自己逼迫的那么紧，学习前你也得做一些最基本的准备工作，你必须具备对堆内存的基本知识的了解，还有就 是对结构体的基本认识，有了这两个重要的条件，再进行分解式学习就可以比较轻松的掌握这一节内容的难点。</p>
<p>下面我们给出一个完整的创建链表的程序，不管看的懂看不懂希望读者先认真看一下，想一想，看不懂没有关系，因为我下面会有分解式的教程，但之前的基本思考一定要做，要不即使我分解了你也是无从理解的。</p>
<p>代码如下，我在重要部分做了注解：</p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>struct test<br>{<br>    char name[10];<br>    float socre;<br>     test *next;<br>};</p>
<p>test *head;//创建一个全局的引导进入链表的指针</p>
<p>test <em>create()<br>{<br>     test </em>ls;//节点指针<br>     test *le;//链尾指针<br>     ls = new test;//把ls指向动态开辟的堆内存地址<br>    cin&gt;&gt;ls-&gt;name&gt;&gt;ls-&gt;socre;<br>     head=NULL;//进入的时候先不设置head指针指向任何地址,因为不知道是否一上来就输入null跳出程序<br>     le=ls;//把链尾指针设置成刚刚动态开辟的堆内存地址,用于等下设置le-&gt;next,也就是下一个节点的位置</p>
<pre><code>while(strcmp(ls-&gt;name,&quot;null&quot;)!=0)//创建循环条件为ls-&gt;name的值不是null,用于循环添加节点
 {
    if(head==NULL)//判断是否是第一次进入循环
     {
         head=ls;//如果是第一次进入循环,那么把引导进入链表的指针指向第一次动态开辟的堆内存地址
     }
    else
     {
         le-&gt;next=ls;//如果不是第一次进入那么就把上一次的链尾指针的le-&gt;next指向上一次循环结束前动态创建的堆内存地址
     }
     le=ls;//设置链尾指针为当前循环中的节点指针,用于下一次进入循环的时候把上一次的节点的next指向上一次循环结束前动态创建的堆内存地址
     ls=new test;//为下一个节点在堆内存中动态开辟空间
    cin&gt;&gt;ls-&gt;name&gt;&gt;ls-&gt;socre;
 }

 le-&gt;next=NULL;//把链尾指针的next设置为空,因为不管如何循环总是要结束的,设置为空才能够在循环显链表的时候不至于死循环
delete ls;//当结束的时候最后一个动态开辟的内存是无效的,所以必须清除掉
return head;//返回链首指针
</code></pre><p>}</p>
<p>void showl(test *head)<br>{<br>    cout&lt;&lt;”链首指针:”&lt;<head<<endl; while(head)="" 以内存指向为null为条件循环显示先前输入的内容="" {="" cout<<head-="">name&lt;&lt;”|”&lt;<head->socre&lt;<endl; head="head-">next;<br>     }<br>}</endl;></head-></head<<endl;></p>
<p>void main()<br>{<br>     showl(create());<br>    cin.get();<br>    cin.get();<br>}<br>　　上面的代码我们是要达到一个目的：就是要存储你输入的人名和他们的得分，并且以链状结构把它们组合成一个链状结构。</p>
<p>程序种有两个组成部分<br>test <em>create()<br>和<br>void showl(test </em>head)<br>这两个函数，create是用来创建链表的 ，showl是用来显示链表的。</p>
<p>create函数的返回类型是一个结构体指针，在程序调用的时候我们用了showl(create());，而不用引用的目的原因是引导指针是一个全局 指针变量，我们不能在showl()内改变它，因为showl()函数内有一个移动操作head=head-&gt;next;，如果是引用的话我们就破 坏了head指针的位置，以至于我们再也无法找会首地址的位置了。</p>
<p>下面我们来分解整个程序，以一个初学者的思想来思考整个程序，由浅入深的逐步解释。</p>
<p>首先，我们写这个程序，要考虑到由于是一个链表结构，我们不可能知道它的大小到底是多大，这个问题我们可以用动态开辟堆内存来解决，因为堆内存在程序结 束前始终是有效的，不受函数栈空间生命期的限制，但要注意的是我们必须有一个指针变量来存储这一链状结构的进入地址，而在函数内部来建立这一指针变量显然 是不合适的，因为函数一旦退出，这个指针变量也随之失效，所以我们在程序的开始声明了一个全局指针变量。<br>test *head;//创建一个全局的引导进入链表的指针<br>　　好解决了这两个问题，我们接下去思考</p>
<p>有输入就必然有输出，由于输出函数和输入函数是相对独立的，为了不断测试程序的正确性好调试我们先写好输出函数和main函数捏的调用，创建函数我们先约定好名为create。</p>
<p>我们先写出如下的代码：</p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>struct test<br>{<br>    char name[10];<br>    float socre;<br>     test *next;<br>};</p>
<p>test *head;//创建一个全局的引导进入链表的指针</p>
<p>test *create()<br>{</p>
<pre><code>return head;//返回链首指针
</code></pre><p>}</p>
<p>void showl(test *head)<br>{<br>    cout&lt;&lt;”链首指针:”&lt;<head<<endl; while(head)="" 以内存指向为null为条件循环显示先前输入的内容="" {="" cout<<head-="">name&lt;&lt;”|”&lt;<head->socre&lt;<endl; head="head-">next;<br>     }<br>}</endl;></head-></head<<endl;></p>
<p>void main()<br>{<br>     showl(create());<br>    cin.get();<br>    cin.get();<br>}<br>　　程序写到这里，基本形态已经出来，输入和调用我们已经有了。<br>　　下面我们来解决输入问题，链表的实现我们是通过循环输入来实现的，既然是循环我们就一定得考虑终止循环的条件，避免死循环和无效循环的发生。</p>
<p>　　在create()函数内部我们先写成这样：<br>test <em>create()<br>{<br>     test </em>ls;//节点指针<br>     test *le;//链尾指针<br>     ls = new test;//把ls指向动态开辟的堆内存地址<br>    cin&gt;&gt;ls-&gt;name&gt;&gt;ls-&gt;socre;<br>     head=NULL;//进入的时候先不设置head指针指向任何地址,因为不知道是否一上来就输入null跳出程序<br>     le=ls;//把链尾指针设置成刚刚动态开辟的堆内存地址,用于等下设置le-&gt;next,也就是下一个节点的位置</p>
<pre><code> le-&gt;next=NULL;//把链尾指针的next设置为空,因为不管如何循环总是要结束的,设置为空才能够在循环显链表的时候不至于死循环
delete ls;//当结束的时候最后一个动态开辟的内存是无效的,所以必须清除掉
return head;//返回链首指针
</code></pre><p>}<br>　　在循环创建之前我们必须考虑一个都不输入的情况。</p>
<p>程序一单进入create函数我们首先必然要创建一个节点，我们先创建一个节点指针，后把者个节点指针指向到动态开辟的test类型的动态内存地址位置上。</p>
<p>所以我们有了<br>test <em>ls;<br>ls = new test;<br>　　程序既然是循环输入，而结构成员test </em>next又是用来存储下一个接点的内存地址的，每次循环我们又要动态创建一个新的内存空间，所以我们必须要有一个指针来存储上一次循环动态开辟的内存地址，于是就有了<br>test *le;<br>　　接下来在进入循环前我们要创建链表的第一个节点，第一个节点必然是在循环外创建，于是就有了<br>cin&gt;&gt;ls-&gt;name&gt;&gt;ls-&gt;socre;<br>　　程序执行者的情况是位置的，所以我们必然要考虑，一上来就不想继续运行程序的情况，所以我们一开始先把head引导指针设置为不指向任何地址也就是<br>head=NULL;<br>　　为了符合le也就是链尾指针的设计思路，我们在循环前一定要保存刚刚动态开辟的内存地址，好在下一次循环的时候设置上一个节点中的next成员指向，于是我们便有了：<br>le=ls;<br>　　为了实现循环输入我们又了下面的代码：<br>while(strcmp(ls-&gt;name,”null”)!=0)<br>{<br>if(head==NULL)<br>{<br>head=ls;<br>}<br>else<br>{<br>le-&gt;next=ls;<br>}<br>le=ls;<br>ls=new test;<br>cin&gt;&gt;ls-&gt;name&gt;&gt;ls-&gt;socre;<br>}<br>　　程序是循环必然要有终止循环的条件，所以我们的循环条件是：<br>while(strcmp(ls-&gt;name,”null”)!=0)<br>　　输入的名字是null的时候就停止循环。</p>
<p>为了保证第一次进入循环，也就是在循环内准备创建第二个节点前，设置引导指针的指向我们有了如下的判断代码：<br>if(head==NULL)<br>{<br>head=ls;<br>}<br>else<br>{<br>le-&gt;next=ls;<br>}</p>
<p>代码中的else条件是为了设置前一个节点next指向而写的,这点我们记住先看下面的代码,稍后大家回过头想就明白了<br>le=ls;<br>ls=new test;<br>cin&gt;&gt;ls-&gt;name&gt;&gt;ls-&gt;socre;<br>　　le=ls;这么写就是为了保存上一次循环指针的位置而设的,正是为了上面的else代码而做的预先保留<br>ls=new test;<br>cin&gt;&gt;ls-&gt;name&gt;&gt;ls-&gt;socre;<br>　　这两行代码的意思就是继续开辟下一个节点空间,和输入节点内容!</p>
<p>循环一旦结束也就结束了程序,为了保持程序不出错,也就是最后一个节点的next成员指向为空我们有了下面的代码<br>le-&gt;next=NULL;<br>　　程序的思路始终是以先开辟后判断为思路的,所以到最后一个不成立的时候总会有一个多开辟的内存空间,为了删除掉它,我们有了下面的代码<br>delete ls;<br>　　程序到最后由于返回head指针<br>return head;<br>　　显示链表的函数没有什么太多特别的也只需要注意下面这样就可以了！<br>head=head-&gt;next;<br>　　我们之所以不用head+=1;来写就是因为链表是我们动态开辟的，而每一个节点的位置并不是相连的，next成员指针的意义也就是下一个节点的内存地址。<br>　　到这里整个创建函数的设计思路也都说完了，笔者不一定说的很好，但基本思路是这样的，希望读者多思考，多对比，相信此教程还是对大家有帮助的，程序设计就是利用逐步思考的方式进行的，写好的代码往往直接看看不懂就是因为中间的细节并不是一次都能够想到的。<br>　　下面我们来说一下链表节点的删除!</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[编程修养（3）]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2015/12/27/%E7%BC%96%E7%A8%8B%E4%BF%AE%E5%85%BB%EF%BC%883%EF%BC%89.html</url>
      <content type="html"><![CDATA[<h2 id="把相同或近乎相同的代码形成函数和宏"><a href="#把相同或近乎相同的代码形成函数和宏" class="headerlink" title="把相同或近乎相同的代码形成函数和宏"></a>把相同或近乎相同的代码形成函数和宏</h2><p>—————————————————————<br>有人说，最好的程序员，就是最喜欢“偷懒”的程序，其中不无道理。  </p>
<p>如果你有一些程序的代码片段很相似，或直接就是一样的，请把他们放在一个函数中。而如果</p>
<p>这段代码不多，而且会被经常使用，你还想避免函数调用的开销，那么就把他写成宏吧。 <a id="more"></a> </p>
<p>千万不要让同一份代码或是功能相似的代码在多个地方存在，不然如果功能一变，你就要修改</p>
<p>好几处地方，这种会给维护带来巨大的麻烦，所以，做到“一改百改”，还是要形成函数或是宏。  </p>
<h2 id="表达式中的括号"><a href="#表达式中的括号" class="headerlink" title="表达式中的括号"></a>表达式中的括号</h2><p>—————————  </p>
<p>如果一个比较复杂的表达式中，你并不是很清楚各个操作符的忧先级，即使是你很清楚优先级</p>
<p>，也请加上括号，不然，别人或是自己下一次读程序时，一不小心就看走眼理解错了，为了避</p>
<p>免这种“误解”，还有让自己的程序更为清淅，还是加上括号吧。  </p>
<p>比如，对一个结构的成员取地址：  </p>
<p>GetUserAge( &amp;( UserInfo-&gt;age ) );  </p>
<p>虽然，&amp;UserInfo-&gt;age中，-&gt;操作符的优先级最高，但加上一个括号，会让人一眼就看明白你的</p>
<p>代码是什么意思。  </p>
<p>再比如，一个很长的条件判断：  </p>
<p>if ( ( ch[0] &gt;= ‘0’ || ch[0] &lt;= ‘9’ ) &amp;&amp;<br>( ch[1] &gt;= ‘a’ || ch[1] &lt;= ‘z’ ) &amp;&amp;<br>( ch[2] &gt;= ‘A’ || ch[2] &lt;= ‘Z’ ) )  </p>
<p>括号，再加上空格和换行，你的代码是不是很容易读懂了？  </p>
<h2 id="函数参数中的const"><a href="#函数参数中的const" class="headerlink" title="函数参数中的const"></a>函数参数中的const</h2><p>———————————  </p>
<p>对于一些函数中的指针参数，如果在函数中只读，请将其用const修饰，这样，别人一读到你的</p>
<p>函数接口时，就会知道你的意图是这个参数是[in]，如果没有const时，参数表示[in/out]，注意函</p>
<p>数接口中的const使用，利于程序的维护和避免犯一些错误。  </p>
<p>虽然，const修饰的指针，如：const char* p，在C中一点用也没有，因为不管你的声明是不是</p>
<p>const，指针的内容照样能改，因为编译器会强制转换，但是加上这样一个说明，有利于程序的</p>
<p>阅读和编译。因为在C中，修改一个const指针所指向的内存时，会报一个Warning。这会引起程</p>
<p>序员的注意。  </p>
<p>C++中对const定义的就很严格了，所以C++中要多多的使用const，const的成员函数，const的</p>
<p>变量，这样会对让你的代码和你的程序更加完整和易读。（关于C++的const我就不多说了）  </p>
<h2 id="函数的参数个数（多了请用结构）"><a href="#函数的参数个数（多了请用结构）" class="headerlink" title="函数的参数个数（多了请用结构）"></a>函数的参数个数（多了请用结构）</h2><p>—————————————————  </p>
<p>函数的参数个数最好不要太多，一般来说6个左右就可以了，众多的函数参数会让读代码的人一</p>
<p>眼看上去就很头昏，而且也不利于维护。如果参数众多，还请使用结构来传递参数。这样做有</p>
<p>利于数据的封装和程序的简洁性。  </p>
<p>也利于使用函数的人，因为如果你的函数个数很多，比如12个，调用者很容易搞错参数的顺序</p>
<p>和个数，而使用结构struct来传递参数，就可以不管参数的顺序。  </p>
<p>而且，函数很容易被修改，如果需要给函数增加参数，不需要更改函数接口，只需更改结构体</p>
<p>和函数内部处理，而对于调用函数的程序来说，这个动作是透明的。  </p>
<h2 id="函数的返回类型，不要省略"><a href="#函数的返回类型，不要省略" class="headerlink" title="函数的返回类型，不要省略"></a>函数的返回类型，不要省略</h2><p>——————————————  </p>
<p>我看到很多程序写函数时，在函数的返回类型方面不太注意。如果一个函数没有返回值，也请</p>
<p>在函数前面加上void的修饰。而有的程序员偷懒，在返回int的函数则什么不修饰（因为如果不</p>
<p>修饰，则默认返回int），这种习惯很不好，还是为了原代码的易读性，加上int吧。  </p>
<p>所以函数的返回值类型，请不要省略。  </p>
<p>另外，对于void的函数，我们往往会忘了return，由于某些C/C++的编译器比较敏感，会报一些</p>
<p>警告，所以即使是void的函数，我们在内部最好也要加上return的语句，这有助于代码的编译。  </p>
<h2 id="goto语句的使用"><a href="#goto语句的使用" class="headerlink" title="goto语句的使用"></a>goto语句的使用</h2><p>—————————  </p>
<p>N年前，软件开发的一代宗师——迪杰斯特拉(Dijkstra)说过：“goto statment is harmful !!”，并建</p>
<p>议取消goto语句。因为goto语句不利于程序代码的维护性。  </p>
<p>这里我也强烈建议不要使用goto语句，除非下面的这种情况：  </p>
<p>#define FREE(p) if(p) { \<br>free(p); \<br>p = NULL; \<br>}  </p>
<p>main()<br>{<br>char <em>fname, </em>lname, *mname;  </p>
<p>fname = ( char* ) calloc ( 20, sizeof(char) );<br>if ( fname == NULL ){<br>goto ErrHandle;<br>}  </p>
<p>lname = ( char* ) calloc ( 20, sizeof(char) );<br>if ( lname == NULL ){<br>goto ErrHandle;<br>}  </p>
<p>mname = ( char* ) calloc ( 20, sizeof(char) );<br>if ( mname == NULL ){<br>goto ErrHandle;<br>}  </p>
<p>……  </p>
<p>ErrHandle:<br>FREE(fname);<br>FREE(lname);<br>FREE(mname);<br>ReportError(ERR_NO_MEMOEY);<br>}  </p>
<p>也只有在这种情况下，goto语句会让你的程序更易读，更容易维护。（在用嵌C来对数据库设置</p>
<p>游标操作时，或是对数据库建立链接时，也会遇到这种结构）  </p>
<h2 id="宏的使用"><a href="#宏的使用" class="headerlink" title="宏的使用"></a>宏的使用</h2><p>——————  </p>
<p>很多程序员不知道C中的“宏”到底是什么意思？特别是当宏有参数的时候，经常把宏和函数混淆</p>
<p>。我想在这里我还是先讲讲“宏”，宏只是一种定义，他定义了一个语句块，当程序编译时，编译</p>
<p>器首先要执行一个“替换”源程序的动作，把宏引用的地方替换成宏定义的语句块，就像文本文件</p>
<p>替换一样。这个动作术语叫“宏的展开”  </p>
<p>使用宏是比较“危险”的，因为你不知道宏展开后会是什么一个样子。例如下面这个宏：  </p>
<p>#define MAX(a, b) a&gt;b?a:b  </p>
<p>当我们这样使用宏时，没有什么问题： MAX( num1, num2 ); 因为宏展开后变成 num1&gt;num2?</p>
<p>num1:num2；。 但是，如果是这样调用的，MAX( 17+32, 25+21 ); 呢，编译时出现错误，原因</p>
<p>是，宏展开后变成：17+32&gt;25+21?17+32:25+21，哇，这是什么啊？  </p>
<p>所以，宏在使用时，参数一定要加上括号，上述的那个例子改成如下所示就能解决问题了。  </p>
<p>#define MAX( (a), (b) ) (a)&gt;(b)?(a)b)  </p>
<p>即使是这样，也不这个宏也还是有Bug，因为如果我这样调用 MAX(i++, j++); ， 经过这个宏以</p>
<p>后，i和j都被累加了两次，这绝不是我们想要的。  </p>
<p>所以，在宏的使用上还是要谨慎考虑，因为宏展开是的结果是很难让人预料的。而且虽然，宏</p>
<p>的执行很快（因为没有函数调用的开销），但宏会让源代码澎涨，使目标文件尺寸变大，（如</p>
<p>：一个50行的宏，程序中有1000个地方用到，宏展开后会很不得了），相反不能让程序执行得</p>
<p>更快（因为执行文件变大，运行时系统换页频繁）。  </p>
<p>因此，在决定是用函数，还是用宏时得要小心。  </p>
<h2 id="static的使用"><a href="#static的使用" class="headerlink" title="static的使用"></a>static的使用</h2><p>————————<br>static关键字，表示了“静态”，一般来说，他会被经常用于变量和函数。一个static的变量，其实</p>
<p>就是全局变量，只不过他是有作用域的全局变量。比如一个函数中的static变量：<br>char*<br>getConsumerName()<br>{<br>static int cnt = 0;  </p>
<p>….<br>cnt++;<br>….<br>}  </p>
<p>cnt变量的值会跟随着函数的调用次而递增，函数退出后，cnt的值还存在，只是cnt只能在函数</p>
<p>中才能被访问。而cnt的内存也只会在函数第一次被调用时才会被分配和初始化，以后每次进入</p>
<p>函数，都不为static分配了，而直接使用上一次的值。  </p>
<p>对于一些被经常调用的函数内的常量，最好也声明成static（参见第12条）  </p>
<p>但static的最多的用处却不在这里，其最大的作用的控制访问，在C中如果一个函数或是一个全</p>
<p>局变量被声明为static，那么，这个函数和这个全局变量，将只能在这个C文件中被访问，如果</p>
<p>别的C文件中调用这个C文件中的函数，或是使用其中的全局（用extern关键字），将会发生链</p>
<p>接时错误。这个特性可以用于数据和程序保密。  </p>
<h2 id="函数中的代码尺寸"><a href="#函数中的代码尺寸" class="headerlink" title="函数中的代码尺寸"></a>函数中的代码尺寸</h2><p>——————————<br>一个函数完成一个具体的功能，一般来说，一个函数中的代码最好不要超过600行左右，越少越</p>
<p>好，最好的函数一般在100行以内，300行左右的孙函数就差不多了。有证据表明，一个函数中</p>
<p>的代码如果超过500行，就会有和别的函数相同或是相近的代码，也就是说，就可以再写另一个</p>
<p>函数。  </p>
<p>另外，函数一般是完成一个特定的功能，千万忌讳在一个函数中做许多件不同的事。函数的功</p>
<p>能越单一越好，一方面有利于函数的易读性，另一方面更有利于代码的维护和重用，功能越单</p>
<p>一表示这个函数就越可能给更多的程序提供服务，也就是说共性就越多。  </p>
<p>虽然函数的调用会有一定的开销，但比起软件后期维护来说，增加一些运行时的开销而换来更</p>
<p>好的可维护性和代码重用性，是很值得的一件事。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[编程修养（2）]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2015/12/27/%E7%BC%96%E7%A8%8B%E4%BF%AE%E5%85%BB%EF%BC%882%EF%BC%89.html</url>
      <content type="html"><![CDATA[<h2 id="h和c文件的使用"><a href="#h和c文件的使用" class="headerlink" title="h和c文件的使用"></a>h和c文件的使用</h2><p>—————————<br>H文件和C文件怎么用呢？一般来说，H文件中是declare（声明），C文件中是define（定义）</p>
<p>。因为C文件要编译成库文件（Windows下是.obj/.lib，UNIX下是.o/.a），如果别人要使用你的</p>
<p>函数，那么就要引用你的H文件，所以，H文件中一般是变量、宏定义、枚举、结构和函数接口</p>
<p>的声明，就像一个接口说明文件一样。而C文件则是实现细节。<a id="more"></a>   </p>
<p>H文件和C文件最大的用处就是声明和实现分开。这个特性应该是公认的了，但我仍然看到有些</p>
<p>人喜欢把函数写在H文件中，这种习惯很不好。（如果是C++话，对于其模板函数，在VC中只</p>
<p>有把实现和声明都写在一个文件中，因为VC不支持export关键字）。而且，如果在H文件中写</p>
<p>上函数的实现，你还得在makefile中把头文件的依赖关系也加上去，这个就会让你的makefile很</p>
<p>不规范。  </p>
<p>最后，有一个最需要注意的地方就是：带初始化的全局变量不要放在H文件中！  </p>
<p>例如有一个处理错误信息的结构：  </p>
<p>char* errmsg[] = {<br>“No error”,<br>“Open file error”,<br>“Failed in sending/receiving a message”,<br>“Bad arguments”,<br>“Memeroy is not enough”,<br>“Service is down; try later”,<br>“Unknow information”,<br>“A socket operation has failed”,<br>“Permission denied”,<br>“Bad configuration file format”,<br>“Communication time out”,<br>……<br>……<br>};  </p>
<p>请不要把这个东西放在头文件中，因为如果你的这个头文件被5个函数库（.lib或是.a）所用到，</p>
<p>于是他就被链接在这5个.lib或.a中，而如果你的一个程序用到了这5个函数库中的函数，并且这</p>
<p>些函数都用到了这个出错信息数组。那么这份信息将有5个副本存在于你的执行文件中。如果你</p>
<p>的这个errmsg很大的话，而且你用到的函数库更多的话，你的执行文件也会变得很大。  </p>
<p>正确的写法应该把它写到C文件中，然后在各个需要用到errmsg的C文件头上加上 extern char*  </p>
<p>errmsg[]; 的外部声明，让编译器在链接时才去管他，这样一来，就只会有一个errmsg存在于执</p>
<p>行文件中，而且，这样做很利于封装。  </p>
<p>我曾遇到过的最疯狂的事，就是在我的目标文件中，这个errmsg一共有112个副本，执行文件</p>
<p>有8M左右。当我把errmsg放到C文件中，并为一千多个C文件加上了extern的声明后，所有的函</p>
<p>数库文件尺寸都下降了20%左右，而我的执行文件只有5M了。一下子少了3M啊。</p>
<p>［ 备注 ］<br>—————<br>有朋友对我说，这个只是一个特例，因为，如果errmsg在执行文件中存在多个副本时，可以加</p>
<p>快程序运行速度，理由是errmsg的多个复本会让系统的内存换页降低，达到效率提升。像我们</p>
<p>这里所说的errmsg只有一份，当某函数要用errmsg时，如果内存隔得比较远，会产生换页，反</p>
<p>而效率不高。  </p>
<p>这个说法不无道理，但是一般而言，对于一个比较大的系统，errmsg是比较大的，所以产生副</p>
<p>本导致执行文件尺寸变大，不仅增加了系统装载时间，也会让一个程序在内存中占更多的页面</p>
<p>。而对于errmsg这样数据，一般来说，在系统运行时不会经常用到，所以还是产生的内存换页</p>
<p>也就不算频繁。权衡之下，还是只有一份errmsg的效率高。即便是像logmsg这样频繁使用的的</p>
<p>数据，操作系统的内存调度算法会让这样的频繁使用的页面常驻于内存，所以也就不会出现内</p>
<p>存换页问题了。  </p>
<h2 id="出错信息的处理"><a href="#出错信息的处理" class="headerlink" title="出错信息的处理"></a>出错信息的处理</h2><p>—————————<br>你会处理出错信息吗？哦，它并不是简单的输出。看下面的示例：  </p>
<p>if ( p == NULL ){<br>printf ( “ERR: The pointer is NULL\n” );<br>}  </p>
<p>告别学生时代的编程吧。这种编程很不利于维护和管理，出错信息或是提示信息，应该统一处</p>
<p>理，而不是像上面这样，写成一个“硬编码”。第10条对这方面的处理做了一部分说明。如果要</p>
<p>管理错误信息，那就要有以下的处理：  </p>
<p>#define ERR_NO_ERROR 0  </p>
<p>#define ERR_OPEN_FILE 1  </p>
<p>#define ERR_SEND_MESG 2  </p>
<p>#define ERR_BAD_ARGS 3  </p>
<p>#define ERR_MEM_NONE 4  </p>
<p>#define ERR_SERV_DOWN 5  </p>
<p>#define ERR_UNKNOW_INFO 6  </p>
<p>#define ERR_SOCKET_ERR 7  </p>
<p>#define ERR_PERMISSION 8  </p>
<p>#define ERR_BAD_formAT 9  </p>
<p>#define ERR_TIME_OUT 10  </p>
<p>char* errmsg[] = {<br>“No error”,<br>“Open file error”,<br>“Failed in sending/receiving a message”,<br>“Bad arguments”,<br>“Memeroy is not enough”,<br>“Service is down; try later”,<br>“Unknow information”,<br>“A socket operation has failed”,<br>“Permission denied”,<br>“Bad configuration file format”,<br>“Communication time out”,<br>};  </p>
<p>long errno = 0;  </p>
<p>void perror( char* info)<br>{<br>if ( info ){<br>printf(“%s: %s\n”, info, errmsg[errno] );<br>return;<br>}  </p>
<p>printf(“Error: %s\n”, errmsg[errno] );<br>}  </p>
<p>这个基本上是ANSI的错误处理实现细节了，于是当你程序中有错误时你就可以这样处理：  </p>
<p>bool CheckPermission( char* userName )<br>{<br>if ( strcpy(userName, “root”) != 0 ){<br>errno = ERR_PERMISSION_DENIED;<br>return (FALSE);<br>}  </p>
<p>…<br>}  </p>
<p>main()<br>{<br>…<br>if (! CheckPermission( username ) ){<br>perror(“main()”);<br>}<br>…<br>}  </p>
<p>一个即有共性，也有个性的错误信息处理，这样做有利同种错误出一样的信息，统一用户界面</p>
<p>，而不会因为文件打开失败，A程序员出一个信息，B程序员又出一个信息。而且这样做，非常</p>
<p>容易维护。代码也易读。  </p>
<p>当然，物极必反，也没有必要把所有的输出都放到errmsg中，抽取比较重要的出错信息或是提</p>
<p>示信息是其关键，但即使这样，这也包括了大多数的信息。  </p>
<h2 id="常用函数和循环语句中的被计算量"><a href="#常用函数和循环语句中的被计算量" class="headerlink" title="常用函数和循环语句中的被计算量"></a>常用函数和循环语句中的被计算量</h2><p>—————————————————<br>看一下下面这个例子：  </p>
<p>for( i=0; i&lt;1000; i++ ){<br>GetLocalHostName( hostname );<br>…<br>}  </p>
<p>GetLocalHostName的意思是取得当前计算机名，在循环体中，它会被调用1000次啊。这是多</p>
<p>么的没有效率的事啊。应该把这个函数拿到循环体外，这样只调用一次，效率得到了很大的提</p>
<p>高。虽然，我们的编译器会进行优化，会把循环体内的不变的东西拿到循环外面，但是，你相</p>
<p>信所有编译器会知道哪些是不变的吗？我觉得编译器不可靠。最好还是自己动手吧。  </p>
<p>同样，对于常用函数中的不变量，如：  </p>
<p>GetLocalHostName(char* name)<br>{<br>char funcName[] = “GetLocalHostName”;  </p>
<p>sys_log( “%s begin……”, funcName );<br>…<br>sys_log( “%s end……”, funcName );<br>}  </p>
<p>如果这是一个经常调用的函数，每次调用时都要对funcName进行分配内存，这个开销很大啊。</p>
<p>把这个变量声明成static吧，当函数再次被调用时，就会省去了分配内存的开销，执行效率也很</p>
<p>好。  </p>
<h2 id="函数名和变量名的命名"><a href="#函数名和变量名的命名" class="headerlink" title="函数名和变量名的命名"></a>函数名和变量名的命名</h2><p>————————————<br>我看到许多程序对变量名和函数名的取名很草率，特别是变量名，什么a,b,c,aa,bb,cc，还有什</p>
<p>么flag1,flag2, cnt1, cnt2，这同样是一种没有“修养”的行为。即便加上好的注释。好的变量名或</p>
<p>是函数名，我认为应该有以下的规则：  </p>
<p>1) 直观并且可以拼读，可望文知意，不必“解码”。<br>2) 名字的长度应该即要最短的长度，也要能最大限度的表达其含义。<br>3) 不要全部大写，也不要全部小写，应该大小写都有，如：GetLocalHostName 或是  </p>
<p>UserAccount。<br>4) 可以简写，但简写得要让人明白，如：ErrorCode -&gt; ErrCode, ServerListener -&gt; ServLisner</p>
<p>，UserAccount -&gt; UsrAcct 等。<br>5) 为了避免全局函数和变量名字冲突，可以加上一些前缀，一般以模块简称做为前缀。<br>6) 全局变量统一加一个前缀或是后缀，让人一看到这个变量就知道是全局的。<br>7) 用匈牙利命名法命名函数参数，局部变量。但还是要坚持“望文生意”的原则。<br>8) 与标准库（如：STL）或开发库（如：MFC）的命名风格保持一致</p>
<h2 id="函数的传值和传指针"><a href="#函数的传值和传指针" class="headerlink" title="函数的传值和传指针"></a>函数的传值和传指针</h2><p>————————————<br>向函数传参数时，一般而言，传入非const的指针时，就表示，在函数中要修改这个指针把指内</p>
<p>存中的数据。如果是传值，那么无论在函数内部怎么修改这个值，也影响不到传过来的值，因</p>
<p>为传值是只内存拷贝。  </p>
<p>什么？你说这个特性你明白了，好吧，让我们看看下面的这个例程：  </p>
<p>void<br>GetVersion(char* pStr)<br>{<br>pStr = malloc(10);<br>strcpy ( pStr, “2.0” );<br>}  </p>
<p>main()<br>{<br>char* ver = NULL;<br>GetVersion ( ver );<br>…<br>…<br>free ( ver );<br>}  </p>
<p>我保证，类似这样的问题是一个新手最容易犯的错误。程序中妄图通过函数GetVersion给指针</p>
<p>ver分配空间，但这种方法根本没有什么作用，原因就是——这是传值，不是传指针。你或许会</p>
<p>和我争论，我分明传的时指针啊？再仔细看看，其实，你传的是指针其实是在传值。  </p>
<h2 id="修改别人程序的修养"><a href="#修改别人程序的修养" class="headerlink" title="修改别人程序的修养"></a>修改别人程序的修养</h2><p>———————————  </p>
<p>当你维护别人的程序时，请不要非常主观臆断的把已有的程序删除或是修改。我经常看到有的</p>
<p>程序员直接在别人的程序上修改表达式或是语句。修改别人的程序时，请不要删除别人的程序</p>
<p>，如果你觉得别人的程序有所不妥，请注释掉，然后添加自己的处理程序，必竟，你不可能</p>
<p>100%的知道别人的意图，所以为了可以恢复，请不依赖于CVS或是SourceSafe这种版本控制</p>
<p>软件，还是要在源码上给别人看到你修改程序的意图和步骤。这是程序维护时，一个有修养的</p>
<p>程序员所应该做的。  </p>
<p>如下所示，这就是一种比较好的修改方法：  </p>
<p>char<em> p = ( char</em> )calloc( 10, sizeof char );  </p>
<p>…  </p>
<p>当然，这种方法是在软件维护时使用的，这样的方法，可以让再维护的人很容易知道以前的代</p>
<p>码更改的动作和意图，而且这也是对原作者的一种尊敬。  </p>
<p>以“注释 — 添加”方式修改别人的程序，要好于直接删除别人的程序。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[编程修养（1）]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2015/12/27/%E7%BC%96%E7%A8%8B%E4%BF%AE%E5%85%BB%EF%BC%881%EF%BC%89.html</url>
      <content type="html"><![CDATA[<h2 id="版权和版本"><a href="#版权和版本" class="headerlink" title="版权和版本"></a>版权和版本</h2><p>———————<br>好的程序员会给自己的每个函数，每个文件，都注上版权和版本。  </p>
<p>对于C/C++的文件，文件头应该有类似这样的注释：  <a id="more"></a></p>
<p>而对于函数来说，应该也有类似于这样的注释：  </p>
<p>这样的描述可以让人对一个函数，一个文件有一个总体的认识，对代码的易读性和易维护性有</p>
<p>很大的好处 </p>
<h2 id="缩进、空格、换行、空行、对齐"><a href="#缩进、空格、换行、空行、对齐" class="headerlink" title="缩进、空格、换行、空行、对齐"></a>缩进、空格、换行、空行、对齐</h2><p>————————————————<br>i) 缩进应该是每个程序都会做的，只要学程序过程序就应该知道这个，但是我仍然看过不缩进</p>
<p>的程序，或是乱缩进的程序，如果你的公司还有写程序不缩进的程序员，请毫不犹豫的开除他</p>
<p>吧，并以破坏源码罪起诉他，还要他赔偿读过他程序的人的精神损失费。缩进，这是不成文规</p>
<p>矩，我再重提一下吧，一个缩进一般是一个TAB键或是4个空格。（最好用TAB键）  </p>
<p>ii) 空格。空格能给程序代来什么损失吗？没有，有效的利用空格可以让你的程序读进来更加赏</p>
<p>心悦目。而不一堆表达式挤在一起。看看下面的代码：  </p>
<p>ha=(ha<em>128+</em>key++)%tabPtr-&gt;size;  </p>
<p>ha = ( ha <em> 128 + </em>key++ ) % tabPtr-&gt;size;  </p>
<p>有空格和没有空格的感觉不一样吧。一般来说，语句中要在各个操作符间加空格，函数调用时</p>
<p>，要以各个参数间加空格。如下面这种加空格的和不加的：  </p>
<p>if ((hProc=OpenProcess(PROCESS_ALL_ACCESS,FALSE,pid))==NULL){<br>}  </p>
<p>if ( ( hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid) ) == NULL ){<br>}  </p>
<p>iii) 换行。不要把语句都写在一行上，这样很不好。如：  </p>
<p>for(i=0;i’9’)&amp;&amp;(a[i]&lt;’a’||a[i]&gt;’z’)) break;  </p>
<p>我拷，这种即无空格，又无换行的程序在写什么啊？加上空格和换行吧。  </p>
<p>for ( i=0; i if ( ( a[i] &lt; ‘0’ || a[i] &gt; ‘9’ ) &amp;&amp;<br>( a[i] &lt; ‘a’ || a[i] &gt; ‘z’ ) ) {<br>break;<br>}<br>}  </p>
<p>好多了吧？有时候，函数参数多的时候，最好也换行，如：  </p>
<p>CreateProcess(<br>NULL,<br>cmdbuf,<br>NULL,<br>NULL,<br>bInhH,<br>dwCrtFlags,<br>enVBuf,<br>NULL,<br>&amp;siStartInfo,<br>&amp;prInfo<br>);  </p>
<p>条件语句也应该在必要时换行：  </p>
<p>if ( ch &gt;= ‘0’ || ch &lt;= ‘9’ ||<br>ch &gt;= ‘a’ || ch &lt;= ‘z’ ||<br>ch &gt;= ‘A’ || ch &lt;= ‘Z’ )  </p>
<p>iv) 空行。不要不加空行，空行可以区分不同的程序块，程序块间，最好加上空行。如：  </p>
<p>HANDLE hProcess;<br>PROCESS_T procInfo;  </p>
<p>if((hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid)) == NULL)<br>{<br>return LSE_MISC_SYS;<br>}  </p>
<p>memset(&amp;procInfo, 0, sizeof(procInfo));<br>procInfo.idProc = pid;<br>procInfo.hdProc = hProcess;<br>procInfo.misc |= MSCAVA_PROC;  </p>
<p>return(0);  </p>
<p>v) 对齐。用TAB键对齐你的一些变量的声明或注释，一样会让你的程序好看一些。如：  </p>
<p>typedef struct _pt_man<em>t</em> {<br>int numProc;<br>int maxProc;<br>int numEvnt;<br>int maxEvnt;<br>HANDLE* pHndEvnt;<br>DWORD timeout;<br>HANDLE hPipe;<br>TCHAR usr[MAXUSR];<br>int numMsg;<br>int Msg[MAXMSG];<br>} PT_MAN_T;  </p>
<h2 id="程序注释"><a href="#程序注释" class="headerlink" title="程序注释"></a>程序注释</h2><p>i) 对于行注释（“//”）比块注释（“”）要好的说法，我并不是很同意。因为一些老版本的C编</p>
<p>译器并不支持行注释，所以为了你的程序的移植性，请你还是尽量使用块注释。  </p>
<p>ii) 你也许会为块注释的不能嵌套而不爽，那么你可以用预编译来完成这个功能。使用“#if 0”和</p>
<p>“#endif”括起来的代码，将不被编译，而且还可以嵌套。  </p>
<h2 id="函数的-in-out-参数"><a href="#函数的-in-out-参数" class="headerlink" title="函数的[in][out]参数"></a>函数的[in][out]参数</h2><p>———————————  </p>
<p>我经常看到这样的程序：<br>FuncName(char* str)<br>{<br>int len = strlen(str);<br>…..<br>}  </p>
<p>char<em><br>GetUserName(struct user</em> pUser)<br>{<br>return pUser-&gt;name;<br>}  </p>
<p>不！请不要这样做。  </p>
<p>你应该先判断一下传进来的那个指针是不是为空。如果传进来的指针为空的话，那么，你的一</p>
<p>个大的系统就会因为这一个小的函数而崩溃。一种更好的技术是使用断言（assert），这里我就</p>
<p>不多说这些技术细节了。当然，如果是在C++中，引用要比指针好得多，但你也需要对各个参</p>
<p>数进行检查。  </p>
<p>写有参数的函数时，首要工作，就是要对传进来的所有参数进行合法性检查。而对于传出的参</p>
<p>数也应该进行检查，这个动作当然应该在函数的外部，也就是说，调用完一个函数后，应该对</p>
<p>其传出的值进行检查。  </p>
<p>当然，检查会浪费一点时间，但为了整个系统不至于出现“非法操作”或是“Core Dump”的系统级</p>
<p>的错误，多花这点时间还是很值得的。  </p>
<h2 id="对系统调用的返回进行判断"><a href="#对系统调用的返回进行判断" class="headerlink" title="对系统调用的返回进行判断"></a>对系统调用的返回进行判断</h2><p>——————————————<br>继续上一条，对于一些系统调用，比如打开文件，我经常看到，许多程序员对fopen返回的指针</p>
<p>不做任何判断，就直接使用了。然后发现文件的内容怎么也读出不，或是怎么也写不进去。还</p>
<p>是判断一下吧：  </p>
<p>fp = fopen(“log.txt”, “a”);<br>if ( fp == NULL ){<br>printf(“Error: open file error\n”);<br>return FALSE;<br>}  </p>
<p>其它还有许多啦，比如：socket返回的socket号，malloc返回的内存。请对这些系统调用返回的</p>
<p>东西进行判断。</p>
<h2 id="if-语句对出错的处理"><a href="#if-语句对出错的处理" class="headerlink" title="if 语句对出错的处理"></a>if 语句对出错的处理</h2><p>———————————<br>我看见你说了，这有什么好说的。还是先看一段程序代码吧。<br>if ( ch &gt;= ‘0’ &amp;&amp; ch &lt;= ‘9’ ){  </p>
<p>}else{  </p>
<p>printf(“error ……\n”);<br>return ( FALSE );<br>}  </p>
<p>这种结构很不好，特别是如果“正常处理代码”很长时，对于这种情况，最好不要用else。先判断</p>
<p>错误，如：  </p>
<p>if ( ch &lt; ‘0’ || ch &gt; ‘9’ ){  </p>
<p>printf(“error ……\n”);<br>return ( FALSE );<br>}  </p>
<p>……  </p>
<p>这样的结构，不是很清楚吗？突出了错误的条件，让别人在使用你的函数的时候，第一眼就能</p>
<p>看到不合法的条件，于是就会更下意识的避免。  </p>
<h2 id="头文件中的-ifndef"><a href="#头文件中的-ifndef" class="headerlink" title="头文件中的#ifndef"></a>头文件中的#ifndef</h2><p>——————————<br>千万不要忽略了头件的中的#ifndef，这是一个很关键的东西。比如你有两个C文件，这两个C文</p>
<p>件都include了同一个头文件。而编译时，这两个C文件要一同编译成一个可运行文件，于是问</p>
<p>题来了，大量的声明冲突。  </p>
<p>还是把头文件的内容都放在#ifndef和#endif中吧。不管你的头文件会不会被多个文件引用，你都</p>
<p>要加上这个。一般格式是这样的：  </p>
<p>#ifndef &lt;标识&gt;  </p>
<p>#define &lt;标识&gt;  </p>
<p>……<br>……  </p>
<p>#endif  </p>
<p>&lt;标识&gt;在理论上来说可以是自由命名的，但每个头文件的这个“标识”都应该是唯一的。标识的</p>
<p>命名规则一般是头文件名全大写，前后加下划线，并把文件名中的“.”也变成下划线，如：</p>
<p>stdio.h  </p>
<p>#ifndef _STDIO<em>H</em>  </p>
<p>#define _STDIO<em>H</em>  </p>
<p>……  </p>
<p>#endif  </p>
<p>（BTW：预编译有多很有用的功能。你会用预编译吗？）  </p>
<h2 id="在堆上分配内存"><a href="#在堆上分配内存" class="headerlink" title="在堆上分配内存"></a>在堆上分配内存</h2><p>—————————<br>可能许多人对内存分配上的“栈 stack”和“堆 heap”还不是很明白。包括一些科班出身的人也不明</p>
<p>白这两个概念。我不想过多的说这两个东西。简单的来讲，stack上分配的内存系统自动释放，</p>
<p>heap上分配的内存，系统不释放，哪怕程序退出，那一块内存还是在那里。stack一般是静态分</p>
<p>配内存，heap上一般是动态分配内存。  </p>
<p>由malloc系统函数分配的内存就是从堆上分配内存。从堆上分配的内存一定要自己释放。用free</p>
<p>释放，不然就是术语——“内存泄露”（或是“内存漏洞”）—— Memory Leak。于是，系统的可分</p>
<p>配内存会随malloc越来越少，直到系统崩溃。还是来看看“栈内存”和“堆内存”的差别吧。  </p>
<p>栈内存分配<br>—————<br>char*<br>AllocStrFromStack()<br>{<br>char pstr[100];<br>return pstr;<br>}  </p>
<p>堆内存分配<br>—————<br>char<em><br>AllocStrFromHeap(int len)<br>{<br>char </em>pstr;  </p>
<p>if ( len &lt;= 0 ) return NULL;<br>return ( char* ) malloc( len );<br>}  </p>
<p>对于第一个函数，那块pstr的内存在函数返回时就被系统释放了。于是所返回的char*什么也没</p>
<p>有。而对于第二个函数，是从堆上分配内存，所以哪怕是程序退出时，也不释放，所以第二个</p>
<p>函数的返回的内存没有问题，可以被使用。但一定要调用free释放，不然就是Memory Leak！  </p>
<p>在堆上分配内存很容易造成内存泄漏，这是C/C++的最大的“克星”，如果你的程序要稳定，那么</p>
<p>就不要出现Memory Leak。所以，我还是要在这里千叮咛万嘱付，在使用malloc系统函数（包</p>
<p>括calloc，realloc）时千万要小心。  </p>
<p>记得有一个UNIX上的服务应用程序，大约有几百的C文件编译而成，运行测试良好，等使用时</p>
<p>，每隔三个月系统就是down一次，搞得许多人焦头烂额，查不出问题所在。只好，每隔两个月</p>
<p>人工手动重启系统一次。出现这种问题就是Memery Leak在做怪了，在C/C++中这种问题总是</p>
<p>会发生，所以你一定要小心。一个Rational的检测工作——Purify，可以帮你测试你的程序有没</p>
<p>有内存泄漏。  </p>
<p>我保证，做过许多C/C++的工程的程序员，都会对malloc或是new有些感冒。当你什么时候在使</p>
<p>用malloc和new时，有一种轻度的紧张和惶恐的感觉时，你就具备了这方面的修养了。  </p>
<p>对于malloc和free的操作有以下规则：  </p>
<p>1) 配对使用，有一个malloc，就应该有一个free。（C++中对应为new和delete）<br>2) 尽量在同一层上使用，不要像上面那种，malloc在函数中，而free在函数外。最好在同一调用</p>
<p>层上使用这两个函数。<br>3) malloc分配的内存一定要初始化。free后的指针一定要设置为NULL。  </p>
<p>注：虽然现在的操作系统（如：UNIX和Win2k/NT）都有进程内存跟踪机制，也就是如果你有没</p>
<p>有释放的内存，操作系统会帮你释放。但操作系统依然不会释放你程序中所有产生了Memory  </p>
<p>Leak的内存，所以，最好还是你自己来做这个工作。（有的时候不知不觉就出现Memory Leak</p>
<p>了，而且在几百万行的代码中找无异于海底捞针，Rational有一个工具叫Purify，可能很好的帮</p>
<p>你检查程序中的Memory Leak）  </p>
<h2 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h2><p>————————<br>接上一条，变量一定要被初始化再使用。C/C++编译器在这个方面不会像Java一样帮你初始化</p>
<p>，这一切都需要你自己来，如果你使用了没有初始化的变量，结果未知。好的程序员从来都会</p>
<p>在使用变量前初始化变量的。如：  </p>
<p>1) 对malloc分配的内存进行memset清零操作。（可以使用calloc分配一块全零的内存）<br>2) 对一些栈上分配的struct或数组进行初始化。（最好也是清零）  </p>
<p>不过话又说回来了，初始化也会造成系统运行时间有一定的开销，所以，也不要对所有的变量</p>
<p>做初始化，这个也没有意义。好的程序员知道哪些变量需要初始化，哪些则不需要。如：以下</p>
<p>这种情况，则不需要。  </p>
<p>char <em>pstr;<br>pstr = ( char</em> ) malloc( 50 );<br>if ( pstr == NULL ) exit(0);<br>strcpy( pstr, “Hello Wrold” );  </p>
<p>但如果是下面一种情况，最好进行内存初始化。（指针是一个危险的东西，一定要初始化）  </p>
<p>char <strong>pstr;<br>pstr = ( char</strong> ) malloc( 50 );<br>if ( pstr == NULL ) exit(0);  </p>
<p>memset( pstr, 0, 50<em>sizeof(char</em>) );  </p>
<p>而对于全局变量，和静态变量，一定要声明时就初始化。因为你不知道它第一次会在哪里被使</p>
<p>用。所以使用前初始这些变量是比较不现实的，一定要在声明时就初始化它们。如：  </p>
<p>Links *plnk = NULL;   </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python入门网络爬虫之精华版]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2015/12/16/Python%E5%85%A5%E9%97%A8%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B9%8B%E7%B2%BE%E5%8D%8E%E7%89%88.html</url>
      <content type="html"><![CDATA[<hr>
<p>Python学习网络爬虫主要分3个大的版块：<strong>抓取</strong>，<strong>分析</strong>，<strong>存储</strong>  </p>
<p>另外，比较常用的爬虫框架<a href="http://scrapy.org/" target="_blank" rel="external">Scrapy</a>，这里最后也详细介绍一下。    </p>
<p>首先列举一下本人总结的相关文章，这些覆盖了入门网络爬虫需要的基本概念和技巧：<a href="http://www.lining0806.com/category/spider/" target="_blank" rel="external">宁哥的小站-网络爬虫</a>  </p>
<hr>
<p>当我们在浏览器中输入一个url后回车，后台会发生什么？比如说你输入<a href="http://www.lining0806.com/" target="_blank" rel="external">http://www.lining0806.com/</a>，你就会看到宁哥的小站首页。</p>
<p>简单来说这段过程发生了以下四个步骤：<br><a id="more"></a></p>
<ul>
<li>查找域名对应的IP地址。</li>
<li>向IP对应的服务器发送请求。</li>
<li>服务器响应请求，发回网页内容。</li>
<li>浏览器解析网页内容。</li>
</ul>
<p>网络爬虫要做的，简单来说，就是实现浏览器的功能。通过指定url，直接返回给用户所需要的数据，而不需要一步步人工去操纵浏览器获取。</p>
<h2 id="抓取"><a href="#抓取" class="headerlink" title="抓取"></a>抓取</h2><p>这一步，你要明确要得到的内容是是什么？是HTML源码，还是Json格式的字符串等。  </p>
<h4 id="1-最基本的抓取"><a href="#1-最基本的抓取" class="headerlink" title="1. 最基本的抓取"></a>1. 最基本的抓取</h4><p>抓取大多数情况属于get请求，即直接从对方服务器上获取数据。  </p>
<p>首先，Python中自带urllib及urllib2这两个模块，基本上能满足一般的页面抓取。另外，<a href="https://github.com/kennethreitz/requests" target="_blank" rel="external">requests</a>也是非常有用的包，与此类似的，还有<a href="https://github.com/jcgregorio/httplib2" target="_blank" rel="external">httplib2</a>等等。    </p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Requests：</span><br><span class="line">	import requests</span><br><span class="line">	response = requests.<span class="built_in">get</span>(url)</span><br><span class="line">	<span class="built_in">content</span> = requests.<span class="built_in">get</span>(url).<span class="built_in">content</span></span><br><span class="line">	<span class="built_in">print</span> <span class="string">"response headers:"</span>, response.headers</span><br><span class="line">	<span class="built_in">print</span> <span class="string">"content:"</span>, <span class="built_in">content</span></span><br><span class="line">Urllib2：</span><br><span class="line">	import urllib2</span><br><span class="line">	response = urllib2.urlopen(url)</span><br><span class="line">	<span class="built_in">content</span> = urllib2.urlopen(url).<span class="built_in">read</span>()</span><br><span class="line">	<span class="built_in">print</span> <span class="string">"response headers:"</span>, response.headers</span><br><span class="line">	<span class="built_in">print</span> <span class="string">"content:"</span>, <span class="built_in">content</span></span><br><span class="line">Httplib2：</span><br><span class="line">	import httplib2</span><br><span class="line">	http = httplib2.Http()</span><br><span class="line">	response_headers, <span class="built_in">content</span> = http.request(url, 'GET')</span><br><span class="line">	<span class="built_in">print</span> <span class="string">"response headers:"</span>, response_headers</span><br><span class="line">	<span class="built_in">print</span> <span class="string">"content:"</span>, <span class="built_in">content</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">此外，对于带有查询字段的url，<span class="built_in">get</span>请求一般会将来请求的数据附在url之后，以?分割url和传输数据，多个参数用&amp;连接。</span><br></pre></td></tr></table></figure>
<p>data = {‘data1’:’XXXXX’, ‘data2’:’XXXXX’}<br>Requests：data为dict，json<br>    import requests<br>    response = requests.get(url=url, params=data)<br>Urllib2：data为string<br>    import urllib, urllib2<br>    data = urllib.urlencode(data)<br>    full_url = url+’?’+data<br>    response = urllib2.urlopen(full_url)<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">相关参考：[网易新闻排行榜抓取回顾](http:<span class="regexp">//www</span>.lining0806.com/%E7%BD%91%E6%98%93%E6%96%B0%E9%97%BB%E6%8E%92%E8%A1%8C%E6%A6%9C%E6%8A%93%E5%8F%96%E5%9B%9E%E9%A1%BE/)</span><br><span class="line"></span><br><span class="line">参考项目：[网络爬虫之最基本的爬虫：爬取网易新闻排行榜](https:<span class="regexp">//github</span>.com/lining0806/NewsSpider)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 2. 对于登陆情况的处理  </span></span><br><span class="line"></span><br><span class="line">**<span class="number">2.1</span> 使用表单登陆**  </span><br><span class="line"></span><br><span class="line">这种情况属于post请求，即先向服务器发送表单数据，服务器再将返回的cookie存入本地。</span><br></pre></td></tr></table></figure></p>
<p>data = {‘data1’:’XXXXX’, ‘data2’:’XXXXX’}<br>Requests：data为dict，json<br>    import requests<br>    response = requests.post(url=url, data=data)<br>Urllib2：data为string<br>    import urllib, urllib2<br>    data = urllib.urlencode(data)<br>    req = urllib2.Request(url=url, data=data)<br>    response = urllib2.urlopen(req)<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="strong">*2.2 使用cookie登陆*</span>*  </span><br><span class="line"></span><br><span class="line">使用cookie登陆，服务器会认为你是一个已登陆的用户，所以就会返回给你一个已登陆的内容。因此，需要验证码的情况可以使用带验证码登陆的cookie解决。</span><br></pre></td></tr></table></figure></p>
<p>import requests<br>requests_session = requests.session()<br>response = requests_session.post(url=url_login, data=data)<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">若存在验证码，此时采用response = requests_session.post(url=url_login, <span class="class"><span class="keyword">data</span>=<span class="keyword">data</span>)是不行的，做法应该如下：</span></span><br></pre></td></tr></table></figure></p>
<p>response_captcha = requests_session.get(url=url_login, cookies=cookies)<br>response1 = requests.get(url_login) # 未登陆<br>response2 = requests_session.get(url_login) # 已登陆，因为之前拿到了Response Cookie！<br>response3 = requests_session.get(url_results) # 已登陆，因为之前拿到了Response Cookie！<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">相关参考：[网络爬虫-验证码登陆](http:<span class="regexp">//www</span>.lining0806.com/<span class="number">6</span>-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E9%99%86/)  </span><br><span class="line"></span><br><span class="line">参考项目：[网络爬虫之用户名密码及验证码登陆：爬取知乎网站](https:<span class="regexp">//github</span>.com/lining0806/ZhihuSpider)  </span><br><span class="line"></span><br><span class="line"><span class="comment">### 3. 对于反爬虫机制的处理 </span></span><br><span class="line"></span><br><span class="line">**<span class="number">3.1</span> 使用代理** </span><br><span class="line"></span><br><span class="line">适用情况：限制IP地址情况，也可解决由于“频繁点击”而需要输入验证码登陆的情况。  </span><br><span class="line"></span><br><span class="line">这种情况最好的办法就是维护一个代理IP池，网上有很多免费的代理IP，良莠不齐，可以通过筛选找到能用的。对于“频繁点击”的情况，我们还可以通过限制爬虫访问网站的频率来避免被网站禁掉。</span><br></pre></td></tr></table></figure></p>
<p>proxies = {‘http’:’<a href="http://XX.XX.XX.XX:XXXX&#39;}" target="_blank" rel="external">http://XX.XX.XX.XX:XXXX&#39;}</a><br>Requests：<br>    import requests<br>    response = requests.get(url=url, proxies=proxies)<br>Urllib2：<br>    import urllib2<br>    proxy_support = urllib2.ProxyHandler(proxies)<br>    opener = urllib2.build_opener(proxy_support, urllib2.HTTPHandler)<br>    urllib2.install_opener(opener) # 安装opener，此后调用urlopen()时都会使用安装过的opener对象<br>    response = urllib2.urlopen(url)<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">**3.2 时间设置** </span></span><br><span class="line"></span><br><span class="line">适用情况：限制频率情况。 </span><br><span class="line"></span><br><span class="line">Requests，Urllib2都可以使用time库的<span class="built-in">sleep</span>()函数：</span><br></pre></td></tr></table></figure></p>
<p>import time<br>time.sleep(1)<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="number">3.3</span> 伪装成浏览器，或者反“反盗链”**  </span><br><span class="line"></span><br><span class="line">有些网站会检查你是不是真的浏览器访问，还是机器自动访问的。这种情况，加上User<span class="attr">-Agent</span>，表明你是浏览器访问即可。有时还会检查是否带<span class="keyword">Referer</span>信息还会检查你的<span class="keyword">Referer</span>是否合法，一般再加上<span class="keyword">Referer</span>。</span><br></pre></td></tr></table></figure></p>
<p>headers = {‘User-Agent’:’XXXXX’} # 伪装成浏览器访问，适用于拒绝爬虫的网站<br>headers = {‘Referer’:’XXXXX’}<br>headers = {‘User-Agent’:’XXXXX’, ‘Referer’:’XXXXX’}<br>Requests：<br>    response = requests.get(url=url, headers=headers)<br>Urllib2：<br>    import urllib, urllib2<br>    req = urllib2.Request(url=url, headers=headers)<br>    response = urllib2.urlopen(req)<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">### 4. 对于断线重连  </span></span><br><span class="line"></span><br><span class="line">不多说。</span><br></pre></td></tr></table></figure></p>
<p>def multi_session(session, <em>arg):<br>    while True:<br>        retryTimes = 20<br>    while retryTimes&gt;0:<br>        try:<br>            return session.post(</em>arg)<br>        except:<br>            print ‘.’,<br>            retryTimes -= 1<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">或者</span><br></pre></td></tr></table></figure></p>
<p>def multi_open(opener, <em>arg):<br>    while True:<br>        retryTimes = 20<br>    while retryTimes&gt;0:<br>        try:<br>            return opener.open(</em>arg)<br>        except:<br>            print ‘.’,<br>            retryTimes -= 1<br>```</p>
<p>这样我们就可以使用multi_session或multi_open对爬虫抓取的session或opener进行保持。    </p>
<h3 id="5-多进程抓取"><a href="#5-多进程抓取" class="headerlink" title="5. 多进程抓取"></a>5. 多进程抓取</h3><p>这里针对<a href="http://live.wallstreetcn.com/" target="_blank" rel="external">华尔街见闻</a>进行并行抓取的实验对比：<a href="https://github.com/lining0806/Spider_Python" target="_blank" rel="external">Python多进程抓取</a> 与 <a href="https://github.com/lining0806/Spider" target="_blank" rel="external">Java单线程和多线程抓取</a>  </p>
<p>相关参考：<a href="http://www.lining0806.com/%E5%85%B3%E4%BA%8Epython%E5%92%8Cjava%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94/" target="_blank" rel="external">关于Python和Java的多进程多线程计算方法对比</a>  </p>
<h3 id="6-对于Ajax请求的处理"><a href="#6-对于Ajax请求的处理" class="headerlink" title="6. 对于Ajax请求的处理"></a>6. 对于Ajax请求的处理</h3><p>对于“加载更多”情况，使用Ajax来传输很多数据。</p>
<p>它的工作原理是：从网页的url加载网页的源代码之后，会在浏览器里执行JavaScript程序。这些程序会加载更多的内容，“填充”到网页里。这就是为什么如果你直接去爬网页本身的url，你会找不到页面的实际内容。  </p>
<p>这里，若使用Google Chrome分析”请求“对应的链接(方法：右键→审查元素→Network→清空，点击”加载更多“，出现对应的GET链接寻找Type为text/html的，点击，查看get参数或者复制Request URL)，循环过程。  </p>
<ul>
<li>如果“请求”之前有页面，依据上一步的网址进行分析推导第1页。以此类推，抓取抓Ajax地址的数据。  </li>
<li>对返回的json格式数据(str)进行正则匹配。json格式数据中，需从’\uxxxx’形式的unicode_escape编码转换成u’\uxxxx’的unicode编码。  </li>
</ul>
<h3 id="7-自动化测试工具Selenium"><a href="#7-自动化测试工具Selenium" class="headerlink" title="7. 自动化测试工具Selenium"></a>7. 自动化测试工具Selenium</h3><p>Selenium是一款自动化测试工具。它能实现操纵浏览器，包括字符填充、鼠标点击、获取元素、页面切换等一系列操作。总之，凡是浏览器能做的事，Selenium都能够做到。</p>
<p>这里列出在给定城市列表后，使用selenium来动态抓取<a href="http://flight.qunar.com/" target="_blank" rel="external">去哪儿网</a>的票价信息的代码。</p>
<p>参考项目：<a href="https://github.com/lining0806/QunarSpider" target="_blank" rel="external">网络爬虫之Selenium使用代理登陆：爬取去哪儿网站</a> </p>
<h3 id="8-验证码识别"><a href="#8-验证码识别" class="headerlink" title="8. 验证码识别"></a>8. 验证码识别</h3><p>对于网站有验证码的情况，我们有三种办法：  </p>
<ul>
<li>使用代理，更新IP。</li>
<li>使用cookie登陆。</li>
<li>验证码识别。</li>
</ul>
<p>使用代理和使用cookie登陆之前已经讲过，下面讲一下验证码识别。  </p>
<p>可以利用开源的Tesseract-OCR系统进行验证码图片的下载及识别，将识别的字符传到爬虫系统进行模拟登陆。如果不成功，可以再次更新验证码识别，直到成功为止。  </p>
<p>参考项目：<a href="https://github.com/lining0806/Captcha1" target="_blank" rel="external">Captcha1</a></p>
<p><strong>爬取有两个需要注意的问题：</strong></p>
<ul>
<li>如何监控一系列网站的更新情况，也就是说，如何进行增量式爬取？</li>
<li>对于海量数据，如何实现分布式爬取？</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>抓取之后就是对抓取的内容进行分析，你需要什么内容，就从中提炼出相关的内容来。  </p>
<p>常见的分析工具有<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">正则表达式</a>，<a href="http://www.crummy.com/software/BeautifulSoup/" target="_blank" rel="external">BeautifulSoup</a>，<a href="http://lxml.de/" target="_blank" rel="external">lxml</a>等等。  </p>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>分析出我们需要的内容之后，接下来就是存储了。  </p>
<p>我们可以选择存入文本文件，也可以选择存入<a href="http://www.mysql.com/" target="_blank" rel="external">MySQL</a>或<a href="https://www.mongodb.org/" target="_blank" rel="external">MongoDB</a>数据库等。  </p>
<p><strong>存储有两个需要注意的问题：</strong></p>
<ul>
<li>如何进行网页去重？</li>
<li>内容以什么形式存储？</li>
</ul>
<h2 id="Scrapy"><a href="#Scrapy" class="headerlink" title="Scrapy"></a>Scrapy</h2><p>Scrapy是一个基于Twisted的开源的Python爬虫框架，在工业中应用非常广泛。  </p>
<p>相关内容可以参考<a href="http://www.lining0806.com/%E5%9F%BA%E4%BA%8Escrapy%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E7%9A%84%E6%90%AD%E5%BB%BA/" target="_blank" rel="external">基于Scrapy网络爬虫的搭建</a>，同时给出这篇文章介绍的<a href="http://weixin.sogou.com/weixin" target="_blank" rel="external">微信搜索</a>爬取的项目代码，给大家作为学习参考。</p>
<p>参考项目：<a href="https://github.com/lining0806/WechatSearchProjects" target="_blank" rel="external">使用Scrapy或Requests递归抓取微信搜索结果</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[理解矩阵]]></title>
      <url>http://i90s.vip/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/2015/12/15/%E7%90%86%E8%A7%A3%E7%9F%A9%E9%98%B5.html</url>
      <content type="html"><![CDATA[<p>前不久chensh出于不可告人的目的，要充当老师，教别人线性代数。于是我被揪住就线性代数中一些务虚性的问题与他讨论了几次。很明显，chensh觉得，要让自己在讲线性代数的时候不被那位强势的学生认为是神经病，还是比较难的事情。</p>
<p>可怜的chensh，谁让你趟这个地雷阵？！色令智昏啊！<br><a id="more"></a></p>
<p>线性代数课程，无论你从行列式入手还是直接从矩阵入手，从一开始就充斥着莫名其妙。比如说，在全国一般工科院系教学中应用最广泛的同济线性代数教材（现在到了第四版），一上来就介绍逆序数这个“前无古人，后无来者”的古怪概念，然后用逆序数给出行列式的一个极不直观的定义，接着是一些简直犯傻的行列式性质和习题——把这行乘一个系数加到另一行上，再把那一列减过来，折腾得那叫一个热闹，可就是压根看不出这个东西有嘛用。大多数像我一样资质平庸的学生到这里就有点犯晕：连这是个什么东西都模模糊糊的，就开始钻火圈表演了，这未免太“无厘头”了吧！于是开始有人逃课，更多的人开始抄作业。这下就中招了，因为其后的发展可以用一句峰回路转来形容，紧跟着这个无厘头的行列式的，是一个同样无厘头但是伟大的无以复加的家伙的出场——矩阵来了！多年之后，我才明白，当老师犯傻似地用中括号把一堆傻了吧叽的数括起来，并且不紧不慢地说：“这个东西叫做矩阵”的时候，我的数学生涯掀开了何等悲壮辛酸、惨绝人寰的一幕！自那以后，在几乎所有跟“学问”二字稍微沾点边的东西里，矩阵这个家伙从不缺席。对于我这个没能一次搞定线性代数的笨蛋来说，矩阵老大的不请自来每每搞得我灰头土脸，头破血流。长期以来，我在阅读中一见矩阵，就如同阿Q见到了假洋鬼子，揉揉额角就绕道走。</p>
<p>事实上，我并不是特例。一般工科学生初学线性代数，通常都会感到困难。这种情形在国内外皆然。瑞典数学家Lars Garding在其名著Encounter with Mathematics中说：“如果不熟悉线性代数的概念，要去学习自然科学，现在看来就和文盲差不多。”，然而“按照现行的国际标准，线性代数是通过公理化来表述的，它是第二代数学模型，…，这就带来了教学上的困难。”事实上，当我们开始学习线性代数的时候，不知不觉就进入了“第二代数学模型”的范畴当中，这意味着数学的表述方式和抽象性有了一次全面的进化，对于从小一直在“第一代数学模型”，即以实用为导向的、具体的数学模型中学习的我们来说，在没有并明确告知的情况下进行如此剧烈的paradigm shift，不感到困难才是奇怪的。</p>
<p>大部分工科学生，往往是在学习了一些后继课程，如数值分析、数学规划、矩阵论之后，才逐渐能够理解和熟练运用线性代数。即便如此，不少人即使能够很熟练地以线性代数为工具进行科研和应用工作，但对于很多这门课程的初学者提出的、看上去是很基础的问题却并不清楚。比如说：</p>
<ul>
<li><p>矩阵究竟是什么东西？向量可以被认为是具有n个相互独立的性质（维度）的对象的表示，矩阵又是什么呢？我们如果认为矩阵是一组列（行）向量组成的新的复合向量的展开式，那么为什么这种展开式具有如此广泛的应用？特别是，为什么偏偏二维的展开式如此有用？如果矩阵中每一个元素又是一个向量，那么我们再展开一次，变成三维的立方阵，是不是更有用？</p>
</li>
<li><p>矩阵的乘法规则究竟为什么这样规定？为什么这样一种怪异的乘法规则却能够在实践中发挥如此巨大的功效？很多看上去似乎是完全不相关的问题，最后竟然都归结到矩阵的乘法，这难道不是很奇妙的事情？难道在矩阵乘法那看上去莫名其妙的规则下面，包含着世界的某些本质规律？如果是的话，这些本质规律是什么？</p>
</li>
<li><p>行列式究竟是一个什么东西？为什么会有如此怪异的计算规则？行列式与其对应方阵本质上是什么关系？为什么只有方阵才有对应的行列式，而一般矩阵就没有（不要觉得这个问题很蠢，如果必要，针对m x n矩阵定义行列式不是做不到的，之所以不做，是因为没有这个必要，但是为什么没有这个必要）？而且，行列式的计算规则，看上去跟矩阵的任何计算规则都没有直观的联系，为什么又在很多方面决定了矩阵的性质？难道这一切仅是巧合？</p>
</li>
<li><p>矩阵为什么可以分块计算？分块计算这件事情看上去是那么随意，为什么竟是可行的？</p>
</li>
<li><p>对于矩阵转置运算AT，有(AB)T = BTAT，对于矩阵求逆运算A-1，有(AB)-1 = B-1A-1。两个看上去完全没有什么关系的运算，为什么有着类似的性质？这仅仅是巧合吗？</p>
</li>
<li><p>为什么说P-1AP得到的矩阵与A矩阵“相似”？这里的“相似”是什么意思？</p>
</li>
<li><p>特征值和特征向量的本质是什么？它们定义就让人很惊讶，因为Ax =λx，一个诺大的矩阵的效应，竟然不过相当于一个小小的数λ，确实有点奇妙。但何至于用“特征”甚至“本征”来界定？它们刻划的究竟是什么？</p>
</li>
</ul>
<p>这样的一类问题，经常让使用线性代数已经很多年的人都感到为难。就好像大人面对小孩子的刨根问底，最后总会迫不得已地说“就这样吧，到此为止”一样，面对这样的问题，很多老手们最后也只能用：“就是这么规定的，你接受并且记住就好”来搪塞。然而，这样的问题如果不能获得回答，线性代数对于我们来说就是一个粗暴的、不讲道理的、莫名其妙的规则集合，我们会感到，自己并不是在学习一门学问，而是被不由分说地“抛到”一个强制的世界中，只是在考试的皮鞭挥舞之下被迫赶路，全然无法领略其中的美妙、和谐与统一。直到多年以后，我们已经发觉这门学问如此的有用，却仍然会非常迷惑：怎么这么凑巧？</p>
<p>我认为，这是我们的线性代数教学中直觉性丧失的后果。上述这些涉及到“如何能”、“怎么会”的问题，仅仅通过纯粹的数学证明来回答，是不能令提问者满意的。比如，如果你通过一般的证明方法论证了矩阵分块运算确实可行，那么这并不能够让提问者的疑惑得到解决。他们真正的困惑是：矩阵分块运算为什么竟然是可行的？究竟只是凑巧，还是说这是由矩阵这种对象的某种本质所必然决定的？如果是后者，那么矩阵的这些本质是什么？只要对上述那些问题稍加考虑，我们就会发现，所有这些问题都不是单纯依靠数学证明所能够解决的。像我们的教科书那样，凡事用数学证明，最后培养出来的学生，只能熟练地使用工具，却欠缺真正意义上的理解。</p>
<p>自从1930年代法国布尔巴基学派兴起以来，数学的公理化、系统性描述已经获得巨大的成功，这使得我们接受的数学教育在严谨性上大大提高。然而数学公理化的一个备受争议的副作用，就是一般数学教育中直觉性的丧失。数学家们似乎认为直觉性与抽象性是矛盾的，因此毫不犹豫地牺牲掉前者。然而包括我本人在内的很多人都对此表示怀疑，我们不认为直觉性与抽象性一定相互矛盾，特别是在数学教育中和数学教材中，帮助学生建立直觉，有助于它们理解那些抽象的概念，进而理解数学的本质。反之，如果一味注重形式上的严格性，学生就好像被迫进行钻火圈表演的小白鼠一样，变成枯燥的规则的奴隶。</p>
<p>对于线性代数的类似上述所提到的一些直觉性的问题，两年多来我断断续续地反复思考了四、五次，为此阅读了好几本国内外线性代数、数值分析、代数和数学通论性书籍，其中像前苏联的名著《数学：它的内容、方法和意义》、龚升教授的《线性代数五讲》、前面提到的Encounter with Mathematics（《数学概观》）以及Thomas A. Garrity的《数学拾遗》都给我很大的启发。不过即使如此，我对这个主题的认识也经历了好几次自我否定。比如以前思考的一些结论曾经写在自己的blog里，但是现在看来，这些结论基本上都是错误的。因此打算把自己现在的有关理解比较完整地记录下来，一方面是因为我觉得现在的理解比较成熟了，可以拿出来与别人探讨，向别人请教。另一方面，如果以后再有进一步的认识，把现在的理解给推翻了，那现在写的这个snapshot也是很有意义的。</p>
<p>因为打算写得比较多，所以会分几次慢慢写。也不知道是不是有时间慢慢写完整，会不会中断，写着看吧。</p>
<hr>
<p>今天先谈谈对线形空间和矩阵的几个核心概念的理解。这些东西大部分是凭着自己的理解写出来的，基本上不抄书，可能有错误的地方，希望能够被指出。但我希望做到直觉，也就是说能把数学背后说的实质问题说出来。</p>
<p>首先说说空间(space)，这个概念是现代数学的命根子之一，从拓扑空间开始，一步步往上加定义，可以形成很多空间。线形空间其实还是比较初级的，如果在里面定义了范数，就成了赋范线性空间。赋范线性空间满足完备性，就成了巴那赫空间；赋范线性空间中定义角度，就有了内积空间，内积空间再满足完备性，就得到希尔伯特空间。</p>
<p>总之，空间有很多种。你要是去看某种空间的数学定义，大致都是“存在一个集合，在这个集合上定义某某概念，然后满足某些性质”，就可以被称为空间。这未免有点奇怪，为什么要用“空间”来称呼一些这样的集合呢？大家将会看到，其实这是很有道理的。</p>
<p>我们一般人最熟悉的空间，毫无疑问就是我们生活在其中的（按照牛顿的绝对时空观）的三维空间，从数学上说，这是一个三维的欧几里德空间，我们先不管那么多，先看看我们熟悉的这样一个空间有些什么最基本的特点。仔细想想我们就会知道，这个三维的空间：1. 由很多（实际上是无穷多个）位置点组成；2. 这些点之间存在相对的关系；3. 可以在空间中定义长度、角度；4. 这个空间可以容纳运动，这里我们所说的运动是从一个点到另一个点的移动（变换），而不是微积分意义上的“连续”性的运动，</p>
<p>上面的这些性质中，最最关键的是第4条。第1、2条只能说是空间的基础，不算是空间特有的性质，凡是讨论数学问题，都得有一个集合，大多数还得在这个集合上定义一些结构（关系），并不是说有了这些就算是空间。而第3条太特殊，其他的空间不需要具备，更不是关键的性质。只有第4条是空间的本质，也就是说，容纳运动是空间的本质特征。</p>
<p>认识到了这些，我们就可以把我们关于三维空间的认识扩展到其他的空间。事实上，不管是什么空间，都必须容纳和支持在其中发生的符合规则的运动（变换）。你会发现，在某种空间中往往会存在一种相对应的变换，比如拓扑空间中有拓扑变换，线性空间中有线性变换，仿射空间中有仿射变换，其实这些变换都只不过是对应空间中允许的运动形式而已。</p>
<p>因此只要知道，“空间”是容纳运动的一个对象集合，而变换则规定了对应空间的运动。</p>
<p>下面我们来看看线性空间。线性空间的定义任何一本书上都有，但是既然我们承认线性空间是个空间，那么有两个最基本的问题必须首先得到解决，那就是：</p>
<ol>
<li><p>空间是一个对象集合，线性空间也是空间，所以也是一个对象集合。那么线性空间是什么样的对象的集合？或者说，线性空间中的对象有什么共同点吗？</p>
</li>
<li><p>线性空间中的运动如何表述的？也就是，线性变换是如何表示的？</p>
</li>
</ol>
<p>我们先来回答第一个问题，回答这个问题的时候其实是不用拐弯抹角的，可以直截了当的给出答案。线性空间中的任何一个对象，通过选取基和坐标的办法，都可以表达为向量的形式。通常的向量空间我就不说了，举两个不那么平凡的例子：</p>
<p>L1. 最高次项不大于n次的多项式的全体构成一个线性空间，也就是说，这个线性空间中的每一个对象是一个多项式。如果我们以x0, x1, …, xn为基，那么任何一个这样的多项式都可以表达为一组n+1维向量，其中的每一个分量ai其实就是多项式中x(i-1)项的系数。值得说明的是，基的选取有多种办法，只要所选取的那一组基线性无关就可以。这要用到后面提到的概念了，所以这里先不说，提一下而已。</p>
<p>L2. 闭区间[a, b]上的n阶连续可微函数的全体，构成一个线性空间。也就是说，这个线性空间的每一个对象是一个连续函数。对于其中任何一个连续函数，根据魏尔斯特拉斯定理，一定可以找到最高次项不大于n的多项式函数，使之与该连续函数的差为0，也就是说，完全相等。这样就把问题归结为L1了。后面就不用再重复了。</p>
<p>所以说，向量是很厉害的，只要你找到合适的基，用向量可以表示线性空间里任何一个对象。这里头大有文章，因为向量表面上只是一列数，但是其实由于它的有序性，所以除了这些数本身携带的信息之外，还可以在每个数的对应位置上携带信息。为什么在程序设计中数组最简单，却又威力无穷呢？根本原因就在于此。这是另一个问题了，这里就不说了。</p>
<p>下面来回答第二个问题，这个问题的回答会涉及到线性代数的一个最根本的问题。</p>
<p>线性空间中的运动，被称为线性变换。也就是说，你从线性空间中的一个点运动到任意的另外一个点，都可以通过一个线性变化来完成。那么，线性变换如何表示呢？很有意思，在线性空间中，当你选定一组基之后，不仅可以用一个向量来描述空间中的任何一个对象，而且可以用矩阵来描述该空间中的任何一个运动（变换）。而使某个对象发生对应运动的方法，就是用代表那个运动的矩阵，乘以代表那个对象的向量。</p>
<p>简而言之，在线性空间中选定基之后，向量刻画对象，矩阵刻画对象的运动，用矩阵与向量的乘法施加运动。</p>
<p>是的，矩阵的本质是运动的描述。如果以后有人问你矩阵是什么，那么你就可以响亮地告诉他，矩阵的本质是运动的描述。（chensh，说你呢！）</p>
<p>可是多么有意思啊，向量本身不是也可以看成是n x 1矩阵吗？这实在是很奇妙，一个空间中的对象和运动竟然可以用相类同的方式表示。能说这是巧合吗？如果是巧合的话，那可真是幸运的巧合！可以说，线性代数中大多数奇妙的性质，均与这个巧合有直接的关系</p>
<p>上一篇里说“矩阵是运动的描述”，到现在为止，好像大家都还没什么意见。但是我相信早晚会有数学系出身的网友来拍板转。因为运动这个概念，在数学和物理里是跟微积分联系在一起的。我们学习微积分的时候，总会有人照本宣科地告诉你，初等数学是研究常量的数学，是研究静态的数学，高等数学是变量的数学，是研究运动的数学。大家口口相传，差不多人人都知道这句话。但是真知道这句话说的是什么意思的人，好像也不多。简而言之，在我们人类的经验里，运动是一个连续过程，从A点到B点，就算走得最快的光，也是需要一个时间来逐点地经过AB之间的路径，这就带来了连续性的概念。而连续这个事情，如果不定义极限的概念，根本就解释不了。古希腊人的数学非常强，但就是缺乏极限观念，所以解释不了运动，被芝诺的那些著名悖论（飞箭不动、飞毛腿阿喀琉斯跑不过乌龟等四个悖论）搞得死去活来。因为这篇文章不是讲微积分的，所以我就不多说了。有兴趣的读者可以去看看齐民友教授写的《重温微积分》。我就是读了这本书开头的部分，才明白“高等数学是研究运动的数学”这句话的道理。</p>
<p>不过在我这个《理解矩阵》的文章里，“运动”的概念不是微积分中的连续性的运动，而是瞬间发生的变化。比如这个时刻在A点，经过一个“运动”，一下子就“跃迁”到了B点，其中不需要经过A点与B点之间的任何一个点。这样的“运动”，或者说“跃迁”，是违反我们日常的经验的。不过了解一点量子物理常识的人，就会立刻指出，量子（例如电子）在不同的能量级轨道上跳跃，就是瞬间发生的，具有这样一种跃迁行为。所以说，自然界中并不是没有这种运动现象，只不过宏观上我们观察不到。但是不管怎么说，“运动”这个词用在这里，还是容易产生歧义的，说得更确切些，应该是“跃迁”。因此这句话可以改成：</p>
<p>“矩阵是线性空间里跃迁的描述”。</p>
<p>可是这样说又太物理，也就是说太具体，而不够数学，也就是说不够抽象。因此我们最后换用一个正牌的数学术语——变换，来描述这个事情。这样一说，大家就应该明白了，所谓变换，其实就是空间里从一个点（元素/对象）到另一个点（元素/对象）的跃迁。比如说，拓扑变换，就是在拓扑空间里从一个点到另一个点的跃迁。再比如说，仿射变换，就是在仿射空间里从一个点到另一个点的跃迁。附带说一下，这个仿射空间跟向量空间是亲兄弟。做计算机图形学的朋友都知道，尽管描述一个三维对象只需要三维向量，但所有的计算机图形学变换矩阵都是4 x 4的。说其原因，很多书上都写着“为了使用中方便”，这在我看来简直就是企图蒙混过关。真正的原因，是因为在计算机图形学里应用的图形变换，实际上是在仿射空间而不是向量空间中进行的。想想看，在向量空间里相一个向量平行移动以后仍是相同的那个向量，而现实世界等长的两个平行线段当然不能被认为同一个东西，所以计算机图形学的生存空间实际上是仿射空间。而仿射变换的矩阵表示根本就是4 x 4的。又扯远了，有兴趣的读者可以去看《计算机图形学——几何工具算法详解》。</p>
<p>一旦我们理解了“变换”这个概念，矩阵的定义就变成：</p>
<p>“矩阵是线性空间里的变换的描述。”</p>
<p>到这里为止，我们终于得到了一个看上去比较数学的定义。不过还要多说几句。教材上一般是这么说的，在一个线性空间V里的一个线性变换T，当选定一组基之后，就可以表示为矩阵。因此我们还要说清楚到底什么是线性变换，什么是基，什么叫选定一组基。线性变换的定义是很简单的，设有一种变换T，使得对于线性空间V中间任何两个不相同的对象x和y，以及任意实数a和b，有：<br>T(ax + by) = aT(x) + bT(y)，<br>那么就称T为线性变换。</p>
<p>定义都是这么写的，但是光看定义还得不到直觉的理解。线性变换究竟是一种什么样的变换？我们刚才说了，变换是从空间的一个点跃迁到另一个点，而线性变换，就是从一个线性空间V的某一个点跃迁到另一个线性空间W的另一个点的运动。这句话里蕴含着一层意思，就是说一个点不仅可以变换到同一个线性空间中的另一个点，而且可以变换到另一个线性空间中的另一个点去。不管你怎么变，只要变换前后都是线性空间中的对象，这个变换就一定是线性变换，也就一定可以用一个非奇异矩阵来描述。而你用一个非奇异矩阵去描述的一个变换，一定是一个线性变换。有的人可能要问，这里为什么要强调非奇异矩阵？所谓非奇异，只对方阵有意义，那么非方阵的情况怎么样？这个说起来就会比较冗长了，最后要把线性变换作为一种映射，并且讨论其映射性质，以及线性变换的核与像等概念才能彻底讲清楚。我觉得这个不算是重点，如果确实有时间的话，以后写一点。以下我们只探讨最常用、最有用的一种变换，就是在同一个线性空间之内的线性变换。也就是说，下面所说的矩阵，不作说明的话，就是方阵，而且是非奇异方阵。学习一门学问，最重要的是把握主干内容，迅速建立对于这门学问的整体概念，不必一开始就考虑所有的细枝末节和特殊情况，自乱阵脚。</p>
<p>接着往下说，什么是基呢？这个问题在后面还要大讲一番，这里只要把基看成是线性空间里的坐标系就可以了。注意是坐标系，不是坐标值，这两者可是一个“对立矛盾统一体”。这样一来，“选定一组基”就是说在线性空间里选定一个坐标系。就这意思。</p>
<p>好，最后我们把矩阵的定义完善如下：</p>
<p>“矩阵是线性空间中的线性变换的一个描述。在一个线性空间中，只要我们选定一组基，那么对于任何一个线性变换，都能够用一个确定的矩阵来加以描述。”</p>
<p>理解这句话的关键，在于把“线性变换”与“线性变换的一个描述”区别开。一个是那个对象，一个是对那个对象的表述。就好像我们熟悉的面向对象编程中，一个对象可以有多个引用，每个引用可以叫不同的名字，但都是指的同一个对象。如果还不形象，那就干脆来个很俗的类比。</p>
<p>比如有一头猪，你打算给它拍照片，只要你给照相机选定了一个镜头位置，那么就可以给这头猪拍一张照片。这个照片可以看成是这头猪的一个描述，但只是一个片面的的描述，因为换一个镜头位置给这头猪拍照，能得到一张不同的照片，也是这头猪的另一个片面的描述。所有这样照出来的照片都是这同一头猪的描述，但是又都不是这头猪本身。</p>
<p>同样的，对于一个线性变换，只要你选定一组基，那么就可以找到一个矩阵来描述这个线性变换。换一组基，就得到一个不同的矩阵。所有这些矩阵都是这同一个线性变换的描述，但又都不是线性变换本身。</p>
<p>但是这样的话，问题就来了如果你给我两张猪的照片，我怎么知道这两张照片上的是同一头猪呢？同样的，你给我两个矩阵，我怎么知道这两个矩阵是描述的同一个线性变换呢？如果是同一个线性变换的不同的矩阵描述，那就是本家兄弟了，见面不认识，岂不成了笑话。</p>
<p>好在，我们可以找到同一个线性变换的矩阵兄弟们的一个性质，那就是：</p>
<p>若矩阵A与B是同一个线性变换的两个不同的描述（之所以会不同，是因为选定了不同的基，也就是选定了不同的坐标系），则一定能找到一个非奇异矩阵P，使得A、B之间满足这样的关系：</p>
<p>A = P-1BP</p>
<p>线性代数稍微熟一点的读者一下就看出来，这就是相似矩阵的定义。没错，所谓相似矩阵，就是同一个线性变换的不同的描述矩阵。按照这个定义，同一头猪的不同角度的照片也可以成为相似照片。俗了一点，不过能让人明白。</p>
<p>而在上面式子里那个矩阵P，其实就是A矩阵所基于的基与B矩阵所基于的基这两组基之间的一个变换关系。关于这个结论，可以用一种非常直觉的方法来证明（而不是一般教科书上那种形式上的证明），如果有时间的话，我以后在blog里补充这个证明。</p>
<p>这个发现太重要了。原来一族相似矩阵都是同一个线性变换的描述啊！难怪这么重要！工科研究生课程中有矩阵论、矩阵分析等课程，其中讲了各种各样的相似变换，比如什么相似标准型，对角化之类的内容，都要求变换以后得到的那个矩阵与先前的那个矩阵式相似的，为什么这么要求？因为只有这样要求，才能保证变换前后的两个矩阵是描述同一个线性变换的。当然，同一个线性变换的不同矩阵描述，从实际运算性质来看并不是不分好环的。有些描述矩阵就比其他的矩阵性质好得多。这很容易理解，同一头猪的照片也有美丑之分嘛。所以矩阵的相似变换可以把一个比较丑的矩阵变成一个比较美的矩阵，而保证这两个矩阵都是描述了同一个线性变换。</p>
<p>这样一来，矩阵作为线性变换描述的一面，基本上说清楚了。但是，事情没有那么简单，或者说，线性代数还有比这更奇妙的性质，那就是，矩阵不仅可以作为线性变换的描述，而且可以作为一组基的描述。而作为变换的矩阵，不但可以把线性空间中的一个点给变换到另一个点去，而且也能够把线性空间中的一个坐标系（基）表换到另一个坐标系（基）去。而且，变换点与变换坐标系，具有异曲同工的效果。线性代数里最有趣的奥妙，就蕴含在其中。理解了这些内容，线性代数里很多定理和规则会变得更加清晰、直觉.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如果让我重读一次研究生————王泛森院士]]></title>
      <url>http://i90s.vip/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/2015/12/14/%E5%A6%82%E6%9E%9C%E8%AE%A9%E6%88%91%E9%87%8D%E8%AF%BB%E4%B8%80%E6%AC%A1%E7%A0%94%E7%A9%B6%E7%94%9F.html</url>
      <content type="html"><![CDATA[<h2 id="研究生与大学生的区别"><a href="#研究生与大学生的区别" class="headerlink" title="研究生与大学生的区别"></a>研究生与大学生的区别</h2><p>首先跟大家说明一下研究生和大学生的区别。大学生基本上是来接受学问、接受知识的，然而不管是对于硕士时期或是博士时期的研究而言，都应该准备要开始制造新的知识，我们在美国得到博士学位时都会领到看不懂的毕业证书，在一个偶然的机会下，我问了一位懂拉丁文的人，上面的内容为何？他告诉我：「里头写的是恭喜你对人类的知识有所创新，因此授予你这个学位。」在中国原本并没有博硕士的学历，但是在西方他们原来的用意是，恭贺你已经对人类普遍的知识有所创新，这个创新或大或小，都是对于普遍的知识有所贡献。这个创新不会因为你做本土与否而有所不同，所以第一个我们必须要很用心、很深刻的思考，大学生和研究生是不同的。<br><a id="more"></a></p>
<h3 id="选择自己的问题取向，学会创新"><a href="#选择自己的问题取向，学会创新" class="headerlink" title="选择自己的问题取向，学会创新"></a>选择自己的问题取向，学会创新</h3><p>你一旦是研究生，你就已经进入另一个阶段，不只是要完全乐在其中，更要从而接受各种有趣的知识，进入制造知识的阶段，也就是说你的论文应该有所创新。由接受知识到创造知识，是身为一个研究生最大的特色，不仅如此，还要体认自己不再是个容器，等着老师把某些东西倒在茶杯里，而是要开始逐步发展和开发自己。做为研究生不再是对于各种新奇的课照单全收，而是要重视问题取向的安排，就是在硕士或博士的阶段里面，所有的精力、所有修课以及读的书里面都应该要有一个关注的焦点，而不能像大学那般漫无目标。大学生时代是因为你要尽量开创自己接受任何东西，但是到了硕士生和博士生，有一个最终的目的，就是要完成论文，那篇论文是你个人所有武功的总集合，所以这时候必须要有个问题取向的学习。 </p>
<h3 id="尝试跨领域研究，主动学习"><a href="#尝试跨领域研究，主动学习" class="headerlink" title="尝试跨领域研究，主动学习"></a>尝试跨领域研究，主动学习</h3><p>提出一个重要的问题，跨越一个重要的领域，将决定你未来的成败。我也在台大和清华教了十几年的课，我常常跟学生讲，选对一个领域和选对一个问题是成败的关键，而你自己本身必须是带着问题来探究无限的学问世界，因为你不再像大学时代一样泛滥无所归。所以这段时间内，必须选定一个自己有兴趣及关注的主题为出发点，来探究这些知识，产生有机的循环。由于你是自发性的对这个问题产生好奇和兴趣，所以你的态度和大学部的学生是截然不同的，你慢慢从被动的接受者变成是一个主动的探索者，并学会悠游在这学术的领域。<br>我举一个例子，我们的中央研究院院长李远哲先生，得了诺贝尔奖。他曾经在中研院的周报写过几篇文章，在他的言论集里面，或许各位也可以看到，他反复提到他的故事。他是因为读了一个叫做马亨教授的教科书而去美国柏克莱大学念书，去了以后才发现，这个老师只给他一张支票，跟他说你要花钱你尽量用，但是从来不教他任何东西。可是隔壁那个教授，老师教很多，而且每天学生都是跟着老师学习。他有一次就跟那个老师抱怨：「那你为什么不教我点东西呢？」那个老师就说：「如果我知道结果，那我要你来这边念书做什么？我就是因为不知道，所以要我们共同探索一个问题、一个未知的领域。」他说其实这两种教法都有用处，但是他自己从这个什么都不教他，永远碰到他只问他「有没有什么新发现」的老师身上，得到很大的成长。所以这两方面都各自蕴含深层的道理，没有所谓的好坏，但是最好的方式就是将这两个方式结合起来。我为什么讲这个故事呢？就是强调在这个阶段，学习是一种「 self-help 」，并且是在老师的引导下学习「 self-help 」，而不能再像大学时代般，都是纯粹用听的，这个阶段的学习要基于对研究问题的好奇和兴趣，要怀着一颗热忱的心来探索这个领域。<br>然而研究生另外一个重要的阶段就是 Learn how to learn ，不只是学习而已，而是学习如何学习，不再是要去买一件很漂亮的衣服，而是要学习拿起那一根针，学会绣出一件漂亮的衣服，慢慢学习把目标放在一个标准上，而这一个标准就是你将来要完成硕士或博士论文。如果你到西方一流的大学去读书，你会觉得我这一篇论文可能要和全世界做同一件问题的人相比较。我想即使在台湾也应该要有这样的心情，你的标准不能单单只是放在旁边几个人而已，而应该是要放在领域的普遍人里面。你这篇文章要有新的东西，才算达到的标准，也才符合到我们刚刚讲到那张拉丁文的博士证书上面所讲的，有所贡献与创新。 </p>
<h2 id="一个老师怎么训练研究生"><a href="#一个老师怎么训练研究生" class="headerlink" title="一个老师怎么训练研究生"></a>一个老师怎么训练研究生</h2><p>第二个，身为老师你要怎么训练研究生。我认为人文科学和社会科学的训练，哪怕是自然科学的训练，到研究生阶段应该更像师徒制，所以来自个人和老师、个人和同侪间密切的互动和学习是非常重要的，跟大学部坐在那边单纯听课，听完就走人是不一样的，相较之下你的生活应该要和你所追求的知识与解答相结合，并且你往后的生活应该或多或少都和这个探索有相关。 </p>
<h3 id="善用与老师的伙伴关系，不断-Research"><a href="#善用与老师的伙伴关系，不断-Research" class="headerlink" title="善用与老师的伙伴关系，不断 Research"></a>善用与老师的伙伴关系，不断 Research</h3><p>我常说英文 research 这个字非常有意义， search 是寻找，而 research 是再寻找，所以每个人都要 research ，不断的一遍一遍再寻找，并进而使你的生活和学习成为一体。中国近代兵学大师蒋百里在他的兵学书中曾说：「生活条件要跟战斗条件一致，近代欧洲凡生活与战斗条件一致者强，凡生活与战斗条件不一致者弱。」我就是藉由这个来说明研究生的生活，你的生活条件与你的战斗条件要一致，你的生活是跟着老师与同学共同成长的，当中你所听到的每一句话，都可能带给你无限的启发。<br>回想当时我在美国念书的研究生生活，只要随便在楼梯口碰到任何一个人，他都有办法帮忙解答你语言上的困难，不管是英文、拉丁文、德文、希腊文 …… 等。所以能帮助解决问题的不单只是你的老师，还包括所有同学以及学习团体。你的学习是跟生活合在一起、成为一体的。当我看到有学生呈现被动或是懈怠的时候，我就会用毛泽东的「革命不是请客吃饭！」来跟他讲：「作研究生不是请客吃饭。」 </p>
<h3 id="藉由大量阅读和老师提点，进入研究领域"><a href="#藉由大量阅读和老师提点，进入研究领域" class="headerlink" title="藉由大量阅读和老师提点，进入研究领域"></a>藉由大量阅读和老师提点，进入研究领域</h3><p>怎样进入一个领域最好，我个人觉得只有两条路，其中一条就是让他不停的念书、不停的报告，这是进入一个陌生的领域最快，又最方便的方法，到最后不知不觉学生就会知道这个领域有些什么，我们在不停念书的时候常常可能会沉溺在细节里不能自拔，进而失去全景，导致见树不见林，或是被那几句英文困住，而忘记全局在讲什么。藉由学生的报告，老师可以讲述或是厘清其中的精华内容，经由老师几句提点，就会慢慢打通任督二脉，逐渐发展一种自发学习的能力，同时也知道碰到问题可以看哪些东西。就像是我在美国念书的时候，我修过一些我完全没有背景知识的国家的历史，所以我就不停的念书、不停逼着自己吸收，而老师也只是不停的开书目，运用这样的方式慢慢训练，有一天我不再研究它时，我发现自己仍然有自我生产及蓄发的能力，因为我知道这个学问大概是什么样的轮廓，碰到问题也有能力可以去查询相关的资料。所以努力让自己的学习产生自发的延展性是很重要的。 </p>
<h3 id="循序渐进地练习论文写作"><a href="#循序渐进地练习论文写作" class="headerlink" title="循序渐进地练习论文写作"></a>循序渐进地练习论文写作</h3><p>到了硕士或博士最重要的一件事，是完成一篇学位论文，而不管是硕士或博士论文，其规模都远比你从小学以来所受的教育、所要写的东西都还要长得多，虽然我不知道教育方面的论文情况是如何，但是史学的论文都要写二、三十万字，不然就是十几二十万字。写这么大的一个篇幅，如何才能有条不紊、条理清楚，并把整体架构组织得通畅可读？首先，必须要从一千字、五千字、一万字循序渐进的训练，先从少的慢慢写成多的，而且要在很短的时间内训练到可以从一万字写到十万字。这么大规模的论文谁都写得出来，问题是写得好不好，因为这么大规模的写作，有这么许多的脚注，还要注意首尾相映，使论述一体成型，而不是散落一地的铜钱；是一间大礼堂，而不是一间小小分割的阁楼。为了完成一个大的、完整的、有机的架构模型（学位论文），必须要从小规模的篇幅慢慢练习，这是一个最有效的办法。<br>因为受计算机的影响，我发现很多学生写文章能力都大幅下降。写论文时很重要的一点是，文笔一定要清楚，不要花俏、不必漂亮，「清楚」是最高指导原则，经过慢慢练习会使你的文笔跟思考产生一致的连贯性。我常跟学生讲不必写的花俏，不必展现你散文的才能，因为这是学术论文，所以关键在于要写得非常清楚，如果有好的文笔当然更棒，但那是可遇不可求的，文彩像个人的生命一样，英文叫 style ， style 本身就像个人一样带有一点点天生。因此最重要的还是把内容陈述清楚，从一万字到最后十万字的东西，都要结构严谨、论述清楚、文笔清晰。<br>我在念书的时候，有一位欧洲史、英国史的大师 Lawrence Stone ，他目前已经过世了，曾经有一本书访问十位最了不起的史学家，我记得他在访问中说了一句非常吸引人注意的话，他说他英文文笔相当好，所以他一辈子没有被退过稿。因此文笔清楚或是文笔好，对于将来文章可被接受的程度有举足轻重的地位。内容非常重要，有好的表达工具更是具有加分的作用，但是这里不是讲究漂亮的 style ，而是论述清楚。 </p>
<h2 id="研究生如何训练自己"><a href="#研究生如何训练自己" class="headerlink" title="研究生如何训练自己"></a>研究生如何训练自己</h2><h3 id="尝试接受挑战，勇于克服"><a href="#尝试接受挑战，勇于克服" class="headerlink" title="尝试接受挑战，勇于克服"></a>尝试接受挑战，勇于克服</h3><p>研究生如何训练自己？就是每天、每周或每个月给自己一个挑战，要每隔一段时间就给自己一个挑战，挑战一个你不一定能做到的事情。你不一定要求自己每次都能顺利克服那个挑战，但是要全力以赴去尝试。我在我求学的生涯中，碰到太多聪明但却一无所成的人，因为他们很容易困在自己的障碍里面，举例来说，我在普林斯顿大学碰到一个很聪明的人，他就是没办法克服他给自己的挑战，他就总是东看西看，虽然我也有这个毛病，可是我会定期给我自己一个挑战，例如：我会告诉自己，在某一个期限内，无论如何一定要把这三行字改掉，或是这个礼拜一定要把这篇草稿写完，虽然我仍然常常写不完，但是有这个挑战跟没这个挑战是不一样的，因为我挑战三次总会完成一次，完成一次就够了，就足以表示克服了自己，如果觉得每一个礼拜的挑战，可行性太低，可以把时间延长为一个月的挑战，去挑战原来的你，不一定能做到的事情。不过也要切记，硕士生是刚开始进入这一个领域的新手，如果一开始问题太小，或是问题大到不能控制，都会造成以后研究的困难。 </p>
<h3 id="论文的写作是个训练过程，不能苛求完成精典之作"><a href="#论文的写作是个训练过程，不能苛求完成精典之作" class="headerlink" title="论文的写作是个训练过程，不能苛求完成精典之作"></a>论文的写作是个训练过程，不能苛求完成精典之作</h3><p>各位要记得我以前的老师所说的一句话：「硕士跟博士是一个训练的过程，硕士跟博士不是写经典之作的过程。」我看过很多人，包括我的亲戚朋友们，他之所以没有办法好好的完成硕士论文，或是博士论文，就是因为他把它当成在写经典之作的过程，虽然事实上，很多人一生最好的作品就是硕士论文或博士论文，因为之后的时间很难再有三年或六年的时间，沉浸在一个主题里反复的耕耘，当你做教授的时候，像我今天被行政缠身，你不再有充裕的时间好好探究一个问题，尤其做教授还要指导学生、上课，因此非常的忙碌，所以他一生最集中又精华的时间，当然就是他写博士、或是硕士论文的时候，而那一本成为他一生中最重要的著作也就一点都不奇怪了。<br>不一定要刻意强求，要有这是一个训练过程的信念，应该清楚知道从哪里开始，也要知道从哪里放手，不要无限的追求完美。当然我不是否认这个过程的重要性，只是要调整自己的心态，把论文的完成当成一个目标，不要成为是一种的心理障碍或是心理负担。这方面有太多的例子了，我在普林斯顿大学念书的时候，那边旧书摊有一位非常博学多文的旧书店老板，我常常赞叹的对他说：「你为什么不要在大学做教授。」他说：「因为那篇博士论文没有写完。」原因在于他把那个博士论文当成要写一本经典，那当然永远写不完。如果真能写成经典那是最好，就像《美丽心灵》那部电影的男主角 John Nash 一样，一生最大的贡献就是博士那二十几页的论文，不过切记不要把那个当作是目标，因为那是自然而然形成的，应该要坚定的告诉自己，所要完成的是一份结构严谨、论述清楚与言之有物的论文，不要一开始就期待它是经典之作。如果你期待它是经典之作，你可能会变成我所看到的那位旧书摊的老板，至于我为什么知道他有那么多学问，是因为那时候我在找一本书，但它并没有在旧书店里面，不过他告诉我：「还有很多本都跟他不相上下。」后来我对那个领域稍稍懂了之后，证明确实如他所建议的那般。一个旧书店的老板精熟每一本书，可是他就是永远无法完成，他梦幻般的学位论文，因为他不知道要在哪里放手，这一切都只成为空谈。 </p>
<h3 id="论文的正式写作"><a href="#论文的正式写作" class="headerlink" title="论文的正式写作"></a>论文的正式写作</h3><ol>
<li>学习有所取舍<br>到了写论文的时候，要能取也要能舍，因为现在信息爆炸，可以看的书太多，所以一定要建构一个属于自己的知识树，首先，要有一棵自己的知识树，才能在那棵树挂相关的东西，但千万不要不断的挂不相关的东西，而且要慢慢的舍掉一些挂不上去的东西，再随着你的问题和关心的领域，让这棵知识树有主干和枝叶。然而这棵知识树要如何形成？第一步你必须对所关心的领域中，有用的书籍或是数据非常熟悉。 </li>
<li>形成你的知识树<br>我昨天还请教林毓生院士，他今年已经七十几岁了，我告诉他我今天要来作演讲，就问他：「你如果讲这个题目你要怎么讲？」他说：「只有一点，就是那重要的五、六本书要读好几遍。」因为林毓生先生是海耶克，还有几位近代思想大师在芝加哥大学的学生，他们受的训练中很重要的一部份是精读原典。这句话很有道理，虽然你不可能只读那几本重要的书，但是那五、六本书将逐渐形成你知识树的主干，此后的东西要挂在上面，都可以参照这一个架构，然后把不相干的东西暂放一边。生也有涯，知也无涯，你不可能读遍天下所有的好书，所以要学习取舍，了解自己无法看遍所有有兴趣的书，而且一但看遍所有有兴趣的书，很可能就会落得普林斯顿街上的那位旧书店的老板一般，因为阅读太多不是自己所关心的领域的知识，它对于你来说只是一地的散钱。 </li>
<li>掌握工具<br>在这个阶段一定要掌握语文与合适的工具。要有一个外语可以非常流畅的阅读，要有另外一个语文至少可以看得懂文章的标题，能学更多当然更好，但是至少要有一个语文，不管是英文、日文、法文 …… 等，一定要有一个语文（外语）能够非常流畅的阅读相关书籍，这是起码的前提。一旦这个工具没有了，你的视野就会因此大受限制，因为语文就如同是一扇天窗，没有这个天窗你这房间就封闭住了。为什么你要看得懂标题？因为这样才不会有重要的文章而你不知道，如果你连标题都看不懂，你就不知道如何找人来帮你或是自己查相关的数据。其它的工具，不管是统计或是其它的任何工具，你也一定要多掌握，因为你将来没有时间再把这样的工具学会。 </li>
<li>突破学科间的界线<br>应该要把跨学科的学习当作是一件很重要的事，但是跨学科涉及到的东西必须要对你这棵知识树有帮助，要学会到别的领域稍微偷打几枪，到别的领域去摄取一些概念，对于本身关心的问题产生另一种不同的启发，可是不要泛滥无所归。为什么要去偷打那几枪？近几十年来，人们发现不管是科学或人文，最有创新的部份是发生在学科交会的地方。为什么会如此？因为我们现在的所有学科大部分都在西方十九世纪形成的，而中国再把它转借过来。十九世纪形成这些知识学科的划分的时候，很多都带有那个时代的思想跟学术背景，比如说，中研院的李院长的专长就是物理化学，他之所以得诺贝尔奖就是他在物理和化学的交界处做工作。像诺贝尔经济奖，这二十年来所颁的奖，如果在传统的经济学奖来看就是旁门走道，古典经济学岂会有这些东西，甚至心理学家也得诺贝尔经济奖，连 John Nash 这位数学家也得诺贝尔经济奖，为什么？因为他们都在学科的交界上，学科跟学科、平台跟平台的交界之处有所突破。在平台本身、在学科原本最核心的地方已经 search 太多次了，因此不一定能有很大的创新，所以为什么跨领域学习是一件很重要的事情。<br>常常一篇硕士论文或博士论文最重要、最关键的，是那一个统摄性的重要概念，而通常你在本学科里面抓不到，是因为你已经泡在这个学科里面太久了，你已经拿着手电筒在这个小仓库里面照来照去照太久了，而忘了还有别的东西可以更好解释你这些材料的现象，不过这些东西可遇而不可求。 John Nash 这一位数学家为什么会得诺贝尔数学奖？为什么他在赛局理论的博士论文，会在数十年之后得诺贝尔经济奖？因为他在大学时代上经济学导论的课，所以他认为数学可以用在经济方面来思考，而这个东西在一开始，他也没有想到会有这么大的用处。他是在数学和经济学的知识交界之处做突破。有时候在经济学这一个部分没有大关系，在数学的这一个部分也没有大关系，不过两个加在一起，火花就会蹦出来。 </li>
<li>论文题目要有延展性<br>对一个硕士生或博士生来说，如果选错了题目，就是失败，题目选对了，还有百分之七十胜利的机会。这个问题值得研一、博一的学生好好思考。你的第一年其实就是要花在这上面，你要不断的跟老师商量寻找一个有意义、有延展性的问题，而且不要太难。我在国科会当过人文处长，当我离开的时候，每次就有七千件申请案，就有一万四千个袋子，就要送给一万四千个教授审查。我当然不可能看那么多，可是我有个重要的任务，就是要看申诉。有些申诉者认为：「我的研究计划很好，我的著作很好，所以我来申诉。」申诉通过的大概只有百分之十，那么我的责任就是在百分之九十未通过的案子正式判决前，再拿来看一看。有几个印象最深常常被拿出来讨论的，就是这个题目不必再做了、这个题目本身没有发展性，所以使我更加确认选对一个有意义、有延展性、可控制、可以经营的题目是非常重要的。<br>我的学生常常选非常难的题目，我说你千万不要这样，因为没有人会仔细去看你研究的困难度，对于难的题目你要花更多的时间阅读史料，才能得到一点点东西；要挤很多东西，才能筛选出一点点内容，所以你最好选择一个难易适中的题目。<br>我写过好几本书，我认为我对每一本书的花的心力都是一样，虽然我写任何东西我都不满意，但是在过程中我都绞尽脑汁希望把他写好。目前为止很多人认为我最好的书，是我二十几岁刚到史语所那一年所写的那本书。我在那本书花的时间并不长，那本书的大部分的稿子，是我和许添明老师同时在当兵的军营里面写的，而且还是用我以前旧的笔记写的。大陆这些年有许多出版社，反复要求出版我以前的书，尤其是这一本，我说：「不行。」因为我用的是我以前的读书笔记，我怕引文有错字，因为在军队营区里面随时都要出操、随时就要集合，手边又没有书，怎么可能好好的去核对呢？而如果要我重新校正一遍，又因为引用太多书，实在没有力气校正。<br>为什么举这个例子呢？我后来想一想，那本书之所以比较好，可能是因为那个题目可延展性大，那个题目波澜起伏的可能性大。很多人都认为，我最好的书应该是剑桥大学出的那一本，不过我认为我最好的书一定是用中文写的，因为这个语文我能掌握，英文我没办法掌握得出神入化。读、写任何语文一定要练习到你能带着三分随意，那时候你才可以说对于这一个语文完全理解与精熟，如果你还无法达到三分的随意，就表示你还在摸索。<br>回到我刚刚讲的，其实每一本书、每一篇论文我都很想把它写好。但是有些东西没办法写好，为什么？因为一开始选择的题目不够好。因此唯有选定题目以后，你的所有训练跟努力才有价值。我在这里建议大家，选题的工作要尽早做，所选的题目所要处理的材料最好要集中，不要太分散，因为硕士生可能只有三年、博士生可能只有五年，如果你的材料太不集中，读书或看数据可能就要花掉你大部分的时间，让你没有余力思考。而且这个题目要适合你的兴趣和专长，如果你不会统计学或讨厌数字，但却选了一个全都要靠统计的论文，那是不可能做得好。 </li>
<li>养成遵照学术格式的写作习惯<br>另一个最基本的训练，就是平时不管你写一万字、三万字、五万字都要养成遵照学术规范的习惯，要让它自然天成，就是说你论文的脚注、格式，在一开始进入研究生的阶段就要培养成为你生命中的一个部份。如果这个习惯没有养成，人家就会觉得这个论文不严谨，之后修改也要花很多时间，因为你的论文规模很大，可能几百页，如果一开始弄错了，后来再从头改到尾，一定很耗时费力，因此要在一开始就养成习惯，因为我们是在写论文而不是在写散文，哪一个逗点应该在哪里、哪一个书名号该在哪里、哪一个地方要用引号、哪一个要什么标点符号，都有一定的规定，用中文写还好，用英文有一大堆简称。在 1960 年代台湾知识还很封闭的时候，有一个人从美国回来就说：「美国有个不得了的情形，因为有一个人非常不得了。」有人问他为什么不得了，他说：「因为这个人的作品到处被引用。」他的名字就叫 ibid 。所谓 ibid 就是同前作者，这个字是从拉丁文发展出来的，拉丁文有一大堆简称，像 et. al. 就是两人共同编的。英文有一本 The Chicago Manual of Style 就是专门说明这一些写作规范。各位要尽早学会中英文的写作规范，慢慢练习，最后随性下笔，就能写出符合规范的文章。 </li>
<li>善用图书馆<br>图书馆应该是研究生阶段最重要的地方，不必读每一本书，可是要知道有哪些书。我记得我做学生时，新进的书都会放在图书馆的墙上，而身为学生最重要的事情，就是要把书名看一看。在某些程度上知道书皮就够了，但是这仍和打计算机是不一样的，你要实际上熟悉一下那些书，摸一下，看一遍目录。我知道现在从计算机就可以查到书名，可是我还是非常珍惜这种定期去 browse 新到的书的感觉，或去看看相关领域的书长成什么样子。中研院有一位院士是哈佛大学信息教授，他告诉我他在创造力最高峰的时候，每个礼拜都到他们信息系图书室里，翻阅重要的信息期刊。所以图书馆应该是身为研究生的人们最熟悉的地方。不过切记不重要的书或文献不要花时间去看，你们生活在信息泛滥的时代，跟我生长在信息贫乏的时代是不同的，所以生长在这一个信息泛滥的时代，你要学会有所取舍。我常常看我的学生引用一些三流的论文，却引得津津有味，我都替他感到难过，因为我强调要读有用、有价值的东西。 </li>
<li>留下时间，精致思考<br>还要记得给自己保留一些思考的时间。一篇论文能不能出神入化、能不能引人入胜，很重要的是在现象之上作概念性的思考，但我不是说一定要走理论的路线，而是提醒大家要在一般的层次再提升两三步， conceptualize（概念化） 你所看到的东西。真切去了解，你所看到的东西是什么？整体意义是什么？整体的轮廓是什么？千万不要被枝节淹没，虽然枝节是你最重要的开始，但是你一天总也要留一些时间好好思考、慢慢沉淀。 conceptualize 是一种非常难教的东西，我记得我念书时，有位老师信誓旦旦说要开一门课，教学生如何 conceptualize ，可是从来都没开成，因为这非常难教。我要提醒的是，在被很多材料和枝节淹没的时候，要适时跳出来想一想，所看到的东西有哪些意义？这个意义有没有广泛连结到更大层面的知识价值。<br>傅斯年先生来到台湾以后，同时担任中央研究院历史语言研究所的所长及台大的校长。台大有个傅钟每小时钟声有二十一响、敲二十一次。以前有一个人，写了一本书叫《钟声二十一响》，当时很轰动。他当时对这二十一响解释是说：因为台大的学生都很好，所以二十一响是欢迎国家元首二十一响的礼炮。不久前我发现台大在每一个重要的古迹下面竖一个铜牌，我仔细看看傅钟下的解释，才知道原来是因为傅斯年当台大校长的时候，曾经说过一句话：「人一天只有二十一个小时，另外三小时是要思考的。」所以才叫二十一响。我觉得这句话大有道理，可是我觉得三小时可能太多，因为研究生是非常忙的，但至少每天要留个三十分钟、一小时思考，想一想你看到了什么？学习跳到比你所看到的东西更高一点的层次去思考。 </li>
<li>找到学习的楷模<br>我刚到美国念书的时候，每次写报告头皮就重的不得了，因为我们的英文报告三、四十页，一个学期有四门课的话就有一百六十页，可是你连脚注都要从头学习。后来我找到一个好办法，就是我每次要写的时候，把一篇我最喜欢的论文放在旁边，虽然他写的题目跟我写的都没关系，不过我每次都看他如何写，看看他的注脚、读几行，然后我就开始写。就像最有名的男高音 Pavarotti 唱歌剧的时候都会捏着一条手帕，因为他说：「上舞台就像下地狱，太紧张了。」他为了克服紧张，他有习惯性的动作，就是捏着白手帕。我想当年那一篇论文抽印本就像是我的白手帕一样，能让我开始好好写这篇报告，我学习它里面如何思考、如何构思、如何照顾全体、如何用英文作脚注。静下心来，好好的把一位大师的作品或一本经典的论文读完，开始模仿和学习它，是入门的最好方法。逐步的，你也开始写出自己的东西。我也常常鼓励我的学生，出国半年或是一年到国外看看，像现在国科会有各式各样的机会，可以增长眼界，可以知道现在的餐馆正在卖些什么菜，回来后自己要作菜也才知道要如何着手。 </li>
</ol>
<h2 id="用两条腿走路，练习培养自己的兴趣"><a href="#用两条腿走路，练习培养自己的兴趣" class="headerlink" title="用两条腿走路，练习培养自己的兴趣"></a>用两条腿走路，练习培养自己的兴趣</h2><p>最后还有一点很重要的，就是我们的人生是两只脚，我们不是靠一只脚走路。做研究生的时代，固然应该把所有的心思都放在学业上，探索你所要探索的那些问题，可是那只是你的一只脚，另外还有一只脚是要学习培养一、两种兴趣。很多人后来会发现他的右脚特别肥重（包括我自己在内），也就是因为忘了培养左脚。很多很有名的大学者最后都陷入极度的精神困扰之中，就是因为他只是培养他的右脚，他忘了培养他的左脚，他忘了人生用两只脚走路，他少了一个小小的兴趣或嗜好，用来好好的调节心情或是排遣自己。<br>去年夏天，香港《亚洲周刊》要访问我，我说：「我不想接受访问，我不是重要的人。」可是后来他们还是把一个简单的对话刊出来了，里面我只记得讲了一段话：做一个研究生或一个学者，有两个感觉最重要 – 责任感与罪恶感。你一定要有很大的责任感，去写出好的东西，如果责任感还不够强，还要有一个罪恶感，你会觉得如果今天没有好好做几个小时的工作的话，会有很大的罪恶感。除非是了不得的天才，不然即使爱因斯坦也是需要很努力的。很多很了不得的人，他只是把所有的努力集中在一百页里面，他花了一千小时和另外一个人只花了十个小时，相对于来说，当然是那花一千个小时所写出来的文章较好。所以为什么说要赶快选定题目？因为如果太晚选定一个题目，只有一年的时间可以好好耕耘那个题目，早点选定可以有二、三年耕耘那个题目，是三年做出的东西好，还是一年的东西好？如果我们的才智都一样的话，将三年的努力与思考都灌在上面，当然比一年还要好。 </p>
<h2 id="营造卓越的大学，分享学术的氛围"><a href="#营造卓越的大学，分享学术的氛围" class="headerlink" title="营造卓越的大学，分享学术的氛围"></a>营造卓越的大学，分享学术的氛围</h2><p>现在很多人都在讨论，何谓卓越的大学？我认为一个好的大学，学校生活的一大部份（如咖啡厅、餐厅等），以及校园的许多活动，直接或间接都与学问有关。同学在咖啡厅里面谈论的，直接或间接也都会是学术相关的议题。教授们在餐厅里面吃饭，谈的是「有没有新的发现」？或是哪个人那天演讲到底讲了什么重要的想法？一定是沉浸在这种氛围中的大学，才有可能成为卓越大学。那种交换思想学识、那种互相教育的气氛不是花钱就有办法获得的。我知道钱固然重要，但不是唯一的东西。一个卓越的大学、一个好的大学、一个好的学习环境，表示里面有一个共同关心的焦点，如果没有的话，这个学校就不可能成为好的大学。<br>虽然文章写的貌似很长，看完的人也是褒贬不一，总的来说，作为一个研究生，在国内需要2年或3年的时间，国外是1年或2年的时间，其实，在读研之前，大家的憧憬也许是好的，看着看那，但是在大家真正进入到学习中一段时间后，就会发现自己的期望值在一点点的降低，这个降低并不是自己价值观的降低，实际上是被客观实际情况所柔化了，我们憧憬的所谓研究真正落实到每个人头上的时候，也许很多时候是不理想的，也许枯燥，也许重复，也许碰到不负责任的老师，也许这个课题不符合实际情况，也许碰到假课题，这些情况时有发生，在不同程度的打击着我们。读研对于不同的人来说有时候是辛苦，有时候是娱乐，这完全取决于个人。重要的是你能保持对于你做的事情的热情，并认真的去完成它。<br>     我理解的研究生的整个学习过程是一个提升自己的一个过程，而并不仅仅是为了研究出什么东西，实际来讲，硕士生实际上是没有什么创新的（特别是在国内），更多的是在训练自己的素质，正由自身的素质上去了，你在做课题的同时才能想到更多，收获也越大，不管怎么样，如果你能在毕业的时候回顾自己走过的几年，能够觉得比你刚入学时成熟了很多，并且学会了很多原则性的潜意识的东西的话，就算是一种比较成功的过程。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[搭建博客急需解决的问题]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2015/12/12/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%80%A5%E9%9C%80%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
      <content type="html"><![CDATA[<h2 id="本地网页如何链接"><a href="#本地网页如何链接" class="headerlink" title="本地网页如何链接"></a>本地网页如何链接</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote>
<p>自己设计了一个网页，想在Github上进行托管，<br>博客给出网页链接，点击链接打开新网页</p>
</blockquote>
<a id="more"></a>
<h2 id="namecheap二级域名"><a href="#namecheap二级域名" class="headerlink" title="namecheap二级域名"></a>namecheap二级域名</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote>
<p>使用的namecheap的chengong.me域名<br>如何将github page与二级域名进行绑定</p>
</blockquote>
<h2 id="多说回复bug"><a href="#多说回复bug" class="headerlink" title="多说回复bug"></a>多说回复bug</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote>
<p>回复不是在自己主页<br>别人blog也有同步<br>多说头像旋转</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《从加州理工到高盛银行》by粟耀莹]]></title>
      <url>http://i90s.vip/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/2015/12/11/%E4%BB%8E%E5%8A%A0%E5%B7%9E%E7%90%86%E5%B7%A5%E5%88%B0%E9%AB%98%E7%9B%9B%E9%93%B6%E8%A1%8C.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整十年前，我妈妈洪冬桂博士写「我家胖比」一书，造成很大轰动。那个小名「胖比」的女孩，就是我─艾丽斯，粟 (Alyce Su)，粟耀莹。那本书写了我从降生到大学毕业的许多趣事，把我塑造成一个很逗人喜欢、奋发上进的小姑娘。我还记得那书最后的结论是：“人们不会怀疑十年之后的科学家名单中有粟耀莹的名字，可是到那时候，除了她爸爸粟教授外，很少人会知道世界上曾有一个名叫『粟胖比』的女孩”！</p>
<p>妈妈这个结论，是根据我当年表现出的性向而下的。<a id="more"></a>我在科学方面的天赋确实很高，举个例子，我进入大学四年级的时候，由于已修完了所有物理系的应修学分，便到研究所去选修公认最难的课：量子物理学和相对性天文学，结果我前者拿了九十九分，后者拿了九十八分，满分都是一百。 我也拿到朱经武奖学金。那时我非常自信，认为此生应可拿到一项诺贝尔奖。</p>
<p>以前台大物理系的恩师们，丘宏毅教授，李文中教授，林清凉教授，扬信男教授，黄伟彦教授，张国龙教授，都对我诸多期许与鼓励。尤其是林清凉教授，在上量子物理时，总是以我作例子，教训和我同班上课不够认真的台大物理研究所的学长们。</p>
<p>后来很多人问我，Alyce，你拿了加州理工这么难念的博士，怎么不教书或作研究? 这个问题，自我从商开始，已经回答了N遍，答案是：我从来没有想要教书或作研究，我去加州理工，这个在世界上诺贝尔奖得主密度最大的地方，是为了接受其熏陶，以悟出如何得到诺贝尔奖的道理，并对我当年的偶象Feynman费因曼（著名的物理诺贝尔奖得主，著有Surely You’re Joking，Mr。Feynman 一书）生前待过最久的地方，进行模拜。</p>
<p>当年因为家庭环境的缘故，不知道还有Bill Gates，Larry Ellison，Warren Buffet，这种人，不然一定早就打算如何进华尔街或硅谷，作交易员或向风险投资家融资来创业。后来知道世界上原来还有这些白手起家的富豪，二话不说，在加州理工学院修得生物科技/物理学博士，也就是受完最好的自然科学训练之后，马上跳出了科学方面的职场，慨然踏进了金融行业。</p>
<h2 id="19岁走出台湾赴美"><a href="#19岁走出台湾赴美" class="headerlink" title="19岁走出台湾赴美"></a>19岁走出台湾赴美</h2><p>大学四年级时，我还不到二十岁，考完托福和GRE后 (多谢来欣补习班的方有毅老师，当年我的GRE 是全台湾考出的前三高分)，申请学校的结果，得到多所美国名校的入学许可。加州理工，哈佛，哥伦比亚，柏克莱，康奈尔，芝加哥，等等。加州理工物理系历年为全美物理排名第一。哥伦比亚给我诺贝尔奖得主李政道奖学金。柏克莱给我全额奖学金，其天文系第一把手徐遐生教授来台湾演讲时，还特地安排与我见面，希望要我选择柏克莱，以为中国天文物理界培育接班人。康奈尔也派出钟威，当年台湾清大有名的资优生，向我招手。钟威在康奈尔学的是最难的“超弦论” (Super-String Theory)，但后来也投身华尔街。</p>
<p>我和父亲特别到美国这些学校都看过，才决定加州理工。</p>
<h2 id="进入加州理工"><a href="#进入加州理工" class="headerlink" title="进入加州理工"></a>进入加州理工</h2><p>一九九二年六月，我正告别了深爱我的家人，要到加州理工学院这所精致的大学深造。临行前一天，有缘和当年台湾最有名的天才，扬柏因见面。扬柏因刚从MIT回台湾，以4年时间修完博士，为台湾历史上最年轻的博士。在台大时，扬维哲教授是学生最喜欢的老师，扬柏因为扬维哲教授之子，又是台大物理系的学长及当年有名的资优生，未见面前很多人告诉我很多传闻，听说是又矮又小。结果一见之下，居然又高又大。我们聊的很开心，可惜第二天我就飞美国了。</p>
<p>本来怀这雄心壮志到加州理工学院，结果才发现学物理的找不到工作，去拜见物理系的教授，不是不收学生，就是研究经费减少，然后就造就了许多10年的研究生，不时没毕业，就是一直留在实验室作同一个教授的博士后研究员。从商业的角度来看，怪不得读博士学校付奖学金，读MBA则要交学费。</p>
<p>当时我连计算机都不会用，只是理论很行，为了在研究中能生存，一九九二年夏天，一天晚到校园的计算机中心泡在计算机前苦练计算机。有一天，我计算机屏幕上有人从另一台计算机上给我写字，约我和他去喝COFFEE。我望那一台计算机一看，看到一个中国人，个头不高。原来他是中国大陆少年班出来的，12 岁进安徽的科技大学，16岁大学毕业到加州理工学院博士班。我还以为我 19岁来加州理工学院博士班多了不起，原来人外有人，天外有天。但他已经来加州理工4年了，正在写博士论文。</p>
<p>他的指导教授是Tom Prince在美国的计算机天文学中是领导。他们一天到晚有一大堆的资料，从看星星得来，要作数据处理。因为数据真的太多了，他们有时要用PARAGON也就是“超级并行计算机”来作”并行计算”(Parallel Computing)。那时全美国也只有５个地方有这样大计算容量的计算机，加州理工为其中之一。</p>
<p>他告诉我，暑假还是准备开学的考试。考过了，就不必花一年的时间修物理课。越早开始做研究越好。我听他的话，专心准备。</p>
<p>1992年9月，学校便给我们这些新生一个考试，要测定所有新入学者的真实程度，以确定对每个人如何安排，如是要念硕士还是直攻博士甚至是不是要转系。考试的科目为 (1) 古典物理 (2) 量子物理 (3) 数学物理。我前两门得了全班前五高分，数学物理得了第二高分。数学物理最高分的是一位哈佛Harvard来的，大学就和教授做“超弦论” (Super-String Theory)的研究，大学毕业论文就相关的题目，还发表在Physics Review。我虽然一个最高分都没那到，和以前在台大物理系很不一样，我很高兴没丢台湾人的脸。我们那一年受了30个左右的新生，是从全球来的精英。</p>
<p>物理博士生第一年，主要是修课，谁要是不想修也可以，但又得参加免修考试，考过了就可免修考试考的都是很难的题目，那目的可能是要挫一下想免修的人的锐气，要人知难而退，乖乖修读所有课程。考试的科目为 (1) 古典物理 (2) 量子物理 (3) 高等应用数学 (4) 高能物理 (5) 核物理。其中我后4门都用考过的，只有第一们古典物理特别去上Kip Thorne的课。Kip Thorne是近代相对论的始祖，其嫡传弟子包括台湾清华大学名教授倪维斗。</p>
<p>考试证明实力之后，物理系的系主任及教授们都认识我，也给我比较多的自由。系主任有几次请我去爬山，我带朋友一起去。 </p>
<p>这一年我因此而有比较多的空档时间，我把这些时间用来扫描物理学门中比较有发展前途的课题，以决定自己的研究方向。我曾去拜见过叶乃裳教授，叶乃裳教授是台湾有名的才女，当年上过Time Magazine，一个星期工作100小时，以作超导体著名。我一看，她实验室的博士生就是收在机器旁边等数据。我问这位女博士生，何必守在旁边和机器一起等数据，她说机器还是有可能故障，一出故障，数据收集要从新来过。这个女博士生出身不凡，是印度的公主。堂堂印度的公主在自然的面前也没有特权，可见这科学科技真的是凭真本事。</p>
<p>这时我发现，物理学本身几乎处于饱和状态，倒是物理学与生物学交界的学问，很值得研究。那时在这个部门用心的人极少，这就是今天全球正在热炒的生物科技，或称生物工程。</p>
<p>我打定主意，要以生物科技为自己的研究主题。但是问题来了，我根本没有修过大学有关生物学的课程。没有这方面的基础，而想进行生物科技研究，并要取得成绩，实在是不可能的。</p>
<h2 id="从物理转生物科技"><a href="#从物理转生物科技" class="headerlink" title="从物理转生物科技"></a>从物理转生物科技</h2><p>说到这儿，我就要感谢加州理工弹性的教学体制。当我把我的研究计划提出来后，我要求到大学部去上生物课程，这在别的学校几乎是不可能的事，但是加州理工竟然准了，让我用一年的时间，跟生物系的大学生一道修生物方面的专业课，并学习基本的实验。加州理工大学部是有名的天才班，很多11的12 岁的小孩确问最犀利的问题，或能答出教授所问最难的问题。我20岁坐在那儿，已经算老了。这时候我才知道以前和我同学的学长姐们，有何感想。</p>
<p>所谓隔行如隔山，到我亲身从物理学界跨进生物学界，才真正了解这句话的真正涵义。在此之前，我从高中就不念生物，生物只有国中程度，对生物学所知真是有限，待进了大学生物系的课堂，才发现要学的东西多着呢。但加州理工毕竟不一样，教授讲生物思考模式，而不是琐碎的事件，常讲最新的发现，或是自己研究的发现。每一子科的课本中，重大的研究成果好像都从加州理工作出来，课本上面的某某，要嘛是加州理工学校的教授，或是同学的父母亲或亲戚，读起来真的很带劲，让人有一个有为者亦若是的抱负。</p>
<p>虽然物理和生物两门学问，不论在思考学习的模式或实验方法主体上，在科学?相邻最远，但我觉得物理于生物学交叉的部分真是蕴藏着无限的学问，故很愿意花时间下工夫。</p>
<p>但是，任何时候、任何地方，一定有所谓「保守势力」，他们对于具创新意义的事，总有些抵触情绪，连加州理工生物系也不例外。学校批准我这个物理博士生到生物系大学部修课，有些老师、同学都当笑话看，不知道学校在弄什么花样。直到我生物学修课了好成绩，并且用所学得的这方面的知识与物理学结合，做出了很有价值的实验，且取得了可以实用的专利，投射在我身上的异样眼光才收敛掉，这是后话。</p>
<h2 id="得到芯片之父Carver-Mead及诺贝尔奖得主Rudi-Marcus的鼓励"><a href="#得到芯片之父Carver-Mead及诺贝尔奖得主Rudi-Marcus的鼓励" class="headerlink" title="得到芯片之父Carver Mead及诺贝尔奖得主Rudi Marcus的鼓励"></a>得到芯片之父Carver Mead及诺贝尔奖得主Rudi Marcus的鼓励</h2><p>加州理工有一个新建的系，叫 Computation and Neural Systems 计算及神经系统系。这个系的创办人之一叫做Carver Mead，所有电机系出身的没有不认识他的，他是超大型机体电路VLSI之父，也是Intel创始人Gordon Moore的好朋友。Carver Mead是Feynman费因曼在加州理工最好的朋友之一，因为两人的程度都不是一般人的智力能及。Feynman费因曼在死前，在加州理工最喜欢的研究题目，已经不在纯物理的范围，而在Nano-Technology一类用做原子做工程的应用，以及物理和生物的交界尤其是神经科学这种和电有关系的，这正是Carver Mead 毕生研究的范围。</p>
<p>正像很多最杰出的工程师一样，他们觉得最了不起的计算机设计无他 – 就是人脑! 故Carver Mead就想做chips that can see会看的芯片，chips that can hear会听的芯片。Carver Mead觉得要能理解人脑，一定要能建造一个，才表示懂。而人脑如此复杂，一定要把他分成几块，于是能看的这一块，和能听的这一块，都被他抽出来磨拧。Carver Mead用他的研究成果开了很多家公司，多在北加州，靠进旧金山及史旦佛大学一带。有一个公司取名叫Synaptic神经突触，其意不言自明。他在加州理工开课，就是为他的公司培训以后的员工。</p>
<p>Carver Mead曾指导过一个天才女学生，Misha Mohawald，她是第一个加州理工获得最优秀博士论文的女性，也上过美国全国电视网介绍杰出女科学家的节目。Carver Mead和Misha Mohawald 共同作出了第一片能看到芯片。Misha博士后到Oxford拜师Rodney Douglas名下。Rodney为Misha 在瑞士最好的理工大学ETH开了一个系，叫Neuro-morphic Engineering仿神经网络的工程系。Misha于30岁出头，自杀结束了她精彩但短暂的一生。</p>
<p>我研究生第一年修Carver Mead的课。Carver Mead在加州理工是研究生心目中的神。每堂课爆满不说，每个学生都枪要坐前面，而且枪者回答Carver Mead的问题，希望引起Carver Mead的重视。那些学生多是电机系的，而且是加州理工的电机系，功力之高可想而知。我也属于坐前排枪答Carver Mead问题的学生，但高手环视之下，我大学又不是学这个的，出头很难。</p>
<p>不过，全班大概就我一个中国女生。期末，有一次，Carver Mead画了一个很难的线路图，很多平常的高手，不是没回答，或是答错。我一看原来那些答案是错的，我便举手，用了消去法，猜出了一个答案。Carver Mead一听，很高兴，觉得孺子可教也，课后就请我去Athenaem喝一杯小酒。那时快要过Christmas 圣诞节了，去喝一杯小酒很正常，校园大家都在开舞会。</p>
<p>Carver Mead的课是5:00 pm上到 7:00 pm。那一天晚上，7:00多，天色很暗，Carver和我在走在到Athenaem (Athenaem 是加州理工一个教员学生吃饭的地方) 的路上，我向Carver 问起我的偶象Feynman 生前的情形。在Feynman已经去世的情况下，Carver这位Feynman生前最亲近的朋友，感觉上是与Feynman 最相近的人。</p>
<p>我们在Athenaem找了个位置坐了下来。Carver 告诉我许多 Feynman 生前的事情，言语中充满怀友之情。Carver问我打算选那一个研究方向或题目? 我说生物物理方面，但还不确定那一个题目。我物理考试都高分考过，重新和大学学生一起学生物，也修电机系您的课，就是想多了解这个领域。Carver说: 我在班上有注意到你，你一看就是那种很努力，一天到晚想要跳得更高的人，你需要一个教练。Carver 再说: 这样吧，我时间有限，不能亲自指导你，但我的另一个好友，Rudi Marcus，刚的化学诺贝尔奖的那一位，身在学术界，应该有多一些时间与你讨论，你不妨去找他谈谈。</p>
<p>我第二学期就去修Rudi Marcus开的课。Rudi是个很有儒家修养的教授，身为诺贝尔奖得主，并无改变他的生活。Rudi对我非常赏识，提我写了很好的推荐信。</p>
<h2 id="到生物系找指导教授"><a href="#到生物系找指导教授" class="headerlink" title="到生物系找指导教授"></a>到生物系找指导教授</h2><p>1993年，加州理工已公认我是本校物理系与生物系合作的拓荒者。在我之前，这所全美首屈一指的理工名校，还不曾有过一个扮演这种角色的人。至拓出什么名堂来，很多人还在看。但我的名气是不缺，所有生物系的教授都认识我。我很欣慰的是，1998年我博士毕业那一年，加州理工生物系特别成立了一个“生物物理奖学金”，开放给所有希望在物理与生物交界处作研究的博士生，就是像我这种人。</p>
<p>1993年的万圣节，我参加加州理工校园举办的万圣节Halloween Party。加州理工本来就是有名的怪，再加上万圣节这个作怪的节日，怪上加怪可想而知。每个人的装扮不止是面具，披风，有人用玻璃和晶体管把自己围住，装扮成计算机司服器computer server，引起很多人围观。那真的很厉害，从外面看还真的以为是计算机司服器。</p>
<p>我就是在那个舞会上，遇见Steve Mayo我后来的博士论文指导教授，和他的第一个研究生Bassil Dahiyat。</p>
<p>Steve Mayo那时刚被加州理工聘进来当助理教授，他想做一个可以做蛋白质设计的计算机软件。Steve在大学时就写过一软件程序做分子模型模拟，在加州理工念博士时，就是把大学写的软件程序推广，后来和他的指导教授一起成立了一家公司专卖这个软件给学术机构和大公司的研究部门。最后这家公司被 Pharmacopia收购，Steve的股票大赚了一笔。</p>
<p>Bassil Dahiyat大学念的是约翰-霍普金斯，三年就毕业，后来在约翰-霍普金斯又待了两年，不但拿了硕士，还替他的指导教授成立实验室，发表多篇论文。Bassil的专长是Biomedical Engineering生医工程，理论实验都非常厉害，是那一年加州理工有名的高材生。</p>
<p>这两人1993就有一个远景，要把这个蛋白质设计的计算机软件做出来，并且商业化。</p>
<p>我一听，觉得这就是我想做的方向，第二天就去Steve Mayo的实验室和他谈，他也欣然答应受我作学生。因为他就是要找对生物有兴趣，但又能用理论的方式建立模型的人。</p>
<p>那时我是Steve Mayo的第三个门生，Steve Mayo 的第二个门生叫做Jay，是中国科大的高材生，得过科大的最高荣誉之一的郭末若奖学金。但Jay没有选择做蛋白质设计的计算机软件，作别的博士题目。</p>
<p>Steve Mayo，Bassil Dahiyat，和我，三个人就展开了几年蛋白质工程的科技商业化之路。</p>
<h2 id="我做出了一个经典生物物理模型"><a href="#我做出了一个经典生物物理模型" class="headerlink" title="我做出了一个经典生物物理模型"></a>我做出了一个经典生物物理模型</h2><p>Steve Mayo的实验室才刚开张，由于Steve在计算机方面的功力和成功的科技商业化 (Technology Commercialization) 成功经验，实验经费相当宽裕，尤其是私营的研究经费。Steve用了这些经费先买了好几台计算机，SGI，Sun，Mac，各种版本的都有，编译器也是有Fortran和C语言的。也买了一台600的NMR全美只有最专业的地方才有。其它的实验器材在慢慢的采购之中，实验室每天茁壮成长，渐渐成型。</p>
<p>那时，有个名气很大、人也非常好的犹太教授亨利-乐斯特 (Henry Lester) 和他一个超强的，从以色列来的犹太博士后研究生瑟拉-美革 (Sela Mager) 他们有非常稀有的数据，从某稀有蛋白质 (neuro-transmitter transporter)上量到。这种蛋白质，对了解药物上隐，有很重要的药理功能。他们希望对这一类的蛋白质输送分子的行为，做一个动力模型，以方便日后科学家对药物上隐学的研究。有一天，他两走进我们的实验室，找Steve谈。因为这个模型的建立需要用计算机，写程序，是Steve的专长。</p>
<p>Steve那时正亲手写一个快速寻找的计算机程序，没有这个程序，蛋白质设计的计算机软件是无方运做的，故在等这个程序的过程中，Bassil和我都先做其它的项目。Bassil和Beckman Institute 的一个实验室合作，做实验。我则在Steve，Henry和 Sela，的同意和指导下，开始我的第一个研究计划，为他们的实验数据做一个模型。</p>
<p>制作生物学模型须依助计算机。当时我的计算机功力还不强，还没有完成过高级的设计。正在这时候，一个计算机方面的厉害角色，出现在我的身边。</p>
<p>这个人叫Erik Winfree，是个德国裔的犹太人，只比我大两岁。他在计算机方面不是普通的高强，真称得上是圣手级。Erik的父亲Art Winfree是有名的教授，得过McArthur (Genius) Award，在美国那个叫天才奖。Erik也替 Mathematica 的创办人，也是加州理工前校友，另一个天才 Steve Wolfram 做过程序及研究。这种背景，计算机与逻辑的功力真是无庸置疑。Erik在拿到博士学位后，立刻被加州理工聘为教授，这是极少极少有的事。有其父必有其子，他后来也拿了一个McArthur (Genius) Award。</p>
<p>Erik和我常常就这个模型讨论，也在计算机方面给我的指导。Henry和 Sela 也很够意思，每有新资料就喂给我的模型。Sela 和我也经常就这个模型进行讨论。讨论到一定程度是，就报告给Henry看还有没有要改进的地方。他们本来只要解释他们自己的数据，结果看哪个模型越来越厉害，连他们还没测量到数据也可以预测，就变本加厉把别的实验室量到，有关这种新潮蛋白质的资料也拿来看我们的模型是否能解释。给他们这样一搞，这个模型把那时所有的数据都不但解释，而且预测到了。</p>
<p>我所做出的这模型，不但可以解释Henry和Sela他们发现的现象，还可预测一些别的新的实验现象，这些预测到的现象，后来在其它的实验室如UCLA的名实验室中被发现，因此我做的模型在生物学界相当轰动，Henry 和 Sela到那一阵到什么地方都讲这模型。</p>
<p>Henry 和 Sela 这两个老犹对我完成的工作满意极了，他们在我毕业后为我写求职推荐信时，把我写得非常完美。 Henry 和 Sela是很典型的犹太人 (Henry 的儿子取名叫 Ben，可想而知) 我为此不但对他俩，也爱屋及乌，对所有的犹太人充满预先的敬意。</p>
<p>1995年，我从加州理工发表的第一篇科学论文，就是说明这个模型所统合的各种现象。</p>
<h2 id="我用分子生物学的方法从事蛋白质工程研究"><a href="#我用分子生物学的方法从事蛋白质工程研究" class="headerlink" title="我用分子生物学的方法从事蛋白质工程研究"></a>我用分子生物学的方法从事蛋白质工程研究</h2><p>我和Henry 和 Sela的合作，实验资料是他们提供，我自己是一个实验也不用做。生物学为何初学时感觉是很多片面的知识，因为实验是生物学的基础，生物学便是由这些实验结果基类出来的。如果只是用记忆实验结果的方式，而不去探讨为何会去做那样的实验，是无法了解其精髓而为己所用的。</p>
<p>蛋白质工程和一个纯生物物理模型的差别，是一定要有实验数据来证实或推翻一些假设。用已证实或推翻的假设为基础，再往上堆积。我从 1993 年到 1994 年，陆续修了一些大学部的实验课程，从最基本的 Pipetting (一种实验仪器)开始学。这是最基本的蹲马步，问题是这些学会了之后，和真正能设计自己的实验，并完成这些实验取得可信的实验结果，是两回事。</p>
<p>实验最恐怖的是变因太多，当你以为都想好时，可能结果跟你预期的不一样，因为还有你没想到的变量。故可能要多做几次，才看到所有没考虑到的因素。这时，一要耐心和体力，二要经费。实验是非常耗费金钱与资源的。随着实验越做越多，技巧越好，越能越快得到好的数据。所以一般的指导教授喜欢找有经验的实验研究生，如果以前没有做过实验，没有经费的指导教授是不愿意让这些学生浪费钱的。因此，我从进入 Steve 的实验室开始，无时无刻在想我要如何说服 Steve 和 Bassil 能让我做实验。</p>
<p>Bassil 是做化学实验出身，可以在不用仪器之下，做出很长的蛋白质。但若要更有效的做出更大的蛋白质，必须买仪器 (peptide synthesizer)。但再大的蛋白质，就的用分子生物的方法，买 Oligonucleautide 用 PCR 技术备份，再把这些 DNA 和载体 (Plasmid) 都用效素在特定的地方切，再用粘效素 (ligase) 把 DNA和载体结合。这种 Recombinant DNA 进入细胞以后，就利用细胞现成的机制，把 DNA 变成蛋白质。这个蛋白质从细胞中做出来，到纯化，到干干净净又大量的能进入试管中，做生物物理的定量研究，如 Circular Dichroism 或 NMR 核磁共震，又需要很多人力。 这就是所谓的 Genetic Engineering 基因工程，是蛋白质工程?面很重要的一环。</p>
<p>为了让这个蛋白质设计软件不止是个理论软件，其设计结果有实际用途，我们必须把软件设计出的蛋白质序列从实验室中做出来，然后用生物工程的仪器，如Circular Dichroism 或 NMR 核磁共震等，测出所设计蛋白质的性质，如抗热性，稳定性，结构，等等，来看看软件设计的结果如何。软件设计的结果如果不如预期，我们便要调整软件?的参数，重新再预测新的蛋白质序列，重新再做实验，看结果如何，一直到软件?的参数能够值得信赖地预测出设计者要的蛋白质。</p>
<p>在我开始做实验之前，Bassil 都是用化学的方式，用 Peptide Synthesizer 把蛋白质做出来。这个方法对于小一点的蛋白质可以，但对于大到 60 个 amino acids 左右的蛋白质就不行了，因为 coupling efficiency 不够，产量太低。所以非得用基因工程的方法。我们实验室?，从来还没有人用这种方法做成功过。</p>
<p>我因为设计的蛋白质有 56个amino acids，起初用Peptide Synthesizer 做产量太低，根本无法量产到够做后来的测试实验。而且这种方法非常贵。我只好想办法用基因工程的方法。</p>
<p>我们实验室有一个学生，以前是 UC Davis 生物系大学部的高才生，她不做蛋白质设计的软件，做别的题目。我和她研究这个基因工程要如何做法。她给我画出了实验步揍，我去买了实验原料，照着她画的步揍做。一开始总是做不成，前面的几个不揍还可以，但到了粘接的步揍总是不成。我再查了其它的书，和其它实验室的朋友请教，把每个实验步揍需要的时间，非常精准地写下来。然后带着一个定时器，只要定时器一响，就算是凌晨 3:00，我也照样从床上爬起来，从宿舍走到实验室进行下一个步揍。很多时后我干脆睡在实验室。这样过了几个星期，居然被我弄成了第一个蛋白质成品。这也是我们实验室第一次用基因工程的方法做出来 – 被一个理论物理出身从没作过生物实验的人做出来。从此 Steve和Bassil对我刮目相看，不但不阻止我做实验，还尽量鼓励我多做几个。</p>
<p>原来以前实验室没有半个人做出成果，是因为不按照时间来。可能凌晨 3:00 该起来做下一步时，他睡到上午 8:00。或者星期五晚上，该做下一步实验是，他去吃饭跳舞。只有我这个笨蛋，愿意随身戴一个定时器，照着自然的规矩来。等我熟能生巧后，我就可以安排做实验的时间，而不必再过那种非人的生活了。</p>
<p>这样的日子足足过了三年。那段时间，有两次爸爸、妈妈从台北到美国来看我，我竟然抽不出时间到旅舍去会他们，他们到学校?来，我也只能匆匆跟他们打个照面。他们心疼得不得了，尤其是我妈妈，我看到她的眼睛一离开我，就在掉眼泪。</p>
<p>很多人也问我，Alyce，你为何一个博士花了那么久才拿到。其实，如果我愿意选一些无足轻重的题目，随便弄个计算机模型跑一跑，也可以毕业。这种博士有很多的。但我选择了硬干，从一个理论物理学家，一个生物实验都不懂，到做出实验室第一个基因工程的实验，我向一个重要却困难的题目挑战，而得到了好的成果。现在很多人知道我是台湾最历史上最年轻的女博士，一来现在大家都去念 MBA 了，二来，如果那是我入加州理工的志愿，我还可以更早毕业。</p>
<p>现在，「蛋白质工程」在学术界已是很红、很热的题目，可是在我起步的那时候，我却是孤独的。</p>
<h2 id="蛋白质工程研究成果得奖"><a href="#蛋白质工程研究成果得奖" class="headerlink" title="蛋白质工程研究成果得奖"></a>蛋白质工程研究成果得奖</h2><p>1997 年初，我还没有完成博士学位论文，也就是尚未毕业，但我发表的蛋白质工程相关论文，已使美国的学术界注意到我这个人。麻州理工学院有个大大有名的教授卡尔-柏波(Carl Pabo)，是诺贝尔奖评审团的委员之一。我的博士论文指导教授Steve Mayo由于只是助理教授 Assistant Professor，要升正教授，其研究成果必须得到美国研究领域最上层的认可。卡尔-柏波就是这类权威人士的代表。于是Steve Mayo便请 Carl Pabo由东岸的麻州理工学院飞到西岸的加州理工学院来亲自审核我们实验室的研究成果。</p>
<p>Carl Pabo来时，时间排得很紧。既有安排他的专题演讲，每个加州理工学院的教授们，尤其是年轻的助理教授，都排队要见他。应届毕业的研究生们，想继续在科学界找工作的，都抢着要当他的招待。那时因为Carl Pabo是我的博士论文指导教授请来的，而我的研究成果，和Bassil Dahiyat 的都是我们实验室研究成果的代表，我有幸和一些应届的精英研究生和Carl Pabo一起用中饭。</p>
<p>我向他解释我的研究题目及结果，他认为我的题目选得很好，不但把古代和现代经典的研究方法连在一起，有实验结果证实这套方法的可行性，并兼具研究及商业的价值。</p>
<p>以他在科学界的地位，能被他注意到，是非常不容易的。经过他一品题，身价就不只暴增十倍了。由于柏波教授的推荐，我得了美国蛋白质学会的学术奖。这个奖颁给我这个二十出头的「黄毛丫头」，让学术界大感意外，因为这个奖在美国蛋白质学术界是很崇高的，许多人在争取，不够天分的科学家可以为它努力了一辈子还得不到。</p>
<h2 id="柏波提示我走从商之路"><a href="#柏波提示我走从商之路" class="headerlink" title="柏波提示我走从商之路"></a>柏波提示我走从商之路</h2><p>当天下午我的博士论文指导教授 Steve Mayo 赶紧把Carl Pabo拉到他的办公室，好好地讲解他的研究成果一番。那天下午我恰好身体不舒服，先回宿舍休息。傍晚忽然来了一个电话，是Steve Mayo打来的，问我晚上去哪里吃饭。我正纳闷，因为Steve Mayo向来不打电话到我宿舍的。结果电话那头忽然转手，Carl Pabo把电话抢了过去，并说“把中间人干掉 (Let’s eliminate the middle-man)”他问我晚上可否和他单独一起用餐。</p>
<p>这个机会是多少人求之不得的，我当然说好，虽然我身体不舒服。</p>
<p>遵照他的吩咐，我替他带来一些素食，到他下榻的Athenaem去。他坐在床上打坐，我坐在和床离一段距离的书桌旁边的椅子上，和他聊天。</p>
<p>我当时知道以自己的能力，不论想往何处发展，总是有志者事竟成，连理论物理都能转到实验生物科技。但我对是否留在科学界，有很大的疑问。我的个性喜欢和人打交道，作研究太孤独了。我那时已经开始看华尔街日报，也觉得华尔街日报的内容很有意思。但加州理工学院是一个非常与世隔绝的地方，连商学院都没有。我不晓得原来我的性向是喜欢从商的。</p>
<p>Pabo告诉我，他在科学界这么久，他觉得科学界和宗教最像。如果我决定在科学界发展，他以爱才之心，愿意全力帮我。但柏波又说：“科学界的天才已够多了，天才们想出来、做出来的东西，要放到市场?，做最好的推广，让许多人能够享用，这件事也要有天才去做”。</p>
<p>他这话让我觉得很有意思，只是我从小到大做的都是科学家梦，现在已到了实现的边缘，这时要换一个大方向，真有点不知从何说起的感觉。</p>
<p>柏波教授再说：“你考虑一下我的建议罢！我有一个学生叫Philip Ma，过去在我的实验室表现得很优秀，但大学在英国牛津念生意的，一天到晚看华尔街日报，后来被招进了麦肯锡公司，居然有更杰出的表现。如果你想走这条路，我可以介绍他跟你谈谈”。</p>
<p>过了几天，柏波的这个学生Philip Ma菲立甫-玛，果然打电话给我。跟菲立甫一谈，我才知道在科学之外，还有一个宽广而多彩的世界，商业是一个足可与科学抗衡的行业。我也才知道了麦肯锡公司是干什么的。这些东西引起我很大的兴趣。</p>
<h2 id="用蛋白质工程研究成果换取美国绿卡"><a href="#用蛋白质工程研究成果换取美国绿卡" class="headerlink" title="用蛋白质工程研究成果换取美国绿卡"></a>用蛋白质工程研究成果换取美国绿卡</h2><p>1997年中，我的博士论文大纲及相关数据都已准备齐全，要写的话可以很快写完，也开始想加州理工毕业之后该做什?。这时我发现没有美国绿卡是多麻烦的一件事。 不但很多奖学金，很多工作，都无法申请，而且也听说很多老板会故意拖延替你申请绿卡的程序或种类，如此他可以多用低薪留住你，使得许多移民都是廉价劳工。一个中国人，在美国只好照美国的规矩。那时我一心想在美国工作，绿卡非常关键。</p>
<p>那时美国也体认到高等智慧移民的有用，故开了一个新的移民种类，叫National Interest Waiver 国家利益豁免，是Alien of Exceptional Ability杰出人才的一种。 </p>
<p>我听说加州理工的华人博士生圈中已有几个案件通过了，以上述的方式得到绿卡。我便向他们请教。原来重点是研究成果和推荐信，这个我不缺。从美国国会议员，诺贝尔奖得主，大公司老板，名教授，都不吝大力推荐。我照着这些华人朋友的范本，把这些推荐信放入。幸运的也通过了，以此获得美国绿卡。</p>
<h2 id="蛋白质工程研究成果申请专利，向创投公司融资，开生物科技公司XENCOR"><a href="#蛋白质工程研究成果申请专利，向创投公司融资，开生物科技公司XENCOR" class="headerlink" title="蛋白质工程研究成果申请专利，向创投公司融资，开生物科技公司XENCOR"></a>蛋白质工程研究成果申请专利，向创投公司融资，开生物科技公司XENCOR</h2><p>1997年底，我的博士论文已全部完工。论文题目是：「Coupling Backbone Flexibility and Amino Acid Sequence Selection in Protein Design」，这已不是物理学的论题，完全偏向生物科技尤其是蛋白质工程方面，但是因为我进学校时是由物理系收我的，所以我仍被列为物理学博士。</p>
<p>Steve和Bassil作的成果也被发表在Science杂志。此时，他俩正积极的为他们的研究成果申请专利，找创投公司融资，开一家公司叫 XENCOR。这时我才发现，我辛苦了这?久，把我的青春放在实验室?这么多年，也为他们作出成果，原来一点股权也没我的份。Bassil说，为了保险起见，他希望为我申请专利，然后XENCOR 可以向我申请专利，付我专利金。这个意思就是希望买断我所做的蛋白质设计的研究成果，以免那一天我自己找到了风险投资家融资，和他们竞争。Steve 也从此不在公开科学发表场合介绍我的研究成果。我一个手无寸铁的博士研究生，能有什么还价的余地呢? </p>
<p>从那时开始，我义无反顾的踏进商业界。</p>
<p>XENCOR 目前是美国生物科技界一个被视为很有前途的事业，Bassil是CEO。很多台湾的风险投资家都知道 XENCOR 这个公司，也很想再去投钱。很多作生物科技创投的朋友，也会把手上的营运计划让我看，让我来帮忙评估，因为像我这样有踏实生物科技背景，再加上有日后 McKinsey 和 Goldman Sachs 的工作经验的，实在不多见。</p>
<h2 id="创办领导加州理工学院的Case-Practice-Group进军麦肯锡"><a href="#创办领导加州理工学院的Case-Practice-Group进军麦肯锡" class="headerlink" title="创办领导加州理工学院的Case Practice Group进军麦肯锡"></a>创办领导加州理工学院的Case Practice Group进军麦肯锡</h2><p>1997年9月到1998年6月的毕业典礼，是我一生很大的转折点。25岁之前，我从来不觉得钱很重重要，甚至对钱一点概念都没有。这一年，一来看到自己的博士论文指导教授在钱的面前，对自己的学生是一点也不保护。同时又开始接到爸妈从台湾的一些电话，问什么时候可以开始找工作，赚钱，买房子。真是废话。我那时只恨为什么没有人早告诉我这些东西，我的那些时间可以用来学如何赚钱的，都被浪费在实验室?。然后，一个加州理工博士又能卖到多少钱? </p>
<p>我以壮士断腕的心态，打定主意，非从商不可。</p>
<p>从商，对一个加州理工博士谈何容易? 所有美国顶尖的大学都有商学院，就是加州理工没有。我那时知道唯一有名的商业团体来做校园征才的就是 McKinsey 麦肯锡咨询公司。我想，加州理工可能有一群想从商的人，我一定要把这一群人找到，聚集在一起，互相学习，分享资源，在最快的时间内找到好的商业工作。</p>
<p>因为麦肯锡在面试时，很重要的一环，就是所谓的Case面试。这些Case是真实商业界里面大公司会遇到的问题。麦肯锡就是以这些 Case来淘汰那些没有商业感business sense的博士生。因为我那时一心想进麦肯锡，故把这个团体取名为Case Practice Group，顾名思义，就是让大家一起来收集，练习，以破解麦肯锡考博士生的Case。</p>
<p>我建了一个网站，解释了Case Practice Group的宗旨，活动方式，也放了一些收集到的考题，我这个创办人的电子邮件以供大家联系。然后做了很多海报，一点也不华丽，就是白纸黑字，把网站的内容及网址放上，然后自己一张张的贴在校园最显眼的地方。1997 年那时网站还在学校酝酿，没有掀起后来的网络疯狂 internet frenzy。我那时就发现加州理工这种地方，用网站和电邮是最方便有效的广告及联系方式。</p>
<p>我一提出这个建议，尚根本不是「登高一呼」，竟然有廿七个人写电邮给我来报名参加。加州理工很少有这样大的社团，特别是以研究商业为目的的社团，我这个物理学博士候选人，理所当然的成了这个社团的头。我举办了第一次的社团聚会。</p>
<p>这时有人在我们的社团活动中提出，现在好像有一种趋势，许多大银行、证券公司、咨询公司，常到学校中来招收学自然科学的人，似乎对数学程度好、反应快的人特别有兴趣。而过去，这类单位只在社会科学的范畴招人。</p>
<p>这个问题提出来后，引起整Group成员强烈关注。因为加州理工的毕业生以往的出路，几乎固定是科技界，而现在科技界似乎有人才饱和现象，不但求职难，而且入了行待遇也不高，比不上金融业，甚至只及四分之一到三分之一。</p>
<p>大家的共同认识是：我们既然是在美国这个大共同体?，无论在那一行服务，都是在促进美国的利益。而资本主义社会?一切价值都是以钱来衡量，包括知识都是如此，获得的待遇高，那意思就是获得社会比较高的肯定。有了这个共识，我们这个Group的成员，就不再把求职的范围限制在修习的本行了。</p>
<p>经过一番酝酿，Group的多数人，竟然把进麦肯锡咨询公司当成了第一志愿。我们觉得这个公司很特别，它本身并没有商业业务，甚至严格禁止它的成员介入工商活动，它只是为各行各业的单位提供咨询，也就是提供卓越的知识，来换取金钱。进入这个单位，我们过去所受的训练及修习得的知识，可以得到比进入本行更好的发挥。</p>
<p>于是，我们开始搜集麦肯锡公司过去招考新人时的考题，加以解析，大家一道研究出最合理的答案。不但如此，我们还想办法请了历届被麦肯锡录取的加州理工学长姐们，分享他们的经验。我设立了一个团体电邮，把这些会员的电邮放在一起，大家要互相联络，就把自己的问题或经验透过这个团体电邮分享。我则把每次搜集到的麦肯锡的考古题和解答提示放到了网上。我们并定期准备相互练习的机会，即大家聚在一起，两两一组，进行角色扮演，互相扮演面试者及应试者。</p>
<p>我可以看网站是谁在看，而知道谁有兴趣。一开始不过是会员在看，后来加州理工 Career Development Center 就业辅导中心也在看。后来这个社团名声大了，连麦肯锡的人都上来看了好几次。</p>
<p>我参加麦肯锡的口试，通过第一轮校园口试。第二轮在旧金山举行。第二轮有一个麦肯锡董事 Principal 问我。他第一句话就说「阿丽丝小姐，你确实很厉害，我们都知道你和你办的 Case Practice Group 但我们希望你回去后，能把麦肯锡公司招人可能考的问题从网上拿掉」。</p>
<p>那年麦肯锡没有录取我，但是，加州理工所有被取的学生，都是我的Group的成员。</p>
<h2 id="麦肯锡McKinsey-amp-Co。梦碎进军华尔街"><a href="#麦肯锡McKinsey-amp-Co。梦碎进军华尔街" class="headerlink" title="麦肯锡McKinsey &amp; Co。梦碎进军华尔街"></a>麦肯锡McKinsey &amp; Co。梦碎进军华尔街</h2><p>当麦肯锡没有录取我之后，我才开始注意到华尔街的校园征才。那时虽然听说高盛公司Goldman Sachs &amp; Co。是华尔街的老大，可惜已经错过高盛公司在加州理工进行的第一轮面试。虽然错过了高盛公司，但幸好还赶上了投资银行Salomon，和避险基金如Long Term Capital Management (LTCM)，和D. E. Shaw等，在加州理工进行的第一轮面试。 </p>
<p>那时康奈尔学“超弦论” (Super-String Theory) 的钟威已经弃物理转华尔街了，在 Morgan Stanley 替人家作金融工程及模型 (Financial Engineering and Modeling)。我打电话向他请教，他说，理工科的博士去华尔街要很小心，在面谈时要注意是面谈金融财务方面的工作 (financial engineering)，像他一样，或者只是提别人写计算机程序 (computer programmer)。 如果只是提人写计算机程序，你可能一辈子都翻不了身。 </p>
<p>Salomon是其分析能力最有名的 Yield Book部门在招人。Yield Book 是Salomon 对所有市场参与者提供的金融软件，上面有华尔街常用的所有金融模型，让使用者都能作产品定价及风险管理。 </p>
<p>Salomon在所有加州理工第一轮面试考了一大堆数学问题，只选了三个人非到San Francisco做第二轮面试。我一到San Francisco 才发现所有西岸有名的学校如Stanford，Berkeley第一轮通过的人，都在一起。这时候Salomon比较资深的长官都出现了，技术上的问题问得少，但重视你对Salomon的了解，和你是否有其它地方的面试。我那时为了Salomon的面试，特别买了一本“Liar’s Poker” 来看。同时我也被华尔街当时最有名的两家LTCM 和D. E. Shaw避险基金请去Greenwich 和New York 做第二轮的面试。 </p>
<p>华尔街是特别讲究市场效率的地方，他们特别喜欢互相抢。他们看上的通常是最好的，也以比谁抢到最好的货色为傲。Salomon 一听我和LTCM 和 D。E。Shaw 都会在东岸进行公司内面试，二话不说，也叫我去 New York 总部面试。我去了New York 之后，才知道我已击败Stanford，Berkeley 的博士们，是西岸的代表。 </p>
<p>Salomon 这份工作不是好拿的，因为这个工作不写计算机程序，而是为 Yield Book Group 作金融模型，尤其是 Term Structure 和 Prepayment Modeling。华尔街在交易方面对金融模型非常注重，因为如果你的模型错了，你就回用高价买进低价货，或用贱价出售高价货，让别人赚钱，你就要关门了。理工科的博士生如果想进华尔街翻身作金融，这是一个很好的跳板，怪不得挤破头。很幸运的，决定这份工作的人是亚洲人，也喜欢我，在所有人都势均力敌的情况下，把唯一的工作承诺给了我，年薪十四万美金。纯写计算机程序的工作，后来给了加州理工的另一个大学毕业生。 </p>
<p>有了Salomon的工作承诺之后，我还是必须与LTCM和D. E. Shaw这些避险基金作最后的面试。“Liar’s Poker” 这本书写的是 Salomon 以前的超级债?交易员 (这些人有个不太雅的统称，叫大老二 Big Swinging Dick)，这些书本上的人物，我竟然在 LTCM 都见到了。LTCM 的合伙人Greg Hawkins 是书中的一员，亲自来加州理工挑人，挑了我和其它两个人去Greenwich。LTCM 的办公室在 Greenwich，是东岸很多有钱人住的地方。但我在西岸天气好的地方住久了，看到不管是Greenwich 或 New York 都很不习惯和害怕。东岸很冷，Greenwich 的树都枯了，New York 人好多又都是摩天楼，让我这个从西岸来的乡吧老很害怕。D。E。Shaw是华尔街有名的 Quant Shop里面全是数学竞赛冠军。我和LTCM 和 D。E。Shaw这些避险基金都谈得很好，因为大家都一样会算数学。LTCM期望我能去日本。当时我因在加州有个很好的做独立电影导演的男友，故希望留在加州。 </p>
<p>1997 到1998 年，加州理工新出炉的博士的行情，一般是八万美金一年，十四万已真是高薪。当我从纽约回到巴沙底那，准备收拾行装去赴任的时候，在校园?碰到一个学长，他向我说，Newport Beach新港有一个叫Pimco的投资管理公司有一个美金廿万年薪的工作机会（Pimco 是Pacific Investment Management Company 太平洋投资管理公司的简称）。 </p>
<p>那个学长来头不小，叫Oleg，俄罗斯人，是加州理工应届独一无二的金融博士，以前代表俄罗斯参加全世界的数学奥林匹克竞试，得过第一名。他去Pimco应试后，Pimco惊为天人，给他美金廿万年薪。但他没有接受，因为他想留在学术界。加州理工内又很多像这样的怪才，天赋异秉，但对钱完全不稀罕。 </p>
<p>我想，他不去，那我去试试看。于是我向那个学长要了Pimco的地址和联络人，马上写信过去。 </p>
<p>我的信发出不过一两天，就接到了公司的回信，要我去面试。 </p>
<h2 id="一星期内搞懂“衍生性金融商品的圣经”进入PIMCO"><a href="#一星期内搞懂“衍生性金融商品的圣经”进入PIMCO" class="headerlink" title="一星期内搞懂“衍生性金融商品的圣经”进入PIMCO"></a>一星期内搞懂“衍生性金融商品的圣经”进入PIMCO</h2><p>新港离巴沙底那不远，开车也就是一个钟头左右。我开着一部1983年美金1500元的Chevy烂车，有点怕半路抛锚。车一开进新港，马上天空澄蓝，马路平坦宽阔，和风徐徐，恍如室外桃园。令我感觉最深的，是和巴沙底那及落山机比起来，忽然好车如龙，BMW，Mercedes，Porche，Jaquar 最多，Ferrari 也偶有。我那一个大Chevy烂车在中间真的格格不入。海边望去，还有许多游艇和帆船。旁边的 Fashion Island 有最贵，最新，最高档的限量欧美服装。 </p>
<p>新港是美国最有钱的人退休圣地之一，和东岸的 Greenwich 并提。怪不得很多退休金管理公司都在这?。在巴沙底那及落山机常见的墨西哥人，新港半个都看不出到。也几乎没有亚洲人，全部是白人。更不用说是非裔美人了。 和东岸华尔街严寒枯黄的景象比起来，新港的感觉真像天堂。我心想，若能在这?工作居住，该有多好。 </p>
<p>在PIMCO见到的第一人是一位金发年轻的帅哥，坐在一个大办公室，年纪么约三十出头，已经是Executive Vice President。他和我寒暄了一下，忽然话锋一转，问我一些数学问题。我回答的很好，他又问了一些金融问题。我对金融的问题其实不很懂，但是我告诉他我会用如何的思想架构去解决这样的问题时，他可以感到我有天分，但没有受过正规的金融训练，故从书架上拿了一本书，向我扬了扬，问我以前看过这本书吗？ </p>
<p>我接过那本书看了看，那本书就是Hull and White on Derivatives，我听过华尔街的钟威学长提过，但在加州理工书店内找不到的书。我老实告诉他，我听过，但从来没有真正见过这本书。 </p>
<p>那位先生说：「我发觉你确实很聪明，数学能力超强，现在我想测试一下你的理能力和吸收能力，你把这本书拿回去，好好念念，一个星期后来跟我们讨论」。说完，我知道这一场口试已结束了。 </p>
<p>那位金发年轻的帅哥是 PIMCO 的大红人，年纪轻轻就爬到很多人一辈子也爬不到的地位，几百万美金的年薪，我离开PIMCO 的那一年，他被封为 Partner 是PIMCO 有史以来最年轻的Partner。他本来在 Upenn 的 Wharton 从大学部直升博士班，是金融科的助教，也教 Executive Education 中的管理层们如何应用金融，Wharton 上上下下都认识他，故博士班才进了一年，就被华尔街挖走了。就是他和加州理工的Oleg学长惺惺相惜，给了Oleg 美金二十万年薪的工作承诺。Oleg 给我 PIMCO 的联络人就是他。 </p>
<p>当天还有两个面试，两个都是 PIMCO的Partner。一个以前在Salomon一个以前在Goldman Sachs。PIMCO 的最上层，很多是以Salomon的超级债权交易员，即 Liar’s Poker中所称的大老二 Big Swinging Dick。他们告诉我，PIMCO 是非常独特的地方，不召中间的管理层，但用比华尔街还高的价钱，华尔街最好的有多年经验的人才做最上层投资管理员 Portfolio Manager。每年新进的金融工程师最多只招一个。在华尔街每年新进的人很多，要和上层的人见面不易。PIMCO 的好处是新进的人少，如果你真的有本事，出头很容易。 </p>
<p>我拿了那本Pimco方面给我的书回到巴沙底那，好好把它翻了一下。所谓隔行如隔山，我对那?的内容几乎没法领会。但是，这件事是我自己找上去的，在这个「难」字面前，我怎么能退缩？时间还有一个礼拜，我就好好拼一下吧！ </p>
<p>中国古训有：「天下无难事，只怕有心人！」那本Hull写的大书，竟被我在一个星期中弄清楚了。我如期前往Pimco。 </p>
<p>Pimco 是一个非常有效率，注重实效的地方，我第二次到公司，二话不说，就被带入一个房间考试。考了一个上午 Hull 那本书的内容。题目是一个俄国人，Yuri，出的。Yuri 比我早进 PIMCO 几年的金融工程师，是 Chicago 物理博士转念 Chicago Business School 的金融MBA，他把以前Chicago Business School 的期末考题目拿来考我。 </p>
<p>我很冷静地定下心来，接受考试，结果，我考了将近满分。这个公司录用了我，年薪比照加州理工的Oleg学长。我不得已告诉 Salomon 那位对我很好的亚洲主管，我选择到 PIMCO。虽然说这句话不容易，尤其Salomon的那个工作承诺也是费尽心血拿下来的，我想，把Salomon 的机会给了另一个需要那份工作的人，也是好事。 </p>
<p>后来我才知道，Hull那本书，在ＭＢＡ课程中要念一年，而且得有教授讲解。我进了Pimco之后，Yuri 这个自负的老俄 Chicago Finance MBA 加物理博士 对我说：「你一个星期能读通那本书，程度还算不错」！ </p>
<p>1998 年最后一个学期，我到加州理工的金融系修了一个 Option Pricing，就是OLEG 的指导教授开的课程，用Hull这本书，我得了一个A+。 </p>
<h2 id="我在PIMCO受的训练"><a href="#我在PIMCO受的训练" class="headerlink" title="我在PIMCO受的训练"></a>我在PIMCO受的训练</h2><p>1998 我年从加州理工毕业之后进入PIMCO，搬到 Newport Beach 新港居住，正式脱离学校的生活，开始了我从商的第一步。PIMCO 给我很好的加入红利 Signing Bonus，我便拿这份钱买了一部金色的敞蓬车，也照着新港的衣着规距 (dress code) 置装。后来麦肯锡台北公司把我评为衣着最优雅 The Most Elegant Dresser，很多高盛的客人也夸我的打扮有高贵有气质，这都拜新港的文化熏陶所赐。 </p>
<p>PIMCO 是个很了不起的公司，因为他付的钱比华尔街还高。在华尔街这种完全金钱导向的文化下，PIMCO 是最了不起的公司之一当之无愧。PIMCO 招进来的人很少，最上层都是重金请来华尔街有多年经验最好的交易员 TRADER 做PIMCO 的 Portfolio Manager。这些华尔街最好的交易员之所以会从华尔街跳槽到PIMCO，没有钱是不可能的。我进来的那一年，他们从高盛招了一个在高盛有名的交易员，他和他在 New York 华尔街的朋友最常用来介绍PIMCO 的字眼，就是 “Upside better than Goldman Sachs 最上层比高盛付得多”。Allianz 把PIMCO买下来时，就以5年美金两亿 US$ 200 mm GURANTEED保证拿到的薪水签下PIMCO的大老板，Bill Gross。 </p>
<p>PIMCO把这些华尔街最贵的交易员买来后，全部放在交易室Trading Room?面。这个交易室是非常小的房间，是 PIMCO 最神圣的地方，所有的客户的资产超过美金两千亿 US$ 200 bn，就是在这个小交易室统一管理。我进PIMCO时，他们给我的头衔是 Financial Engineer 财务工程师，阶级在Portfolio Manager底下，做Portfolio Manager的助手。在我之前，Financial Engineer 是不给进交易室的。那位金发年轻的帅哥 Executive Vice President 对我特别好，把我招进PIMCO后，便安排我进交易室实习。 </p>
<p>PIMCO 的交易室早上4:30就有人在，还不算前一晚上留在交易室的，5:30 每个人一定到齐，6:00 进来就算晚了，每一天都如此。PIMCO有一个非常兢兢业业的投资文化，和军队差不多，重视纪录。害我每天天色还没亮就摸黑爬起来，开着金色敞蓬车从山上下来，一定敞蓬，让冷风把我吹醒。 </p>
<p>我进交易室是见习性质，还不能跟华尔街方面对话，但可以在看了银屏上的数据后，向上级提出意见。PIMCO 对我很好，让我从第二支电话听他们和华尔街的谈话来学习。因为PIMCO是华尔街的大户，一举一动若不小心会移动市场，故行动快速低调。华尔街的大行，对PIMCO非常尊敬和害怕，给PIMCO取名叫“沉没的鲨”（Quiet Sharks）。 </p>
<p>我在交易室待了一段时间，主要负责三个部分，CMO (Collateralized Mortgaged Obligations)，Treasury Derivatives，和International bonds。负责这些产品的 Portfolio Manager 如果想知道产品的实际价值，Financial Engineer 就要用现成或已有的模型算给他们看，让他们比较我们算的价钱和华尔街的价钱差多少，差在哪里，我们和华尔街的假设有什?不同。他们多年的经验给他们很好的直觉和自己的一套方法，他们向我们要的是一种 Bottom Up 由下往上的建议。 </p>
<p>因为PIMCO 是买方，华尔街是卖方，PIMCO 送我到华尔街去受训，一来是买方该尽量利用卖方的资源，二来是要多和华尔街打交道，知道并提升自己的程度，三来是最好把华尔街有名的模型学会，搬到PIMCO来。PIMCO这种公司，要赚他的钱还真不容易。在 Mortgage Backed Securities 方面，Bear Stearns 和 Salomon 两家特别强，所以我就常去。 </p>
<p>Bear Stearns 有一次办完培训后，大家晚上到一个酒吧去，那些Bear Stearns的交易员就开始打撞球，有些打桌球。我和另一个Bear Stearns的男交易员一组，对打对面的两个Bear Stearns的男交易员。交易员可爱的地方就是喜欢比赛，喜欢赢。对家两个男交易员看我不过是一介女子，还穿着套装和高跟鞋，根本不把我放在眼?。被我杀了几个球之后，才发现不对，马上全力以赴。结果我和我的搭挡以 2 比 0 把他们干掉。本来我不以为意，结果马上话就传到PIMCO，那位金发年轻的帅哥 Executive Vice President 在我回PIMCO上班时对我说，没想到你桌球打这?好。 </p>
<p>到Salomon 时，也拜访了当年给我工作承诺的 Yield Book Group，他们对我很好，我也很感谢他们。Salomon 那时有个叫 Y。K。Chan 的有名中国人做模型的。他写了个2-factor的term structure 模型，当年很红的，因为别家的模型都是1-factor，那时因为 Yield Curve 变动的很厉害，很多华尔街的公司因没有2-factor的模型，无法抓住Yield Curve 的变动，输了钱。PIMCO 就派我去看这2-factor的模型到底怎?搞法。Y。K。Chan 写了一篇有名的文章，说明这2-factor的模型是如何做出来的。我在PIMCO看了他的文章以后，打电报和Y。K。Chan讨论，也指出文章有一些看来有心的错别方程式，让读者很难重复他的结果。Y。K。Chan说我是第一个卖方看得懂他在写什?，还能了解他为什?这?做的人。到华尔街时和Y。K。Chan和他的团队讨论了很久，回到PIMCO就作出了一个小模型。第二次到华尔街要和Y。K。Chan讨论时，Y。K。Chan和他的团队就借故回避，派出一些不太懂的人应付我们。因为Y。K。Chan怕照我这种搞法，把他华尔街的赚钱模型全偷走了。 </p>
<p>那时知道PIMCO对亚洲市场的开发有兴趣。便请家母引见PIMCO的业务代表和台湾管党产及退休金的长官见面。那时很多台湾的大的资产管理机构都没有听过PIMCO，但在家母的引见下，那些长官马上对PIMCO留下了很深很好的印象。PIMCO 为了感谢我，特别让我和亚洲商务代表，和那位金发年轻的帅哥 Executive Vice President到北京，香港，新加坡，一起向这些区域最大的资产管理机构推销PIMCO的服务。 </p>
<p>PIMCO 的 Secular Forum 是每季都会举行的投资展望大会。每次大会都会请到全世界的投资权威讲结他们的看法。1999 年请到了香港的 Marc Faber。Marc Faber 提 Forbes 写专栏，对老外而言，是中国的专家。Marc Faber讲完的那天晚上，PIMCO 开了一个 cocktail reception，Faber对我很好，问我等一下要不要和他一起去晚饭。那天晚饭在附近的一个乡村俱乐部举行，同桌的还有PIMCO的一个合伙人。那个合伙人后来告诉我，他一起来晚餐是要来保护我，他怕Faber会对我动手动脚。这个合伙人对我很好，我们一起写了一篇文章，发表在 Investment and Pensions Europe，讲 Treasury Inflation Protected Securities。 </p>
<h2 id="赢得「债券王」Bill-Gross的心"><a href="#赢得「债券王」Bill-Gross的心" class="headerlink" title="赢得「债券王」Bill Gross的心"></a>赢得「债券王」Bill Gross的心</h2><p>Pimco的老板名叫比尔-格罗斯(BILL Gross)，他是美国金融界大大有名的「Bond King」─债券王，他白手起家，靠做债券而聚集了大量财富，我进他的公司时，他已有调拨两千亿美金的实力。他的「债券王」的绰号，有人说是「财富」杂志取的，有人说是在华尔街自然产生的，我比较相信后一种说法。比尔多年来在华尔街只做一样：债券，美国的同业都很敬畏他，公认他是有史以来最有本领的债券操盘手、投资人，他对债券市场的判断几乎没有失误过。 </p>
<p>比尔在公司?说一不二，真的像个「王」一样。比尔人很怪，他的全副精神集中在债券投资上，但他不相信科技，连ＰＣ怎么开都不晓得，他平常只跟几个大头交换意见，所有交易员都跟他说不上话，因而大家都不能直接知道他的意向。 </p>
<p>我来PIMCO 转眼快一年了，与比尔?格罗斯一句话都没说过，只有在交易室?见过他，听他每天对市场的评论及交易，和他与大头们的交谈，间接学习。要知道比尔-格罗斯在想什么，只能从比尔?格罗斯在PIMCO网站上对顾客发表的文章，间接猜测。另外，就是每几个月PIMCO内部开的长期投资策略大会，比尔?格罗斯和大头们都会对全球经济的展望，发表高见。PIMCO最厉害的地方就是预测得很?。 </p>
<p>1999 年5 月，PIMCO觉得利率将会 Range-Bound within a 200 basis point band (在一定的区间内变动，这个区间宽2%)而市场可能还没有把这个看法定价(market has not priced in yet)。在这种情况下，range floater 是一种好的投资工具来表示着个看法。比尔?格罗斯在他的文章?隐约这么说，但没说明白（不然别家就会作这个交易了）。 </p>
<p>我一看，就和我的老板，同事，讨论如何作出一个模型，能把比尔-格罗斯的想法定量化，并有参数让他可以调整他想法的强弱。我把Option Pricing的圣经 Black and Scholes 的模型改了一下，把平常利率的机率分布标?差缩小以符合比尔?格罗斯的想法，而标?差的宽度比尔?格罗斯可以自己决定。 </p>
<p>我很快就做出了那个模式，并透过正式管道给了比尔。我虽然对我的模式很有自信，但不知比尔会有怎样的反应，是不屑一顾还是欣赏。 </p>
<p>不料比尔很快就传下话来，他早就想做一批这样的模式，但找不到人商量，而我做出来的正是他构想中的一种。他竟要我就这个问题，对全公司交易员以上的人，做一次演讲。 </p>
<p>那时我只有廿几岁，而公司的交易员们都是四、五十岁的人，在他们面前讲任何问题，我都太嫩了点。可是，比尔的命令是不能违抗的，我只得以向大家说明我的模式的形式，来做这次演讲。 </p>
<p>没有想到这次演讲很成功，不但大家对我做出的模式兴致很多，比尔更当众称赞我做出的模式很棒，能解决问题。会后，他亲自打电话给我，要我把我做的模式，上到他个人的计算机?。这对比尔这个不相信科技，连ＰＣ怎么开都不晓得的「债券王」而言，意义非凡。 </p>
<p>2000 年底，公司全体开圣诞节舞会Christmas Party。总公司有几百人，相互之间大都不认识。PARTY开始后几分钟，比尔?格罗斯走进会场，他笑眯眯向我走过来，向全体同仁大叫一声：「Alyce，Everybody knows Alyce!」─「阿丽丝，大家都认识阿丽斯！」后来有一位在公司服务多年的同事跟我讲，他从来没见过比尔这样兴奋过。 </p>
<p>我在Pimco从1998 到 2000，表现不错，也得到好的奖金。但是，因为我在公司第一次露脸是由于做出了一个比尔欣赏的模式，因而公司高层便把我的责任范围定在做模式方面，我竟没有别的范围可以发挥。我渐渐有了倦怠感，觉得这份工作没有什么意思。正好那时知道了麦肯锡公司又在招人，我认为麦肯锡的工作应该比 PIMCO 有趣，于是我毅然向PIMCO提出辞呈，而参加了麦肯锡公司2000年的考试。 </p>
<p>　　　　　　　　　　　　　 </p>
<h2 id="我买卖房子一年-１６０-投资报酬率"><a href="#我买卖房子一年-１６０-投资报酬率" class="headerlink" title="我买卖房子一年 １６０% 投资报酬率"></a>我买卖房子一年 １６０% 投资报酬率</h2><p>我从拿到加州理工博士开始，就无时无刻想赶快买个房子，免得爸妈咯索。我在PIMCO工作的时候，由于待遇相当高，存了一些钱，便想在加州买房子。 </p>
<p>从那以后，我在公余就花了一些时间留意加州的房屋市场。将就我的年收入来考虑该买哪里的房子。新港的房子是有名的贵，倒是尔湾 Irvine的房子因为很多人喜欢退休之后在哪里住，有人要 (有 demand)，也不算太贵，有升值的空间，又有些华人区，华人生活方便，我觉得是个可以给爸妈退休后住的地方。到有了一个大概的轮廓之后，在我离开 PIMCO 之后，便邀请爸爸、妈妈加上妹妹，只差一个那时还在服预官役的弟弟，一道来尔湾 Irvine 看房子做决定。 </p>
<p>我们看中了一个四房两厅，前后有院子，附近有购物中心，及散步的树丛小径，离医院不远 (因为爸爸年纪一天比一天大，与医院打交道的机会也就增多)的房子。那户房子定价美金 29万，杀到28 万，头期款 20%要美金五万六。那时我还没那末多现金，大概只拿得出美金三万的存款。PIMCO 的一个合伙人，就是很赏识我，和我一起些过一篇 Treasury Inflation Protected Bond 的那一位，待我不薄，于我们全家人见过面后，慷慨解囊借我两万六凑足头期款。美金两万六对这种身价上亿 (光年薪就美金上千万的人) 真的不算什么。我告诉他以后一定还他。他是难得的好人，他说在美国已经很难看到子女为父母买房子的人，我们有这份心，他愿意帮忙。这位PIMCO 的合伙人，以前在高盛。 </p>
<p>那时我以离开了PIMCO，也因为下一个工作有了着落，知道不会在美国了，房子不但要买，还要租出去。幸好那个地点很好，房租比我付的房贷还高，所以整个交易是所谓的 Self-Financing 自给自足，我除了头款，其它不用再付钱。我有想过一年后可以看能不能变现，但不能变现亦无妨，因为市场还好，房价升值。 </p>
<p>回到台湾一年后，妹妹申请到 MBA要出国，弟弟也要去念 JD，因为平常赚的钱交给母亲还台湾的房贷，手上一点现金都不剩，只好赶快一年后就把尔湾 Irvine的房子卖了。出手的价钱近美金33万，赚了５万。头期款五万六还了PIMCO 的合伙人的两万六，手上净拿美金８万。一年内用３万赚８万，回报率百分之一百六十。 </p>
<p>原来所谓的 LBO，Leverage Buy-Out 就是这样干的。 </p>
<p>８万赶紧先分给了弟弟妹妹。税的事情我再去负责。 </p>
<p>弟弟很争气，他在服完兵役之后，一面准备律师考试，一面申请到美国深造的学校，因为他在台大法律系的成绩很好，各种课外纪录也不弱，哥伦比亚大学都给了他入学许可。律师考试也是全台湾第十七名。 </p>
<p>妹妹念完 MBA 后，也有幸进入台湾最好的创投公司中华开发。 </p>
<h2 id="考入麦肯锡-McKinsey-amp-Co。"><a href="#考入麦肯锡-McKinsey-amp-Co。" class="headerlink" title="考入麦肯锡 McKinsey &amp; Co。"></a>考入麦肯锡 McKinsey &amp; Co。</h2><p>我在前面说过，在进Pimco之前，我考过麦肯锡公司，没有录取。但是我对这个公司怀有高度兴趣。另一方面，要想在美国商业界发展，最好有个ＭＢＡ（企业管理硕士）学位，我没有这个学位，要想念一个，要花两年时间，还要交一大笔学费。而美国企业界有个默契，只要在麦肯锡工作过一年，便视同ＭＢＡ资格，这就不但使我因兴趣而想进麦肯锡，实在还有必要进。<br>这样，我就报名参加麦肯锡的一九九九年底的人才甄试，那年我赶上麦肯锡在全美国招收给大中华两岸三地的人才。经过第一轮在加州理工进行。第二轮在落山机进行。我因以前就准备过麦肯锡的甄试，再加上PIMCO所受的训练，对麦肯锡的口试应付自如，也轻易的进了最后一关。最后一关全美一共只收了 40 个人，送去上海，进行为期五天的培训及最后一轮的甄试。麦肯锡给我们这一群人的绰号叫Insight 2000。 </p>
<p>2000 年初到上海，我马上被这个城市给慑住了。我从 1992年离开台湾，之中只有回去台湾两三趟，中国我倒是一次也没回去过。1992 年到 2000 年的牛市 Bull Market 中，两岸三地发生了多少大事，造就了多少人物，而我却一件事也没赶上，一个人也没遇上。2000 年的上海与我印象中的中国是多么的不一样! </p>
<p>前三天是培训，麦肯锡的顾问们先告诉我们他们的背景，做过的案例 (当然案例都不具名)。然后把我们分组，给我们案例，让我们分组讨论，并上台报告。然后角色扮演，我们扮演麦肯锡的顾问，麦肯锡的顾问们扮演公司的CEO，CFO，VP of Marketing 等，让我们感受实际和公司管理层打交道的压力，并对我们的表现给予讲评。麦肯锡也教我们一些最基本的生意架构 (business framework)。晚上麦肯锡为我们安排到上海有名的饭馆体验当地的生活。这三天的假设是，我们这一批，都是中国在美国受过高等教育的一批，都没有MBA，这三天，就是快速的将一些 MBA 的观念，做麦肯锡顾问最基本的工夫，交给我们，然后要看我们学得如何。 </p>
<p>后两天是非常严格的面试，面试都是案例 Case 看我们前三天学得如何，并看每个人的生意感觉 Business Sense。从这 40 个人中，麦肯锡挑了 10 个人，分别进入北京，上海，香港，及台北，4个办公室。我也顺利进入台北办公室，正式成了麦肯锡公司的一员，圆了我加州理工时代的一个梦。 </p>
<p>我当时知道，我一定要在麦肯锡待上一年，获得训练和实际经验，以换取和 Harvard MBA 同等的对待。有了麦肯锡在我的履历表，别人就不敢老是看我是博士，问我为什?不去做研究员或工程师，因为麦肯锡就是全球最有名的”管理”顾问，专门为 Fortune 500 的CEO 提供战略服务的。 </p>
<h2 id="我在麦肯锡受的训练"><a href="#我在麦肯锡受的训练" class="headerlink" title="我在麦肯锡受的训练"></a>我在麦肯锡受的训练</h2><p>对于像我这样的不是学财经出身，但被证明有 智慧且具博士学位的人，在被麦肯锡招进之后，公司会郑重其事对我们做MINI MBA训练，受训的地点有时候在美国内，有时候在美国外。我受过一次在西班牙的小型MBA训练，还有一次在美国匹兹堡的BASIC CONSULTING READINESS基本咨询准备。两次都是三星期。 </p>
<p>如这本有名的 The McKinsey Way 所言，麦肯锡是个很讲究团队精神的公司，为了使同仁们工作上能充分相互配合，公司?面提倡：无论你个人如何优秀杰出，但你必须能与工作伙伴合作，不能只求一个人表现。大家既然来自不同国度，各有不同的文化背景，而且都是在平辈中顶尖的人物，要形成一个圆融的工作团体真的不简单。我现在回想起来，我所受的两次训练。确实发生了很好的作用，而且决不仅是对我个人如此。 </p>
<p>我们在西班牙受训，第一个星期是讲「微观经济」，告诉我们单一企业的特质， 企业的运作要领；第二个星期讲「公司融资」，第三个星期讲「公司策略」，所有的讲员都是全球各名校的最好的MBA教授，从星期一到星期五，我们这些不同国籍、不同肤色的学员，过的可以说是海军陆战队的新兵般的地狱生活，听讲、讨论、做习题、交报告，没有一分一秒浪费，那时间的安排，比我在加州理工修博士时还要紧凑。巧妙的是那最后的报告，一定要用集体的智慧才能完成，参加撰写报告的人，都会感觉到并且承认，那?面蕴含着一些自己提不出的、确实比自己高明的意见。我想，这是训练充实我们的知识之外，另一个具启发性的目的。 </p>
<p>在受训的时候，麦肯锡公司允许并且鼓励我们学员在周末心情放松，一道游玩。这样使我们在成为深有默契的工作伙伴之外，也成为很好的朋友。在西班牙的三个星期训练，给了我终身难忘的回味。 </p>
<p>在匹兹堡的三个星期训练，题目叫做BCR，即「BASIC CONSULTING READINESS」，基本咨询准备。这是麦肯锡公司的本业训练，先由公司仿真一些客户状况，由一组学员把这些问题承接下来，然后由一个人做头，把问题分割成几「块」，每个人负责解决一「块」的问题，各人先就自己负责的一「块」去搜集资料及思考，然后用集体智慧将这些「块」整合起来，再成为整体，提出解决的策略及方案。在训练中每个成员都有做「头」的机会，没有畸轻畸重的情况。这是一种比在西班牙所受训练更深一层的团队工作训练，进一步教给学员对伙伴智慧的重视。另外的重点是学画图，即所谓的 CHARTS 图表，因为顾问和客户的沟通工具是用特别的CHARTS，要如何用言简意亥的方式画出你要传达的意思。 </p>
<p>麦肯锡的训练是按照个人在公司中的职业成长设计的，譬如，一个刚进来的顾问，可能需要小型MBA训练或 基本咨询准备。等这个顾问做了三个案例或进来一年以后，要接受别的训练，升到 Engagement Manager 或 Principal 或Director 后也有配合不同的训练，真是活到老学到老。有个很有名的训练每个参加过的顾问都喜欢谈，就是将每个人做性向测验，把人的个性分成 16 类，然后每个人在身上挂名牌，写上自己的类别。你在与别人交谈时，要针对对方的个性类别说话。如此重复几天。俗语说，见人说人话，可能是同样的道理。 </p>
<p>我最怀念麦肯锡的是每三个月举办的 GCO Square，GCO 是 Greater China Offices 的简称，包含北京，上海，香港，台湾。GCO Square 都选在上海办。全部4个办公室的顾问都聚集在上海，受训，联谊，分享为顾客解决案例的成果，大家讨论，看下次如何可以做得更好。 </p>
<p>最难忘的是2000年底在海南三亚的天域酒店， 麦肯锡举办的GCO Retreat，全部大中华4个办公室的顾问聚在美丽的三亚，开会，联谊，受训，讨论麦肯锡未来的发展方向几长官们对新顾问们的期许，然后对所有新的顾问排名，决定顾问一年的红利。 </p>
<h2 id="在麦肯锡McKinsey-amp-Co。的日子"><a href="#在麦肯锡McKinsey-amp-Co。的日子" class="headerlink" title="在麦肯锡McKinsey &amp; Co。的日子"></a>在麦肯锡McKinsey &amp; Co。的日子</h2><p>如 The McKinsey Way 所言，麦肯锡内部的顾问分成几个等级，人数分布为金字塔型，由长而幼为依序为: Director，Principal，Engagement Manager，Associate，Analyst。每一个等级间大约是两年。但由于是采用所谓的 “Up or Out (上或淘汰)” 系统，很多人两年一到升不上去，就得走路。因为这个缘故，对所有同一年的顾问，上面的人都会做 forced ranking 强迫排名。新进来的顾问，罩子要放亮一点，赶快看上面有那些年资较深的顾问愿意带你，把你认作他的人，因为麦肯锡仍是所谓的 Partner 制，所有向上的晋升一定要有人从上面给你投票。麦肯锡?面本来 Harvard MBA 就最多，在这种体系下，毕业学校就成了一个自然组织集团的方式。我进麦肯锡是 Associate，新的Harvard MBA 近来也叫Associate。 </p>
<p>麦肯锡是以顾客故而“案子” (engagement) 导向。“Director” 从顾客手中接过案子时的，公司就针对顾客的要求设计“案子”的长短，然后从麦肯锡的顾问群中挑选最适合这个案子的 “Principal”，“Engagement Manager”，“Associate”，“Analyst” 的组合。这个过程叫“staffing案子征才”。对一个案子，整个大中华区是统一的案子征才，最上面的Principal也可能从其它亚洲办公室，或者全球的其它办公室找人。这是麦肯锡独特的地方，永远找公司?最好的人才，组成最好的团队，为顾客服务。在这种制度下，新进人员像我，不但有机会从团队中年资深的顾问学习，更有机会互相认识其它大中华办公室的新近人员。麦肯锡对外注重为顾客服务，对内注重学习。 </p>
<p>2000 年初到 2001 年初，在麦肯锡做事一年，我接过三个案例。第一个案例在香港，第二个案例还在香港，第三个案例在台湾。我在香港最好的酒店之一 Grand Hyatt 东方君悦酒店住了半年以上，住到酒店服务人员和旁边的JJ俱乐部收票员都认识我，并直到现在还会对我打招呼。 </p>
<p>第一个案子是为香港第二大集团作公司融资与战略顾问。首先，对中国一出版公司价格作评估，评估方法包含现金流量折现法，市场乘数法，用不同的折现率及收益乘数来划出估值的范围。其次，为此集团的网络投资分部准备与另一个香港大集团销售部门的合作协商档。最后，替集团在新加坡，马来西亚，台湾寻找并购对象。 </p>
<p>第二个案子是为全球最大农化公司的亚太地区高层主管提供并购后重组服务。对亚太地区共13个国家的业务进行分析，然后估计两个公司间的生意互利及重迭。对互利实行及重迭消除方面作出了执行计划及里程碑。此计划为亚太地区最高指导委员会同意并执行。麦肯锡的3人小组在5个月间整合了3000个员工。 </p>
<p>第三个案子是为台湾最大的金融集团等设计并购策略及并购后资源的整合方案。2000 底，台湾金融界因法律改变允许 Financial Holdings Company 的成立，一连串的改变正在酝酿。我们看中这一批改革风潮会带来台湾金融界的震撼，与各集团积极展开讨论合作的可能性。 </p>
<p>我们打交道的对象是各行各业大企业的CEO - Chief Executive Officer翻成中文是「执行长」，也就是他那企业掌握最后决定权的人。这些人在他那行业多有许多年的经历，自然那方面都内行，我们这些麦肯锡的顾问，要他们出高价聘请提供咨询，当然大大不简单。他们一定是遭逢到了棘手的问题，才来找我们，而我们这些人也许对他那一行了解并不深刻，但是一经他们礼聘，短期内就要拿得出能解决问题、令他们折服的方案，这种事的难度可想而知。<br>麦肯锡的顾问，理论上应是「万事通」，随便什么问题，一谈就要能进入状况。这要求有高度的领悟力和学习能力。ＣＥＯ们都忙，没有时间听空话，所以跟他们谈话，一定要很快领会他们的意图，明白困扰他们的问题何在。把他们的意图摸清楚了，找出「当局者迷」迷在何处，才能对症下药求解。 </p>
<p>除了这份聪明，还得十分认真、努力，吃得了苦。因为解决问题的方案要很快做出来，这要查阅非常多的相关数据，并做合理消化。因此，接案之后，顾问的工作几乎是不分日夜，一天十六、十八小时都有可能，每分每秒都是挑战。 </p>
<p>这份工作，对极了我的味口，我的性格就是喜欢捕捉新的、一般人看起来艰涩无解的问题，找出别人找不出或不易找出的答案，挑战越多、越尖锐，我不但不以为苦，反而觉得是一种享受。 </p>
<h2 id="进入高盛公司-Goldman-Sachs-amp-Co。"><a href="#进入高盛公司-Goldman-Sachs-amp-Co。" class="headerlink" title="进入高盛公司 Goldman Sachs &amp; Co。"></a>进入高盛公司 Goldman Sachs &amp; Co。</h2><p>我向麦肯锡公司递出辞呈的时候，许多人都觉得不可思议，因为进入这家公司是那样困难，而我进入公司之后又表现得非常好，留在公司几乎确定有光明的未来。因此有人劝我慎重考虑，不要急于离开。 </p>
<p>对于这些好心人的意见，我没有采纳。因为我最初放弃学术岗位而选择金融行业，就是想在「银海」中求得发展，在赚得足够的钱之后，再凭我的所学，不管是在生物科技方面创业，闯出一片天地，或是找好的投资伙伴们，一起入股收购物美价廉的公司。在麦肯锡公司任职只能出卖智慧，赚钱是有限的，而且我在这公司工作已超过一年，在熟悉美国企业界行情的人眼中，我已具有像 HARVARDＭＢＡ的资格了。 </p>
<p>离开麦肯锡，我向美国最大而著名的投资银行Goldman Sachs &amp; Co，中文译名「高盛公司」求职。进这公司的难度，不下于进麦肯锡。我之所以选择投向高盛，是想弄清楚投资银行是怎样聚合资金，而后又是怎样运用资金的。高盛公司是这方面国际性的佼佼者，一旦投身进去，应可学得一些这方面的学问。 </p>
<p>在很多坊间的书局中，可以见到一本书，叫做?Goldman Sachs，the Culture of Success (高盛，成功的文化)”。如此书所言，要进高盛公司，每个人最少要10个以上的面试，20 几个面试，是常事。因为高盛公司，如此书所言，重视团队工作。一定要大多数人觉得可以与你共事，才有进公司的可能。 </p>
<p>我在高盛台北及香港的公司，都被面试。来来往往也见了十几二十个人。其中让我印象最深的，是台湾投资银行界的教父，宋学仁先生。宋先生话不多，但一针见血，又愿意和你讲最好，最诚实，最中肯的建议。怪不得是所有大企业家最倚重的 Advisor咨询者。没进高盛前，就听说宋先生进高盛，是带兵投靠，把所有大华证?的客户，化为高盛所有。高盛在台湾，从零开始，到台湾成为高盛全球重视的收入来源重镇之一，宋先生扮演了很重要的角色。宋先生不但自己贵为高盛亚洲的副主席，更重要的是，他培育了一批台湾人，都为高盛立下了汗马功劳，而位居高位。我一辈子觉得最可惜的是没赶上那一波追随宋先生的机会，不然我也不会提早离开高盛。 </p>
<p>我面试的结果，Investment Banking投资银行部 和Investment Management投资管理部，两个部门都表示要录用我。后来有人告诉我，这样的情形是不多见的。我选择了投资管理部，因为 2001 年的资本市场不太好，一般的理解下，投资银行部在市场不好时裁员最快最多，而且是后进先出。我当时希望在高盛待十年以上，故选择了投资管理部门。 </p>
<h2 id="我在高盛受的训练"><a href="#我在高盛受的训练" class="headerlink" title="我在高盛受的训练"></a>我在高盛受的训练</h2><p>从麦肯锡转到高盛，几乎是变换了一个世界。我在前面介绍过，麦肯锡公司只给别人出主意，本身不用资本市场的工具为客户融资，这是个原则，所有的工作人员都不能违反。高盛除了可以提供麦肯锡的战略服务之外，还可以用资本市场的工具为客户融资，或从事资本市场的交易。 </p>
<p>就是因为特质有异，所以这两个公司对职业的训练也有很大的不同。高盛在每年的夏天，将当年从全世界招来的新生送到纽约，集中训练。这时通常会包下一家大旅馆，做训练场地，那气派的豪华，令新进人员感到震慑，觉得自己投身的果然是一家不同凡响的大企业。 </p>
<p>高盛训练的第一课，是把整个企业摊开给新进人员看，告诉你高盛有哪些部门，如投资银行、贸易部、资产管理部等，向大家介绍这些部门如何操作。这时的讲员多是高盛的资深高级主管，他们不但熟知高盛的各项业务，而且都对高盛银行有感情、有贡献。透过他们的讲述，新进人员不但了解了这家投资银行本身，对于全球的投资银行业，也会有一个深刻的印象。 </p>
<p>高盛为期数月的新人训练，主要目的之一是给那一年的全球新进人员有一个相互认识的机会，并对自己部门的人员，规矩，专业知识，有所了解，还要测试。在纽约那个夏天，我有幸认识那年全球进高盛的新生，亚洲，美洲，欧洲，有幸和几位德国的新生做了好朋友。晚上上完课后，及周末，我们都一起到纽约去玩，纽约真是个非常美丽又好玩的地方。 </p>
<p>我的部门特别给我们做电话对谈训练，是很有意思也很实用的一个训练项目。不但像我这种学自然科学出身的，即使是名校的MBA，也未必受过电话对谈专门训练，不一定知道那?面有那样大的学问。因为高盛每一个分支机构的业务辖区都很大，做行销的时候，如果都由人上门去洽谈，那成本势必很高，这样就有必要通过电话来接触客户，高盛可以把它的行员训练到只要客户一开口，就知道他的问题在哪里。心中要马上形成为客户解决他所悬问题的腹案，那笔生意八九不离十就能做成。高盛不是教行员骗人，而是提高行员捕捉问题、消弭问题、解决问题的能力。我在接受了这方面的训练之后，经历了好几个相当大的案子，是用电话谈成的交易。 </p>
<h2 id="在高盛公司-Goldman-Sachs-amp-Co。的日子"><a href="#在高盛公司-Goldman-Sachs-amp-Co。的日子" class="headerlink" title="在高盛公司 Goldman Sachs &amp; Co。的日子"></a>在高盛公司 Goldman Sachs &amp; Co。的日子</h2><p>我在高盛公司的工作地点，被安排在香港长江集团中心六十八楼，即公司的亚洲总部，被委负大中华地区─大陆、台湾、香港、澳门─吸收资金的责任。对我来说，这真是个极大的挑战。我在这个地区的人脉并不广，主要是在麦肯锡公司工作时建立的一些关系，现在既然承担了高盛公司赋予的这份责任，只有尽一切力量来建立人际网络。 </p>
<p>2001 年到2003年我是高盛资产管理部大中华区业务负责人。虽然我上面的外国老板来来去去两年内换了三个，因为整个部门只有我一个中国人，所有大中华区有关的事务都是我实际在做。我为大中华区美金现金管理业务开发首席代表，负责美金近十亿。 </p>
<p>我与大中华区重要Chairman，CEO及CFO们谈投资和公司买卖交易的机会。带领高盛投资银行部门美国，欧洲的产业专家，与大中华区公司领导们讨论全球经济局势展望，产业趋势，及竞争者分析。 </p>
<p>我负责大中华区投资者关系管理及新生意发展。与投资者沟通以理解其投资需要，根据其投资需要，量身订做资产配置，并找寻最好的固定收益，股票，避险基金，及其它种投资产品，来满足投资着需求。 </p>
<p>和同仁一起，我们调查并设计中外合资公司资产管理合作的可行性和合作模型。我们也设计，组织，并召开两届为期一星期的亚洲机构投资者培训课程，培训与资产管理相关的重点项目。 </p>
<p>在当代经理人杂志社办的中国成长企业一百强CEO峰会中，我应邀为主讲者及专题主持人。 讲题为中国企业如何引进国外战略投资者，及比较各国资本市场的融资渠道。 </p>
<p>我打交道的对象，是一等一的富人，或者是有钱在库而又想生出利润的机关。高盛公司有一套严谨的制度，它的工作人员必须按照这套制度工作。我们代表公司与人接触，只要做出了承诺，就要百分之百做到，绝不能打折扣，总之一切要顾全公司的信用。这对于我这个学科学出身的人并不难，因为我长期所受的训练就是求「真」，无论说话、做事，都以「不假」为原则，因而我打从进入高盛公司起，就没有违规过。 </p>
<p>由于管理的范围太大，我在外旅行的时间很多，有时一个星期要坐好几次飞机。我惯于独来独往，常常是一个手提箱就出远门。每次到台北，我习惯住到爸妈家?而不住旅馆，妈妈看我来也匆匆、去也匆匆的样子，心疼得不得了，总得我安慰她，她才能回过神来。其实，我东飞西跑，并不觉得如何疲累，反而是看到爱女心切的妈妈那难受的样子，我才心疼。 </p>
<p>由于在高盛公司工作，我认识了很多富豪。我发觉这类人几乎都有很精准的投资眼光。我能有这样的机会，和大中华区最优秀的企业家交流，不但觉得他们的这套本事，很值得我学习，真是三生有幸。 </p>
<h2 id="我与「甲骨文」老板的一段交往-初遇北京"><a href="#我与「甲骨文」老板的一段交往-初遇北京" class="headerlink" title="我与「甲骨文」老板的一段交往: 初遇北京"></a>我与「甲骨文」老板的一段交往: 初遇北京</h2><p>世界的软件业者，没有不知道「ORACLE」（甲骨文）公司。这家公司的老板叫LARRY˙ELLISON拉瑞-爱理逊，一度是被富比士杂志排名全球第一、超过「微软公司」老板比尔-盖兹的富人，后来有几年排名第二，二○○二年则排名第九。这位先生很有意思，他是以特立独行、傲视全球闻名的人物，但却对我非常欣赏，在百忙之中亲自给我发过很多电子邮件，并在与我晤面时给我很多的褒奖。 </p>
<p>甲骨文公司对于出身加州理工学院的人绝不陌生，多年来这个公司在加州理工招聘科技界的新人，出价都很高，被它挑中的加州理工大学毕业生，年薪达六万五千美元，博士则给八万美元，因此许多加州理工大学部最优秀的毕业生都参加了这个公司。只是这家公司的老板很特别，他很少直接接触公司的新进人员，一般职员只能在报刊上看到他放言高论，及他与比尔-盖兹之间的竞争，很少人见过他，跟他面谈过的人更少。 </p>
<p>我是在加州理工相邻的书店中，看到一本名叫 <a href="爱理逊与神的区别—甲骨文公司内部的观察">The Difference Between God and Larry Ellison</a>」的书，买来看了之后，才知道爱理逊其人的。那书把爱理逊写的十分有趣。看完书之后，我以 “日本来的 Alternative Shuksa” 的名字在亚马逊网上书店 (www。amazon。com) 发表读后感。日本是Ellison最喜欢的国家之一，因为Oracle全球卖得第二多的国家就是日本。Alternative Shuksa和Alyce Su的开头都是一样。Shuksa是犹太语“女朋友”的意思。以后约莫有两年时间，我不管在什么报刊上看到有关爱理逊的言论，或者对他的报导，总会一口气看完。我既读过那么多来源不同的有关爱理逊的资料，有时在跟朋友闲聊时谈到他，朋友们都很惊异我怎么知道这么多有关爱理逊的细微之处，于是有人称我为「爱理逊专家」。 </p>
<p>2002年三月某日，我忽然在报上看见，爱理逊六月份要到北京一行。我一算那时间，那时我也会在北京。我想，既然这样，我何不设法与他见上一面，看看我的偶像的卢山真面目。Oracle 成立这么多年来Larry Ellison 上次亲临北京已绖是快十年前了。 </p>
<p>六月初，我试着给爱理逊发了一封电子信，问他能否在六月十日，在北京与我一晤。我当然知道自己的份量，在他这种国际大财阀面前，我算老几？因此，在信发出之后，我并不真的期待他会有回音。 </p>
<p>可是，出乎我所料，他竟很快覆信给我：「I would love to meet you，you are most interesting。」（我很高兴与你会晤，你太有意思了！） </p>
<p>Larry Ellison，Mike Milken [Junk Bond King 垃圾债券王]，Rupert Murdoch [媒体大王梅铎] 三人合作一个公司叫 Knowledge Universe [ 知识宇宙 ]。以前我在 Los Angeles 时，在我离开 PIMCO 去 McKinsey &amp; Co。之前，曾向Mike Milken递过我的简历，结果这份简历落在 Steve Fink，与Mike Milken 私交甚深的好友桌上。自从 Mike Milken被判终身不得从事证?交易之后，所有与商业有?的活动均由 Steve Fink 负责。Steve Fink也是 Forbes 杂志专访过的对象， 其兄弟 Larry Fink 为华尔街著名公司 Blackrock 的创办人及总裁。 Larry Fink 和 PIMCO 的创办人像 Bill Gross 或 Chris Dialynas 十几年前在华尔街交手时就互相认识。华尔街是个小圈子，这些身价上美金亿的大老们都互相认识，再见过我之后，多谢他们都记得有 Alyce Su 这一号女博士。我一直不确定为何像 Larry Ellison 这?德高望重的巨富，竟然会亲自回我的电子邮件。我猜想，但没有证据肯定，可能是这些华尔街巨头的推荐。 </p>
<p>爱理逊的回信当然令我兴奋。但是，我考虑到，我并没有跟他确定谈话的主题，及参与谈话的人，这些事不落实，他随时可能取消这一约会。于是我立刻联系平常在大中华地区接触密切的各方要人，问他们有不有兴趣跟爱理逊谈谈。这一切都是以私人事务的方式进行，和高盛的业务无关。 </p>
<p>这个讯息发出之后，通过电话和电子邮件回来的讯息大量涌至， 政府官员，财经，高科技豪杰，及北京最成功的民营企业家们，莫不想与这位巨头一谈。我过滤了他们的各种要求，整理成两大主题，然后把它发给了爱理逊。 </p>
<p>很快，爱理逊的回信来了，他完全同意我所建议的谈话内容，但他表示，六月十日他尚未到达北京，与我们会面，以六月十二或十三日为宜。 </p>
<p>爱理逊一向以善变著名，这分钟答应的事，下分钟可能就变挂，更何况是六月十二日“或”十三日，这到底是几日呢? 如果这些大中华区的名流真的冲 Larry Ellison 的面子而来，而被放鸽子，那我以后怎么混呢? </p>
<p>我想到，如果爱理逊真是想跟我会面，他一定会还有电子邮件发给我，我可以稍等一下。结果，在几天之内，爱理逊发来很多封电邮，确定要与我在北京见面。他在电邮中，并与我交换了私人电号号码。他也把日期确定在六月十二日。但是最确定的只到日期了，至于时间地点，完全不知。 </p>
<p>六月十日我到北京，机场到处是 Oracle 的旗子，气派的确不凡。 </p>
<p>六月十一日晚上，我还是不晓得 Larry Ellison 到底会不会和我见面，我也没敢再麻烦大中华的名流。 </p>
<p>六月十二日早上九点多钟，我忽然接到爱理逊的私人秘书从他的美国总部打来一个电话，告诉我 Larry希望今天下午6:00 pm 和我及我的朋友们吃饭。她说，Larry wants it to happen，马上 Larry 就要在北京的Oracle 大会发表他的 Keynote Speech。Larry 演讲过后，Larry 的北京私人秘书 Judy 就会打电话再和我联络。 </p>
<p>从这个电话算起，Larry 总算确定了。但是从上午九点多钟到下午6:00已经没多久了。我马上给我的合作伙伴们打电话，请他们待命。我也亲自打了几通电话给重要的人，请问他们6:00 是否有空。 </p>
<p>近中午，Larry 的北京私人秘书 Judy 打给我，说 Larry 要把晚饭由下午6:00改到 4:00。这个变动太突然，令我暗暗叫苦。因为我所约的人无不各有要公，要调整两个小时的业务不是容易的事。但是我想到，爱理逊若不是有绝对必要，他不会提这个要求。我只得先承诺下来，然后再来考验我自己的协调能力。 </p>
<p>我开始一个一个跟预定参加会见爱理逊的朋友打电话，告诉他们这个变动，并希望他们能重新安排时间，不要放弃这个与美国软件大王?谈的机会。大家或许是感于我的诚恳，竟都答认重新安排行程，来共襄这欢迎美国大财阀的盛举。 </p>
<p>当天下午三点五十分，我所约请的与爱理逊欢谈的客人，一个不少出现在北京东方君悦酒店。我先将客人们带到会见的会议厅，然后爱理逊的秘书打了一个电话给爱理逊。不一会儿，Larry 从一个隐密的地方走出来。 </p>
<p>我是第一次见到这个我在报刊上细读了两年多的产业界的大人物，觉得他真是很「酷」，气宇果然不凡。对我而言，他好似从书籍、杂志中走出来。 </p>
<p>那天的聚会真是很热烈，一开始人数算少了，位子不够，还要叫餐厅加椅子，加到后来那个桌子加不下那末多椅子，只好请一位晚到的朋友先出去等，我告诉他若有位置，马上通知。 </p>
<p>晚饭是 4:00 开始的，5:30，有位中国最大电信公司的COO 要先走，我便走出房，打算请那一位晚到的朋友入座。才一出门，马上有人给我递名片，原来中国前三大投资银行的CEO已经在门外等了一个半小时了。这位CEO干过中国第一大，第二大，及第三大投资银行的CEO，当年中国最大的电信公司，就是由他做幕后推手推上市，风头一时无量，被人誉为 Deal Maker。这位CEO带了两个他的左右手，在门外等了一个半小时就为见Larry。我带他们三人进房，请Larry 起身，介绍这为中国最有名望的Deal Maker (the Greatest Deal Maker in China)。这位CEO坐在Larry的右手边，我坐在 Larry 左手边。同桌的还有一位全球最好的投资银行的中国首代，坐在我左手下面两个位置。 </p>
<p>爱理逊口才，风度，真是一级棒。他在桌上，没有人能跟他比，他讲了好多笑话给我们听，也讲了许多商场上的战略。 </p>
<p>他对于我安排事情及协调的能力非常激赏，故透过它的公司在亚太地区的负责人问我愿不愿意到他旗下工作。在我婉谢了他的好意。 </p>
<p>从那以后，我与爱理逊之间一职保持着联系，2002年九月，有幸到他旧金山的家作客。 </p>
<h2 id="我与「甲骨文」老板的一段交往-再见旧金山"><a href="#我与「甲骨文」老板的一段交往-再见旧金山" class="headerlink" title="我与「甲骨文」老板的一段交往: 再见旧金山"></a>我与「甲骨文」老板的一段交往: 再见旧金山</h2><p>Larry 和我自2002年六月初北京一别之后，只有靠电子邮件沟通。他问我如何才能飞去旧金山见他。我知道这是不太可能的是，在大中华区我有这么多的事情要忙，不可能一下子飞去看他。我于是想到了在 Case Practice Group 中义结金兰的好友，Polly Preventza。我想把Polly介绍个Larry，因为Polly在 Morgan Staney 的西岸办公市，做高科技的投资银行家。 Polly 在加州理工时就是有名的大美人。我虽不能身在旧金山，但希望因地缘关系Polly能就近陪Larry。 </p>
<p>Larry 有时也会给我写一些令人感动的信。 </p>
<p>终于，2002 年九月中的某一天，我忽然想飞到旧金山见他。另一个原因是，我身怀美国绿卡，必须每半年入美国一次。 上次是 2002 年4月初入美国，九月中该再去了。 Larry 写信告诉我与他见面的时间地点。 </p>
<p>我和 Polly 下午3:00到了 Larry 的家，一个长得很像Larry 的人来开门，Larry还没来，他说。Polly和我，先到房?坐。桌上有一盆很漂亮的花，这个人告诉我们这花是三天前Larry吩咐送来的。我一听，心?有一点感动，因为三天前我还坐在香港的办公室?想着真的能和Larry在他家见面吗。三天后我就坐在他的房子?。世界上的事情有时是说不定的。 </p>
<p>过了一会儿，Larry 从外面三步并作两步的跑了进来，身上穿着一件很薄的T-Shirt，上面写满了 “America’s Cup” 和 “Oracle” 的标记，原来Larry 一整天都努力的在和他的船员们一起训练，为2002 年冬季在澳大利亚的初赛而准备。他花了 US$ 85 mm 造了最好的船，请了最帮的船员及船长，就为了要赢得这个America’s Cup。 </p>
<p>Larry 好心的带我和Polly参观这个日本设计家做的房子。Larry的左右都是有名的富豪，如Getti Museum 的Getti。房子面向海和旧金山的跨海大桥全部是玻璃，有一片视野很大的海景，有很多帆船。他指向他的帆船，说方才他就在那?练习。但Larry对防地震非常重视，玻璃的材质陪上高级金属做的栏杆，这个房子在几次地震中都没事。 对着这一片海景，Larry说 “对 美丽的事物 我是永远不会厌倦的 – I can never get tired of beauty”。 </p>
<p>房子?有一个电梯，可以通到不同的楼层。每一层楼都有不同的材质和颜色设计。 有一层楼放了Larry最心爱的帆船缩影模型Sayonara。这架Sayonara 的长宽比很漂亮，像一个模特儿一样，颀长秀丽。在上面的层楼旁边还有一个很大露天洗三温暖的池子，旁边有树荫稍微挡着，因为这个池子比较高，故池?的人可以看两旁的邻居，但两旁的邻居不能看到池?的人。 </p>
<p>这间房子虽然漂亮，但看得出不是 Larry 常住的地方，倒更像是给记者参观的地方。屋子?没有他家人的照片，唯一的一张照片，是和新闻集团的总裁 Rupert Murdoch 梅铎一起赛船的。 </p>
<p>Larry，Polly 和我，三个人谈天说地，Larry的学识真的很渊博，天文地理，Information Technology，金融，生物科技， 丛 London 到深圳各地的文化他都能朗朗上口，真的非常厉害。我们从下午聊到晚上天暗了，他说他还要去和他女儿用晚饭。 </p>
<p>临走前，Larry在一楼为我们表演了几首吉他，一楼除了吉他之外，还有一台 Steinway 史坦威钢琴。Larry 应该会弹钢琴，因为他用吉他弹了许多钢琴名曲，有 Bach 巴哈也有 Beethovan贝多芬，尤其是贝多芬的”Fur Elise 给艾丽斯”，我听了很感动。我也上去这一台 Steinway弹琴帮他伴奏，我知道他一定不喜欢别人强他的风头，故我用高很多个八度试着提他伴奏，感觉一下为Larry伴奏是什?滋味。十八年前，我就是参加旧金山的儿童天才才艺比赛，用钢琴得到全旧金山的冠军。十八年后，我竟有幸用钢琴为我最崇拜的人 (My Favorite Billionaire) 在旧金山伴奏，我告诉自己，有一天我一定会再回到旧金山来。 </p>
<p>我很珍惜这一段缘分。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[渐行渐远的你我，渐行渐远的友情]]></title>
      <url>http://i90s.vip/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/2015/12/10/%E6%B8%90%E8%A1%8C%E6%B8%90%E8%BF%9C%E7%9A%84%E4%BD%A0%E6%88%91%EF%BC%8C%E6%B8%90%E8%A1%8C%E6%B8%90%E8%BF%9C%E7%9A%84%E5%8F%8B%E6%83%85.html</url>
      <content type="html"><![CDATA[<p>最近越发觉得，生活没意思，跟宿舍的同学探讨这个话题，说着说着就觉得“还是死了的好”。我问宿舍一贯以读书为乐趣的同学：人活着有什么意思？他说，人活着就没意思啊。另一个同学说：那为什么不去死呢？他说：因为还没到时间啊。最近一段时间，我的各种观就套在这个圈子里，欲罢不能。<a id="more"></a></p>
<p>我也想过，人既然活着没意思，那就找些有意思的事情做吧。于是，拾起来落下很久的BBC，每天听来听去也没听出个啥，拾起来很久没写的文字，重新一篇一篇跟记日记般写出来，下载一些歌曲期待能够遇见爱听的好声音。就这样过着日子，在自己的世界里也慢慢地走出了一点路。</p>
<p>前天晚上QQ被盗，在我熟睡中，盗号者删掉了我所有的好友，我估计盗号者失眠严重，实在无聊了吧。第二天早上，有同学留言告诉我的号有异常，中午回宿舍打开电脑，顿时心里气血翻涌，有一种昏死过去的冲动。我的130号好友被删，留下18个人。中午放弃了午休来处理这个问题，直到晚上的时候QQ还是显示有些异常。</p>
<p>今天终于一切正常了。看着被删的一干二净的QQ，我心里倒是清静了不少，没有时时刻刻的闪动，没有头像的跳动，给了我太多的清静啊。然而，我还是要加回来一部分好友，因为有些业务上的联系，或者是我有求于他们，或者是他们有求于我的事情还没有完全解决。而真正为了不失去联系的，并没有几个。</p>
<p>对于友情，我比较喜欢珍惜现下的光阴。那些过去的故事，过去的友谊，大约只能在未来的相见之后才能继续吧。从小到大的那几个好朋友，一年难得联系几次，谁也不会想着主动去联系谁，偶尔打个电话，为了某件事情，或者只是聊聊天，无需太多的问候，见面也依旧以各种损名相称，谁也不会觉得别扭。</p>
<p>QQ重新定义了好友，让友情以文字的形式表现出来。翻出好友聊天记录，看着和某些人的几十页聊天记录，从彼此试探的尊重到肆无忌惮，再到后来的逐渐陌生，终于渐行渐远。当我尝试着冷落别人的时候，我知道他肯定和我一样，也非常的不适应，也许他和我一样，正在翻看着几十页的聊天记录，看看我们是如何相熟，我们交流了什么，因为什么原因有了共鸣。</p>
<p>我曾经在无比没落的时候，一个人守在电脑跟前，内心苦闷。那时候，我还没有学会用文字来化解这样的尴尬，所以，我尝试着去骚扰那些曾经相熟的人。带着忐忑的心情发过去一个表情，等了半天，回过来一句“呵呵”。我终于也就明白了，友情这东西，不论是在网上，还是在现实中，都需要那些所谓的经营。那些曾经良好的关系，时间让它们都消失了。</p>
<p>我也想过要努力挽回那些友谊，毕竟，它曾经代表一段或美好，或悲催的过去，与青春有关，又哭又笑的日子呢。然而，看着那些文字中的处处遮掩，和处处提防，我也不由得收起本想展示给他们的软弱和伤疤还没有结痂的心。我曾经和习惯在朋友面前揭开自己的伤疤给他们看，他们也能轻柔地抚摸，让我在颤栗的疼痛中泪如雨下。这样的动作缓解了我的疼痛，也连通了我们的心。而现在，展示给他们一个硬巴巴的东西可能会吓他们一跳，于我的疼痛而言，他们早已忘记。</p>
<p>我们之间，终于也只剩下了简单的问候。“你好吗？”“我很好，你呢？”“那就好，我也很好。”“再见。”“再见。”就这样变成陌生人，也是个不错的选择。他日再相遇，看着熟悉而又陌生的你们，我内心大概也不会起太多涟漪。他日若能真相见，在某个咖啡店，喝着一杯苦咖啡，若无其事的说一句“好久不见”，然后谈谈天气，也就足够了。</p>
<p>而现在，和一群人的友情，恰到好处。相同的环境，类似的处境，差不离的生活状态，我们在这样的环境下形成稳定的关系。在这样的状态下，我恰好和你有共同的爱好，你恰好喜欢听我损人，于是我们便成了好朋友。刚开始的时候，我们只是维持简单的关系，心中并无太多牵挂。时间让这一切都变质了。于是，某一天，你突然离开一段时间，我心里觉得空落落的，或者，我突然离开，你嚷着说，下次见面我们还要一起做些猥琐的事情。</p>
<p>想念，这个东西，真奇怪。莫名其妙的感觉，莫名其妙的就来了。我正想念此刻的你，然后你从门里闯了进来。于是，我只好说一句，“哎呀，你居然能活着回来。”不用矫情，这样的话你懂得。我想念你们，那些和我关系正好的好朋友，你们带给我现在的欢乐，我珍惜你们现在的好。</p>
<p>然而，这一切，在有一天也即将成为过去。临近毕业，宿舍晚上每天都摆上几桌子，借着某些人的离开来祭奠着某些东西。吃过饭上来的时候，楼下的三个大男人正在告别，两个箱子三个包，三个男人抱了抱。画面感人，此刻信誓旦旦地说着某些话，泪眼婆娑地说着对友情忠贞的誓言。只有我们自己知道，我们这么做是因为从今天起，从离开的那一分一秒开始，这一切都结束了。</p>
<p>在下次碰上之前，我们的关系再也不能像现在这般好了。我们彼此怀念是因为彼此的我们留给彼此一段特别的回忆。而这段时间的过去，毫无疑问地带走了它。从走出去，离开的那一个时刻，剩下的路便没有了彼此，于是，对彼此的念只能留在回忆中了。这段友情注定要淡下去。然而，这并不妨碍我们现在风风火火，彼此熟识，彼此相爱。</p>
<p>在以后的路上，也会遇见不同的人，和不同的人建立一些联系，产生一些友谊。直到有一日，我们中的某些人突然相遇，惊喜地发现，我们可能要在一起过某段日子，于是，我们的友谊便重新开始，好像一个毫无瑕疵的连接，虽然间断了好长时间，这并不妨碍曾经的默契。</p>
<p>我们注定都将在自己的路上越走越远，这是命中注定的事情，活着大概也就这么点事儿。路上遇到的你们，我心中感激，你们带给我的一切，我都将铭记。你们在你们的路上依然出发，大步向前，前面是你们渴望的终点。我站在分别的路口，看看来时的路，那路上有你们，再看看未来的路，那路上有陌生人，也许将来会变成熟悉的人，变成好朋友，和曾经的你们一样。</p>
<p>我喜欢你们，也感谢你们喜欢我。我讨厌你们，也感谢你们嫌弃我。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一个清华学生留学香港后对人生的思考]]></title>
      <url>http://i90s.vip/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/2015/12/09/%E4%B8%80%E4%B8%AA%E6%B8%85%E5%8D%8E%E5%AD%A6%E7%94%9F%E7%95%99%E5%AD%A6%E9%A6%99%E6%B8%AF%E5%90%8E%E5%AF%B9%E4%BA%BA%E7%94%9F%E7%9A%84%E6%80%9D%E8%80%83.html</url>
      <content type="html"><![CDATA[<p>98年本科毕业，又顺利地被保研，当时的我只是一个憨憨的书呆子，纯洁的如同高中生，在清华这种和尚庙一般的理工学校里呆了四年，女孩似乎是山下的老虎，神秘得让我一见就脸红心跳。未来是什么对于我就是“读完研再说”，反正成绩还行，不读白不读。天上掉了馅饼，用我的兄弟的话来说。香港正好回归一周年，教育部要选派一批本科毕业生去香港科技大学读研，以加强两地的教育和科研交流。清华当然要占不少名额，系里的几个牛人去了美国，所以这个饼就掉到了我头上，确实是个不错的饼，不用考G、考托、全额奖学金，连什么手续都是学校和教育部包办了，我分文不花，后来香港科大的联络人抱怨中国的办事效率和程序烦琐，至于怎样的麻烦过程，我至今都一无所知。<br><a id="more"></a></p>
<h2 id="香港科大"><a href="#香港科大" class="headerlink" title="香港科大"></a>香港科大</h2><p>　　就这么糊里糊涂地来到了香港。依山傍海的科技大学美得如同世外桃源，现代感的建筑更让我们爽眼。当时的一个哥们说：“妈的，就是用银子在荒山野岭堆出来的，这样的物质条件算是让我满足了。”后来得知就是亚洲最美丽校园，倒也丝毫不怀疑。据说是香港政府感到了贸易和服务的优势正受中国沿海城市的挑战，而科技就是竞争力，就下了狠心投钱建了这学校，请来了学者。耗资400亿港币，相当于微软公司一年的纯利。组织的参观，教授的讲话，英语的培训很快就过去了，当时的新奇兴奋也褪得干净，每天面对这青山海景，最后也麻木得没有感觉了。由此可以推测娶一个漂亮老婆是没有多大意义的，如果不是为了炫耀。教授大多是华人，台湾和大陆出身的不少，反倒香港人是少数派，很多都是在北美的名校里拿了PhD,奔这里的高薪来了，他们的PhD头衔总要和名字相片挂一起，挂一辈子，Harvard和Standford之类的当然就香了。正教授可以一年拿到一百多万港币，也就是一个月可以买小汽车，比一般的美国大学高。知识真的值钱了，让我们充满了对未来的向往。有回和教授们吃饭，谈及大陆大学教授的待遇，他们就感慨：“知识分子真被廉价到了可耻的地步。”我们也无话可说，反正不是我的错。然而钱不是好拿的，很多教师正是三十出头，教授职称还未到手，和学校只是几年合同，其他的学者也不断在申请进来，所以压力颇大，辛勤程度比公司打工仔有过之而无不及。既然自己做学问要紧，培养学生的事就要往后排了。刚进来时很多教师和我们亲切讲话，之后就不见了，好久不见就不认得。研究生当然有导师的，只要自己不去找他，他是肯定不会找我的。上课之后就是绝对的自由，当时自由得很是惬意。</p>
<p>萧伯纳说人生的苦闷有二，一是欲望没有被满足，二是它得到了满足。</p>
<p>这话的确是部分的真理。当我住在这绝世美丽的地方，可以随心所欲的去商店买东西不用担心付不起帐，可以任意的支配自己时间时，最初的半年里，却发现情绪每况愈下。西方化的建筑设计将个人的所谓privacy保护发挥到极致，进了宿舍就基本感觉不到他人的存在，同单元的人也有独立的卧室，大家都是进了房，将门一关，隔离了，谁也不好意思去敲门。刚来时认识的一伙人，后来发现根本遇不着，如同消失了一般。同住一起的是三十好几的叔叔级人物，偶尔可以说上一两句话，却永无可能说很多。大家都像是住在不同的空间里做研究，忙碌的无瑕顾及他人。</p>
<p>　　平心而论，对于一个成熟的研究者，如果他有确定的目标和兴趣，对生活人生都不再有不切实际的幻想，准备投身科学研究中，那么这里真是一个好环境。但是我种茫茫睁着无知的眼睛的毛头小子，却是完全另外的感觉。那种茫然的苦闷感觉真是难以描述，找不到人玩，只是将窗户开了又关，关了又开，不停的喝水，仍然感觉不舒服。</p>
<p>怀念在清华的破楼里相互串门打闹的日子，怀念抱着篮球在走廊里叫一声就应者云集的日子，可是怀念解决不了问题。以孩子的心理去进入成熟严谨的环境，不可不说是一次考验。</p>
<p>　　多年的功利教育的辛勤培养，我一路顺当地走过来，发现完全的上当。我在成功的通过了一次次考后，最终都不知道我为什么要通过这些占距人生的考试，这个所谓的优秀学生只是在不停地让自己去符合那个“优秀”的外在标准来麻痹自己的虚荣心，而自己，那个真正的自己却一直没有存在过，没有发育过。我学的任何课程都无法帮我解决当时的苦恼，那么每天学那些微分方程又是为了什么？还去为了父母的微笑，人们的赞许吗？年年得奖学金的清华毕业生是了这么一个怪物：不知道自己要什么，也不知道生活是什么，对社会毫无接触，二十出头，可是见女孩子就一身不自在，会解各式各样的方程，却不能解决自己的困惑，硕士博士的路就在眼前，可是不知道还应不应该这样走下去，这状态难道就是我的追求？一个智商还不错的人努力多年就变成这样？</p>
<p>　　这是一个问题，很早就有了，只不过太晚地暴露出来，我相信这样的问题依然将被很多师弟师妹们面临，我相信在清华依旧有很多像我当年一样的学生。当看到他们天真的讨论： G 2<strong>*, 托 6</strong>，GPA 3.<em>, 学校名次Top *</em>, 仿佛几年的辛劳就只为那么点数字，人生的终极标就是goabroad. 我无法不为他们忧虑。这也是促使我写这篇文章的主要原因。</p>
<p>　　很多人没有对做研究的真正兴趣，但是用尽了精力去获得一个去国外做科学研究的机会，就洋溢在掩饰不住的喜悦里，甚至对人生毫无真正规划，对自己的兴趣一无所知，为出国而出国，那将在告别父老乡亲后去迎接苦闷的开端。</p>
<p>　　香港的学生很实际，决大多数本科毕业就去赚钱，三十之间为结婚买房奋斗，如果告诉一个香港人说你二十八了还在读博士，他会觉得你很失败，可能是根本不会赚钱。而留下来读博士的香港学生，就是真的很喜欢作研究的人，扎实地做事，他们的认真让我们一批朝三暮四，心猿意马的大陆学生汗颜。</p>
<h2 id="生活在香港"><a href="#生活在香港" class="headerlink" title="生活在香港"></a>生活在香港</h2><p>　　都说香港是弹丸之地，其实一千多平方公里的面积也不算小，不过大多是山，可利用的地方不多，很多商业区都是添海造出来的。亚热带的气候，又在到处是山和海湾的地方，风景当然好。香港的气候比北京舒适一万倍，冬天冷不了，夏天也不太热，甚至没有明显的四季感。只是上半年天气有些潮。成天都有湿湿的感觉，北方人有点受不了。</p>
<p>　　香港的交通极其发达，公共车从不拥挤，也很少堵车，可是香港的道路比北京的窄得多，车也不会少，布局和管理更好而已，看来北京走向国际化还须努力。这里是名符其实的购物天堂，东西也不算贵，电器和服装可能比北京便宜，特别是国际名牌，由于没有关税，肯定要比大陆便宜。所以不必带很多衣服来，足够便宜了。但是服务业，比如吃饭，理发，涉及到员工劳动和地租的就要比大陆贵好几倍。可以随便往来深圳也是在香港的一大好处，一天可以轻松来回好几次，在香港读书的学生可一得到香港的临时身份证，加上护照上盖个章，就可以自由出入境了。</p>
<p>　　常有人问及香港的影视明星，可是到了香港就觉得那些人也只是打工仔，背后是更有影响力的老板，一旦老板不想捧了，明星就会很快消失，新人会取而代之。看到他们卖力地载歌载舞，其实也是生存需要，在商业社会里那是绝对的驱动力。</p>
<p>　　香港的金融和资讯服务相当发达，在所谓第一世界里也算相当突出，可以很便宜的享受到信用卡，电讯，互联网服务，因此有些人在香港呆久了再回来反而不适应了，主要就是这些方面，当然还有其他制度等软件原因。</p>
<p>　　说到学校的生活，物质条件比国内任何大学好，甚至条件好过美国不少学校，香港的学生很少住宿学校，所以一到周末放假学校就很冷清。通常大陆学生独享学校设备，偌大电脑房和运动场，舒服的游泳池，都有不少美好回忆。学生宿舍条件不错，可以做饭，自己做比在餐厅里吃来的便宜，所以大陆学生会乐此不疲，周末常三五成群，做吃的为乐。餐厅里中西餐都有，中餐以广东口味为主，忙起来时以营养为重，口味不对也只能将就吃了。</p>
<p>　　现在在香港的大陆学生不算多，总共有四五百人，各个学校都有学生联谊会，是比较松散的组织，也有一些机会认识朋友。周末会组织放放电影，搞舞会。临近考试或论文时，谁也没心思搞活动。香港的学生很好打交道，在成熟的社会里长大的人，心理相对简单且好玩，不像一些大陆学生常常过分盘算自己的明天，将自己逼的很累。他们对大陆也渐渐感兴趣，虽然他们常常不知道湖南和四川，只说得上秦始皇和毛泽东。只要主动点和他们交流，是可以结识不少朋友的，粤语不是障碍，很多人可以听普通话，而且，广东话不难学，不留神就长进不少。</p>
<h2 id="关于工作机会"><a href="#关于工作机会" class="headerlink" title="关于工作机会"></a>关于工作机会</h2><p>　　很多人就终于跳到北美去了，大多还是接着读书，从这个意义上讲，香港只是跳板。</p>
<p>　　在香港留下工作的机会不多，如果在进香港的第一天了解这一点，是有好处的。也有回祖国的，我就是，所以我在这里写文章了，看到很多朋友询问去香港读书的问题，作为过来人，就写了这些，如果能给这些朋友提供一点有益的信息，就很满足了。</p>
<p>　　上次写了文章发表在海外学子版，很多朋友给我回信，给了我很大的鼓励，真的没想到过自己的东西会给别人带来影响。留学的经历给了我很多，几乎是一个脱胎换骨的过程，在一篇文章里是不可能都讲完的，所以我再写一个续集，好莱坞搞续集纯是为赚钱，我呢是什么都不图，万一有ppmm看了之后找我，最爽不过。将心底里的一点点“龌龊” 都暴露出来，可以痛快讲了。</p>
<h2 id="凡事都是虚空"><a href="#凡事都是虚空" class="headerlink" title="凡事都是虚空"></a>凡事都是虚空</h2><p>　　来自发展中国家的人，难免在神情上都多一丝生存紧张，中国在海外的留学生尤其让人感觉到这一点。看不到出自内心的笑，连谈话时也似乎只有一个主题：今后有什么打算？每做一件事，都在问自己：对我有没有好处？</p>
<p>　　坦白的说我自己刚到香港时就是这样，只觉得自己多么没着落，无根无底的飘在他乡，我要努力啊，绝不可浪费自己的任何精力，房子，车子，名誉，地位，还有漂亮老婆，我什么都要啊。要学最能给我带来利益的东西，去做最有利自己的事情，直到我成功。当时我就是这么典型功利，到现在我都想这样痛骂自己。</p>
<p>　　数学指出函数的极大值往往在最不稳定的点取到，人追求极端就会失去内心的平衡，到时候就不难体会到数学原理的深刻。我很快让我的功利心理逼到无路可走了，对所学的东西怀疑，担心自己变成书呆子，对自己有信心，找不到真正的朋友，找不到让身心平静的乐趣，每天都在心潮起伏。最后我去找学生辅导员。愚蠢的诉说倒不多提了，不过我记得他大胡子的脸有了微笑，眼睛里放出宽容而温和的光。他告诉我觉的我很有意思，他第一次遇到这么坦白的学生。“那些东西有什么意义呢，你怀疑得很好。“之后就翻出圣经来，给我读某些章。</p>
<p>　　Everything is meaningless.竟是圣经里的话语。那是我看到的最为震惊的一句话，也是我后来觉得最深刻的一句话。中国人很难理解，对在功利教育里熏陶过来，缺少人格教育的中国学生，更无异于晴天霹雳。成绩，offer, 学位，这样那样的好处，每天拼命算计的东西有什么意义？假设你突然死掉，世界将会怎样？世界将一样绚丽，地球转的一样快，太阳系每天在宇宙中换一个位置。大海还是大海，波涛还是波涛，一样的花开花落，潮起潮落。你的亲人可能会掉眼泪，但是周围的人在三个月内将你忘个干净，那是你曾经那么在乎他们怎么看你的一群人啊。如果上帝存在，在他的眼里，你是多么可怜的小虫子，在活着的短暂岁月里，在最美好的青春里，都不曾快乐过，用尽心力去聚集一大堆外在和心灵没有关系的小东西，只是出于对未来的没有信心，小小的心灵在接近熄灭的一天还在发出那个愚蠢的声音，让你忙碌，让你忧虑的声音：我要，我还要。天底下充满了这样的小虫子，当一个离开了，又有一个来了，做着同样的事情，汹涌着同样的小小念头，受着同样的煎熬。于是上帝要感慨了：虚空的虚空，凡事都是虚空。已有的事，后必再有；已行的事，后必再行。日光之下，并无新事。</p>
<p>　　已过的世代，无人纪念；将来的世代，后来的人也不纪念。</p>
<p>　　                                           ——圣经 旧约 传道书</p>
<p>　　我不是在传教，当时的辅导员也不是在传教，但是让我立刻看到自身的渺小，物质追求的虚妄，内心的愚昧。看看资本主义的学生辅导，是不是比我们这边高明多了？马哲曾帮助过我们什么？</p>
<h2 id="不要忧虑"><a href="#不要忧虑" class="headerlink" title="不要忧虑"></a>不要忧虑</h2><p>　　“不要为明天忧虑，天上的飞鸟，不耕种也不收获，上天尚且要养活它，田野里的百合花，从不忧虑它能不能开花，是不是可以开得和其它一样美，但是它就自然的开花了，开得比所罗门皇冠上的珍珠还美。你呢，忧虑什么呢？人比飞鸟和百合花贵重多了，上帝会弃你不顾吗？”</p>
<p>　　一个朋友告诉我，他在等美国 offer 的时候，常常梦到接到牛校offer, 过度兴奋到醒，更为郁郁，感慨“但愿长醉不复醒”。这样的故事大家听了不会太惊诧，由此不难理解《儒林外史》中的进中举了。而得到offer的人到了海外，往往要经历更多的梦醒时分。</p>
<p>　　为什么活得这么累？生命本是如此美丽，连飞鸟和野花都可以尽情地享受上天的恩赐，而这些有高等思维的聪明人，却活活让思维搞得神情郁郁，哀声叹气。</p>
<p>　　常有人感叹西方人笑起来那么真实，那么出自内心，探讨起来，又归结到他们更有钱，他们的社会更发达。可我觉得那不是原因。原因就是他们比中国学生更接近飞鸟和野花罢了，更接近《阿甘正传》里的弱智罢了。他们更天真，相信那个万能的上帝会永不遗弃他，所以他们可以少想很多的问题，反而过得更顺利，在团队里表现得更凝聚，因为过分的私心是无法向大家共同的上帝交代的，他们可以很快做出一个Microsoft，一个Dell，但是大家可以看看中国的北大方正，联想，新浪，管理层一年的地震比台湾还多, 这么多年来，连冲出亚洲的野心都没有真正实现过。 这难道不是上帝给西方人带来的好处，耶稣说信我就可以得救，不管这个上帝是不是虚拟的，但他在事实上填补了人性的巨大空白，人家的Microsoft就证明了他的存在，正如计算机的虚拟内存，尽管虚拟，但事实上的作用是巨大的。中国学生总是怀疑这个看不见的上帝是否存在，更在私下里说，他对我能带来好处吗？其实中国人什么都不信，只信好处，从古时的考八股起，读书就是为了好处。因此，大家每天活在害怕没有好处的忧郁里，想靠自己小小的思维，在着巨大的世界系统里去谋取好处，上帝忍了泪水，背过脸去。</p>
<h2 id="思维的无奈"><a href="#思维的无奈" class="headerlink" title="思维的无奈"></a>思维的无奈</h2><p>　　我并不主张虚无，尽管我在上一篇文章里尽力去指出物质追求的虚妄。正如萨特认为，人生本是本无意义，但是怎样摆脱虚无却是有意义的。王朔的意义在于砸碎那些没有意义的假崇高，伍迪.艾伦的意义就在于不断指出人生的荒谬。如果一切都是那么可笑，我们怎样面对每天的24小时？但是活着就是这么简单，它只是一个过程，简单而自然地发生，以至于任何干扰和关注都是多余。就像飞鸟掠过天空，野花静静地开放。能把什么东西叫做现在吗？你能占有什么东西吗？一切的意义只在时间的流动的河中。就像一团火，哪个燃烧的过程才叫火，一旦过程停止了，火不存在了。人的思维在作怪，它是一个双面的东西，它不总是带给我们好处，虽然我们对它有那么多自信。思维在很多时候严重地干扰了那个自然的生命过程，它在想单个的状态好不好，值不值得，合不合规范，能给自己带来什么，所以我们很快变得不快乐，不安稳，再也无法享受那种自然的喜悦了，正像被摄像的人，他的表情立刻不自然起来。恐怖片里的鬼魂可能一直不曾出现，人们却开始牙齿打颤，是被自己思维折磨而已。学计算机的朋友肯定知道操作系统将一个进程悬挂起来的意思。人的那个蠢笨不堪的思维，凭什么要常驻内存？它那么长期的运转，又真正解决了多少问题？为什么不在必要的时候悬挂它，去享受生命的自然？明白这一点将改变你的生活，思维会使你陷入矛盾，很多时候它是多余的，用心去体会，甚至用毛孔去感受就足够了。当你不再判断，不再分辨，不再比较，不再权衡，你就立刻、和谐起来。“采菊东篱下，悠然见南山”。那时，还用考虑什么呢？“此间有真意，欲辩已忘言”，连言语都是多余，因为言语来自思维。佛陀的捻花一笑，详和的神情，虽静坐，似乎已飞跃世间一切，他坐在了那个生命的根本之上, 再也没有一丝的不和谐。</p>
<p>　　读书的时候，我常常到海边听涛声，坐下来看着太阳落下，那会是我一天最美好的时间，当太阳没下去，晚霞渐渐褪去颜色，波浪依然轻轻拍打岸边，幕色从四周将我围过来，静默中我会在心灵里升起喜悦，感觉到冥冥中那个永恒的力量，它在紧紧将我抱住，天地万物和我一样同在，也被温和地抱着，我将永不孤独，永不伤心，永不绝望，因为那力量就一直在那里，将永远在那里，我是它的恩赐，我的灵魂从未像那时一样枝繁叶茂，内心从未像那时一样宁静和谐。</p>
<p>　　我不用去分辨那种力量，是上帝也好，上天也好，老子说的道也好，有什么关系呢？分辨只是是思维常干的蠢事罢了。所有的心灵都是一样的，所以我相信所有人都有那个和谐的状态，就像收音机有那个频道一样，只不过太多人没有调到过。太阳，大海，清风明月，鸟语花香，生生不息的物种，是多么大的恩赐啊，只在我们断暂的生命里才可以感受到，可是太多的人从不念及。他们将自己全部地交给了少得可怜的脑细胞，心灵交给了那个拙劣的 CPU,时时刻刻在做狭窄不堪的运算和判断，所以才会长时间挣扎焦虑，只看到85分和90分的区别，5000元月薪和10万年薪的不同，牛校和烂校的分辨。所以“郁闷”，“无耻”，“倒霉”，“不爽”，“急”，这样的词汇就开始在嘴边泛滥了，就像破电脑的出错提示一样多。</p>
<p>本没有打算再写很多了，关于人生的刨根问底本来就是沉重的课题，无异让学业繁多的学子们再怀疑自己，平添忧虑。倒不如多说点逗乐的事，每天多嘻嘻哈哈一阵。</p>
<p>前不久见到北大的一个女生，说我前面介绍香港的文字很实用，后面的文章就越来越看不懂了，可以理解，并不是所有的人都要像我一样想这些问题的，特别是女孩，一天多说几声“挺好的”“好温馨哟”就算过得不错了，古今中外都不曾出过一个女哲学家。但是，这位未曾谋面的北大师弟在等我的续集，谢谢你，xmdl(阿扁鱼）, 我不愿让你失望这一篇是为你而写的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[makedown简介]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2015/12/08/makedown%E7%AE%80%E4%BB%8B.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="external">维基百科</a></p>
</blockquote>
<p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.example.com" target="_blank" rel="external">链接</a>或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按<code>Ctrl + /</code>查看帮助。<br><a id="more"></a></p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span><br><span class="line"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure>
<h3 id="LaTeX-公式"><a href="#LaTeX-公式" class="headerlink" title="LaTeX 公式"></a>LaTeX 公式</h3><p>可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式：</p>
<p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table>
<thead>
<tr>
<th style="text-align:left">Item</th>
<th style="text-align:right">Value</th>
<th style="text-align:center">Qty</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Computer</td>
<td style="text-align:right">1600 USD</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:left">Phone</td>
<td style="text-align:right">12 USD</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:left">Pipe</td>
<td style="text-align:right">1 USD</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">e=&gt;end</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>
<p>以及时序图:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示：</strong>想了解更多，请查看<strong>流程图</strong>[语法][3]以及<strong>时序图</strong>[语法][4]。</p>
</blockquote>
<h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>使用 <code>- [ ]</code> 和 <code>- [x]</code> 语法可以创建复选框，实现 todo-list 等功能。例如：</p>
<ul>
<li>[x] 已完成事项</li>
<li>[ ] 待办事项1</li>
<li>[ ] 待办事项2</li>
</ul>
<h2 id="编辑器相关"><a href="#编辑器相关" class="headerlink" title="编辑器相关"></a>编辑器相关</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>右侧系统菜单（快捷键<code>Ctrl + M</code>）的<code>设置</code>中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。</p>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>帮助    <code>Ctrl + /</code><br>同步文档    <code>Ctrl + S</code><br>创建文档    <code>Ctrl + Alt + N</code><br>最大化编辑器    <code>Ctrl + Enter</code><br>预览文档 <code>Ctrl + Alt + Enter</code><br>文档管理    <code>Ctrl + O</code><br>系统菜单    <code>Ctrl + M</code> </p>
<p>加粗    <code>Ctrl + B</code><br>插入图片    <code>Ctrl + G</code><br>插入链接    <code>Ctrl + L</code><br>提升标题    <code>Ctrl + H</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[博客上线了]]></title>
      <url>http://i90s.vip/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/2015/12/08/%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF%E4%BA%86.html</url>
      <content type="html"><![CDATA[<h2 id="博客终于上线了-激动"><a href="#博客终于上线了-激动" class="headerlink" title="博客终于上线了 激动"></a>博客终于上线了 激动</h2><p><img src="http://cdnzz.ifanr.com/wp-content/uploads/2014/02/forktocat_600x375.jpg" alt=""></p>
<h2 id="随便发发牢骚"><a href="#随便发发牢骚" class="headerlink" title="随便发发牢骚"></a>随便发发牢骚</h2><blockquote>
<p>生平我最讨厌的几件事：跟傻逼讲道理，帮弱智理逻辑，给怂逼壮胆儿。<br>对于无可救药之人，我一向果断抛弃。<br>人类进化，任重道远，不可再互相拖后腿，<br>我很忙，不是人人都能让我停下脚步去挽救或者挽留。<br>唯一能对你说的就是请多珍重，如果有朝一日还能迎头赶上，我在前面路上等你。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 使用方法]]></title>
      <url>http://i90s.vip/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/2015/12/08/Hexo%20%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[关于我 & 留言板]]></title>
      <url>http://i90s.vip/about/index.html</url>
      <content type="html"><![CDATA[<style type="text/css">
    strong a {
        color: #747474;
    }
    .player {
        text-align: center;
        margin: .5em auto 0;
    }
    .player br {
        display: none;
    }
    .sign {
        text-align: right;
        font-style: italic;
    }
    #ds-recent-visitors {
        margin: 0;
        padding: 0;
    }
    #ds-recent-visitors div img {
        display: inline-block !important;
        border-radius: 50%;
        border: 1px solid #ddd;
        padding: 2px;
    }
    .article-entry img:first-child {
        display: block;
    }
</style>

<hr>
<h2 id="关于我，请我吃大餐，可以获取更多信息，哈哈哈哈"><a href="#关于我，请我吃大餐，可以获取更多信息，哈哈哈哈" class="headerlink" title="关于我，请我吃大餐，可以获取更多信息，哈哈哈哈"></a>关于我，请我吃大餐，可以获取更多信息，哈哈哈哈</h2><p class="sign">—— Enzo Chen, 2015年12月10日</p>

<p><img src="/resources/badapple.gif" title="Phantom"></p>
<h3 id="开博缘由"><a href="#开博缘由" class="headerlink" title="开博缘由:"></a>开博缘由:</h3><blockquote>
<p>只为认识你<br>共享知识，交流进步</p>
<p>有什么话要对我说的直接在文末留下评论即可</p>
</blockquote>
<div class="player"><br><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="http://music.163.com/outchain/player?type=0&id=146157353&auto=1&height=430"></iframe><br></div>

<ul class="ds-recent-visitors" data-num-items="30" data-avatar-size="56"></ul>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[建站记事]]></title>
      <url>http://i90s.vip/built/index.html</url>
      <content type="html"><![CDATA[<h3 id="2015-12-29"><a href="#2015-12-29" class="headerlink" title="2015-12-29"></a>2015-12-29</h3><ul>
<li>添加文章置顶功能</li>
<li>添加站长功能</li>
</ul>
<h3 id="2015-12-28"><a href="#2015-12-28" class="headerlink" title="2015-12-28"></a>2015-12-28</h3><ul>
<li>优化分类及标签</li>
<li>完善站内搜索</li>
</ul>
<h3 id="2015-12-14"><a href="#2015-12-14" class="headerlink" title="2015-12-14"></a>2015-12-14</h3><ul>
<li>修改文章版权问题</li>
</ul>
<h3 id="2015-12-13"><a href="#2015-12-13" class="headerlink" title="2015-12-13"></a>2015-12-13</h3><ul>
<li>修改多说ID问题</li>
<li>修改主页添加网页问题</li>
</ul>
<h3 id="2015-12-11"><a href="#2015-12-11" class="headerlink" title="2015-12-11"></a>2015-12-11</h3><ul>
<li>添加RSS</li>
<li>Github、Linkedin增加链接</li>
</ul>
<h3 id="2015-12-10"><a href="#2015-12-10" class="headerlink" title="2015-12-10"></a>2015-12-10</h3><ul>
<li>增加多说功能</li>
<li>链接网易云音乐</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[分类 & 标签]]></title>
      <url>http://i90s.vip/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[搜索结果]]></title>
      <url>http://i90s.vip/search/index.html</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.hl &#123;</span><br><span class="line">color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$data = simplexml_load_file(&apos;search.xml&apos;);</span><br><span class="line">define(LEN, 1000);</span><br><span class="line"></span><br><span class="line">echo &apos;&lt;div class=&quot;article-inner article-entry&quot;&gt;&lt;h2&gt;Search Results for: &apos; . $_GET[&quot;s&quot;] . &apos;&lt;/h2&gt;&lt;/div&gt;&apos;;</span><br><span class="line"></span><br><span class="line">foreach($data-&gt;entry as $a) &#123;</span><br><span class="line">	// echo $a-&gt;title;</span><br><span class="line">// echo preg_replace(&quot;/http:\/\/(.*)\//&quot;,&quot;&lt;a href=\&quot;\$&#123;0&#125;\&quot;&gt;\$&#123;0&#125;&lt;/a&gt;&quot;,&quot;$a&quot;);</span><br><span class="line"></span><br><span class="line">	$pattern = &quot;/&quot; . $_GET[&quot;s&quot;] . &quot;/i&quot;;</span><br><span class="line">	$replace = &apos;&lt;span class=hl&gt;&apos; . $_GET[&quot;s&quot;] . &apos;&lt;/span&gt;&apos;;</span><br><span class="line">	// echo $pattern . &quot;&lt;BR&gt;&quot;;</span><br><span class="line">	// echo $replace . &quot;&lt;BR&gt;&quot;;</span><br><span class="line"></span><br><span class="line">	if(preg_match($pattern, $a-&gt;title)  or preg_match($pattern, $a-&gt;content)) &#123;</span><br><span class="line">		echo &apos;&lt;div class=&quot;article-inner article-entry&quot; itemprop=&quot;articleBody&quot;&gt;&lt;a href=&apos; . $a-&gt;url . &apos;&gt;&lt;h3&gt;&apos; . preg_replace($pattern, $replace, $a-&gt;title) . &apos;&lt;/h3&gt;&lt;/a&gt;&apos;;</span><br><span class="line">		$hl_keys = preg_replace($pattern, $replace, $a-&gt;content);</span><br><span class="line"></span><br><span class="line">		$strpos = stripos($a-&gt;content,  $_GET[&apos;s&apos;]);</span><br><span class="line">		$len = min(LEN, strlen($a-&gt;content) - $strpos - 1);</span><br><span class="line"></span><br><span class="line">		echo &apos;&lt;p&gt;&apos; . mb_strcut($hl_keys, $strpos, $len, &quot;utf-8&quot;) . &apos; &lt;span class=article-more-link&gt;&lt;a href=&apos;. $a-&gt;url .&apos;&gt; Detial&gt;&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&apos;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
</search>
