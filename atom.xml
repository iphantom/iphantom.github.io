<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Phantom</title>
  <subtitle>是我的海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://i90s.vip/"/>
  <updated>2016-12-19T07:19:25.000Z</updated>
  <id>http://i90s.vip/</id>
  
  <author>
    <name>Phantom</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RF使用笔记(1)</title>
    <link href="http://i90s.vip/2016/12/19/RF%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://i90s.vip/2016/12/19/RF使用笔记-1/</id>
    <published>2016-12-19T06:33:40.000Z</published>
    <updated>2016-12-19T07:19:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装chromeDriver"><a href="#安装chromeDriver" class="headerlink" title="安装chromeDriver"></a>安装chromeDriver</h2><p>　　RF默认的是FireFox和IE浏览器，鉴于目前chrome市场占有率及良好的开发环境，RF测试建议使用chrome进行测试</p>
<p>1、ChromeDriver下载地址<br><a id="more"></a><br><a href="https://chromedriver.storage.googleapis.com/index.html?path=2.26/" target="_blank" rel="external">ChromeDriver下载地址</a></p>
<blockquote>
<p>chrome驱动并不是指在电脑上安装chrome浏览器就可以，而是chrome驱动</p>
</blockquote>
<p>2、ChromeDriver.exe 放置地址</p>
<p>ChromeDriver的安装地址需要<strong>添加到系统的环境变量里</strong>，只有这样在运行RF时候才能找到ChromeDriver</p>
<blockquote>
<p>我是直接把ChromeDriver.exe放到了 C:\python27\Scripts 路径下。</p>
</blockquote>
<p>3、Chrome 闪退</p>
<p>完成以上动作之后，在运行RF时发现chrome闪退，网上搜索了下，发现并没有比较好的解决方法，看到一篇文章里面说是chrome版本的问题，看了下自己当前的版本是49，然后升级成了53，再运行RF后发现chrome不再闪退，如果大家也有闪退情况，可以升级或者降级下chrome版本试试</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装chromeDriver&quot;&gt;&lt;a href=&quot;#安装chromeDriver&quot; class=&quot;headerlink&quot; title=&quot;安装chromeDriver&quot;&gt;&lt;/a&gt;安装chromeDriver&lt;/h2&gt;&lt;p&gt;　　RF默认的是FireFox和IE浏览器，鉴于目前chrome市场占有率及良好的开发环境，RF测试建议使用chrome进行测试&lt;/p&gt;
&lt;p&gt;1、ChromeDriver下载地址&lt;br&gt;
    
    </summary>
    
      <category term="软件笔记" scheme="http://i90s.vip/categories/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Robot Framework" scheme="http://i90s.vip/tags/Robot-Framework/"/>
    
      <category term="自动化测试" scheme="http://i90s.vip/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter使用随笔（3）</title>
    <link href="http://i90s.vip/2016/12/05/Jmeter%E4%BD%BF%E7%94%A8%E9%9A%8F%E7%AC%94-3/"/>
    <id>http://i90s.vip/2016/12/05/Jmeter使用随笔-3/</id>
    <published>2016-12-05T08:28:29.000Z</published>
    <updated>2016-12-16T09:48:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用Jmeter的过程中发现，当Jmeter运行一个小时左右，就会报Out of memory error的错误。<br>网上查了下解决该问题的方法，需要两步<a id="more"></a><br>1）修改配置</p>
<p>使用 jmeter 进行压力测试时遇到一段时间后报内存溢出 outfmenmory 错误，导致 jmeter 卡死了，先尝试在 jmeter.bat 中增加了 JVM_ARGS=”-Xmx2048m -Xms2048m -Xmn256m -XX:PermSize=128m -Xss256k”，但结果运行时间增加了，但最终还是报内存溢出，百度后按照网友的建议更改了如下设置后 jmeter 就没有再卡了：<br>windows 环境下，修改 jmeter.bat：</p>
<p>set HEAP=-Xms256m -Xmx256m<br>set NEW=-XX:NewSize=128m -XX:MaxNewSize=128m<br>改为：<br>set HEAP=-Xms256m -Xmx1024m<br>set NEW=-XX:NewSize=128m -XX:MaxNewSize=512m</p>
<p>linux 环境下，修改 jmeter.sh：<br>java $JVM_ARGS -Xms1G -Xmx5G -XX:MaxPermSize=512m -Dapple.laf.useScreenMenuBar=true -jar <code>dirname $0</code>/ApacheJMeter.jar “$@”</p>
<p>2）修改脚本监控<br>在Jmeter脚本中，由于’查看结果树’等监控一直在消耗内容，在前期判断脚本正常后，后期跑长时间高并发时，需要去掉’查看结果树’监控</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Jmeter的过程中发现，当Jmeter运行一个小时左右，就会报Out of memory error的错误。&lt;br&gt;网上查了下解决该问题的方法，需要两步
    
    </summary>
    
      <category term="软件笔记" scheme="http://i90s.vip/categories/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Mac" scheme="http://i90s.vip/tags/Mac/"/>
    
      <category term="Jmeter" scheme="http://i90s.vip/tags/Jmeter/"/>
    
      <category term="性能测试" scheme="http://i90s.vip/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Out of memory error" scheme="http://i90s.vip/tags/Out-of-memory-error/"/>
    
  </entry>
  
  <entry>
    <title>为什么有些人开车到家后会独自坐在车中发呆</title>
    <link href="http://i90s.vip/2016/10/31/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%9B%E4%BA%BA%E5%BC%80%E8%BD%A6%E5%88%B0%E5%AE%B6%E5%90%8E%E4%BC%9A%E7%8B%AC%E8%87%AA%E5%9D%90%E5%9C%A8%E8%BD%A6%E4%B8%AD%E5%8F%91%E5%91%86/"/>
    <id>http://i90s.vip/2016/10/31/为什么有些人开车到家后会独自坐在车中发呆/</id>
    <published>2016-10-31T15:00:22.000Z</published>
    <updated>2016-10-31T15:02:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于一个问题和这个问题的答案</p>
<p>最近看到知乎网上有人提问了一个问题，觉得很值得分享给大家：</p>
<p>问题是：为什么有些人开车到家后会独自坐在车中发呆？</p>
<p>回答的人有很多，有人说因为车里好安静，有种小时候看树下蚂蚁搬家时的平静。</p>
<p>还有人说，是因为车里那首歌没听完 <a id="more"></a></p>
<p>有个朋友说，他不仅喜欢把车开到家门口停一会儿，有时候他甚至绕过家门口掉个头奔快环，有无数个想不明白的夜晚，他一个人开着音响在高速上兜圈。 他的最高纪录是开着暖气熄了灯坐在车里静静的看着人们在楼下银行的 atm 机里取钱，来来往往，看了一个小时。</p>
<p>很难理解对不对？</p>
<p>好好的家不回</p>
<p>车里又没有志玲姐姐</p>
<p>为啥喜欢待在车里？</p>
<p>后来<br>回答的人越来越多<br>…<br>…<br>直到有个人说——<br>很多时候我也不想下车，因为那是一个分界点。推开车门你就是柴米油盐、是父亲、是儿子、是老公，唯独不是你自己；在车上，一个人在车上想静静，抽颗烟，这个躯体属于自己。</p>
<p>这个答案迅速获得了超过 4000 人的赞同。</p>
<p>是啊，活着真的太累。每天带着各种面具忍着各种脾气面对着各种人。不断对自己灌输 “成年人”“成熟” 的行为准则，就算回到家也要小心面对自己的父母妻子，照顾他们的情绪，得不到半点轻松。可我有时候也是会想任性的啊！只有在车里，一个幽暗狭小的空间，一支忽明忽灭的香烟，晚上 fm 主持人轻柔的话语，才会让你有种与世隔绝的感觉，也才会让你意识到 “自我” 的存在，那种感觉实在太好。</p>
<p>当然，并非只有男士才有这种喜欢在车里发呆的习惯，有些女性也有相同的感觉。还有人发自内心的建议姑娘们稍微有点实力就买个小车，真的是既私密又体贴。吵架了伤心了难过了不怕没有去处，油门一蹬四处晃荡，哭一场可以撑半年，然后补个妆回去，厚着脸皮嬉皮笑脸继续把游戏玩下去。</p>
<p>我们每天扮演着各种各样的角色：</p>
<p>在公司，你或是下属，或是上司；</p>
<p>在学校，你或是学生，或是老师；</p>
<p>在家里，你或是丈夫，或是妻子；</p>
<p>甚至走在大街上，你也或是男神女神，或是屌丝女汉子，再不济也是个路人。</p>
<p>唯独在车里的那么一小会儿，你就是你自己。</p>
<p>听着没有放完的曲子，感受此时此刻无需伪装，没有杂质的纯净。</p>
<p>心里想着：“还好有这样一个时刻，我什么也不是，就是我自己。还好。”</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于一个问题和这个问题的答案&lt;/p&gt;
&lt;p&gt;最近看到知乎网上有人提问了一个问题，觉得很值得分享给大家：&lt;/p&gt;
&lt;p&gt;问题是：为什么有些人开车到家后会独自坐在车中发呆？&lt;/p&gt;
&lt;p&gt;回答的人有很多，有人说因为车里好安静，有种小时候看树下蚂蚁搬家时的平静。&lt;/p&gt;
&lt;p&gt;还有人说，是因为车里那首歌没听完
    
    </summary>
    
      <category term="心情笔记" scheme="http://i90s.vip/categories/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="转载" scheme="http://i90s.vip/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="博客" scheme="http://i90s.vip/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter使用随笔(2)</title>
    <link href="http://i90s.vip/2016/09/21/Jmeter%E4%BD%BF%E7%94%A8%E9%9A%8F%E7%AC%94-2/"/>
    <id>http://i90s.vip/2016/09/21/Jmeter使用随笔-2/</id>
    <published>2016-09-21T08:00:49.000Z</published>
    <updated>2016-12-16T09:47:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>现在好多网站再用户成功登录时会返回一个登录凭证，在之后的操作上都要带上这个凭证。在使用Jmeter测试的过程中我们需要获取这个凭证。<br>jmeter提供了正则表达式提取器，用变量提取参数，后续通过${变量名}引用参数。</p>
</blockquote>
<h2 id="sessionKey值"><a href="#sessionKey值" class="headerlink" title="sessionKey值"></a>sessionKey值</h2><p>添加方式 线程组-后置处理器-正则表达式提取器</p>
<p><img src="http://ww1.sinaimg.cn/large/666cc9e3gw1fafxrg4xmwj21kw0zdqar.jpg" alt=""></p>
<p>. 引用名称：其他地方引用提取值的变量名称，如填写的是sessionKey,具体引用方式是${sessionKey}<br>. 正则表达式：提取内容的正则表达式【需要注意：（）表示提取，对于你要提取的内容需要用小括号括起来】<br>. 模板：用$$引用起来，如果在正则表达式中有多个提取表达式（多个括号括起来的），则可以是$1$,$2$等，表示解析到的第一个值给sessionKey，正则表达式的提取模式，值从1开始，值0对应的是整个匹配的表达式<br>. 匹配数字：0表示随机，-1表示所有，其余正整数代表将在已提取的内容中，第几个匹配的内容<br>. 缺省值：正则表达式匹配失败时，取的值</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;现在好多网站再用户成功登录时会返回一个登录凭证，在之后的操作上都要带上这个凭证。在使用Jmeter测试的过程中我们需要获取这个凭证。&lt;br&gt;jmeter提供了正则表达式提取器，用变量提取参数，后续通过${变量名}引用参数。&lt;/p&gt;
&lt;/blockq
    
    </summary>
    
      <category term="软件笔记" scheme="http://i90s.vip/categories/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Mac" scheme="http://i90s.vip/tags/Mac/"/>
    
      <category term="Jmeter" scheme="http://i90s.vip/tags/Jmeter/"/>
    
      <category term="性能测试" scheme="http://i90s.vip/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter 使用随笔(1)</title>
    <link href="http://i90s.vip/2016/09/19/Jmeter-%E4%BD%BF%E7%94%A8%E9%9A%8F%E7%AC%94/"/>
    <id>http://i90s.vip/2016/09/19/Jmeter-使用随笔/</id>
    <published>2016-09-19T06:55:10.000Z</published>
    <updated>2016-12-16T09:48:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP信息头管理器-Content-type"><a href="#HTTP信息头管理器-Content-type" class="headerlink" title="HTTP信息头管理器 Content-type"></a>HTTP信息头管理器 Content-type</h2><p>Content-type：在Request Hearder里，告诉服务器我们发送的请求信息是那种格式的。</p>
<p>1 默认值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-type：application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>
<p>参数格式：key1=value1 &amp; key2=value2</p>
<p>jmeter参数使用方法<br>(1)Paramenters<br><img src="http://ww1.sinaimg.cn/large/666cc9e3gw1f7yzjihid6j21g711lag9.jpg" alt=""><a id="more"></a><br>(2)Body Data<br><img src="http://ww4.sinaimg.cn/large/666cc9e3gw1f7zw1flrz2j21gd12pq8v.jpg" alt=""></p>
<p>2 Json格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-type:application/json</span><br></pre></td></tr></table></figure>
<p>参数格式：<br>{<br>    “key1”:”value1”,<br>    “key2”:”value2”<br>}</p>
<p>jmeter参数使用方法<br>(1)添加HTTP信息头管理器<br><img src="http://ww4.sinaimg.cn/large/666cc9e3gw1f7zw6hlpapj21g30h8mz4.jpg" alt=""><br>(2)Body Data输入参数<br><img src="http://ww1.sinaimg.cn/large/666cc9e3gw1f7zw4o86zxj21fh11qn35.jpg" alt=""></p>
<p>3 传输文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-type:multipart/form-data</span><br></pre></td></tr></table></figure>
<p>(1)HTTP请求页面，勾选Use multipart/form-data for POST<br>(2)Paramenters中输入除了要上传的文件以外的参数<br><img src="http://ww1.sinaimg.cn/large/666cc9e3gw1f7zw940lqgj21fd10zq8p.jpg" alt=""><br>(3)File Upload中上传文件，填写参数名和MIME类型<br><img src="http://ww1.sinaimg.cn/large/666cc9e3gw1f7zwbfcq90j21fe0zdgsi.jpg" alt=""></p>
<h2 id="返回值中文乱码"><a href="#返回值中文乱码" class="headerlink" title="返回值中文乱码"></a>返回值中文乱码</h2><p>（1）再jmeter安装文件夹中找到bin文件夹，用记事本打开jmeter.properties文件<br>（2）修改sampleresult.default.encoding=UTF-8</p>
<blockquote>
<p>注意去掉sampleresult.default.encoding=UTF-8前面的#号</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP信息头管理器-Content-type&quot;&gt;&lt;a href=&quot;#HTTP信息头管理器-Content-type&quot; class=&quot;headerlink&quot; title=&quot;HTTP信息头管理器 Content-type&quot;&gt;&lt;/a&gt;HTTP信息头管理器 Content-type&lt;/h2&gt;&lt;p&gt;Content-type：在Request Hearder里，告诉服务器我们发送的请求信息是那种格式的。&lt;/p&gt;
&lt;p&gt;1 默认值&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Content-type：application/x-www-form-urlencoded&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;参数格式：key1=value1 &amp;amp; key2=value2&lt;/p&gt;
&lt;p&gt;jmeter参数使用方法&lt;br&gt;(1)Paramenters&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/666cc9e3gw1f7yzjihid6j21g711lag9.jpg&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="软件笔记" scheme="http://i90s.vip/categories/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Mac" scheme="http://i90s.vip/tags/Mac/"/>
    
      <category term="Jmeter" scheme="http://i90s.vip/tags/Jmeter/"/>
    
      <category term="性能测试" scheme="http://i90s.vip/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>使用Jmeter进行接口测试</title>
    <link href="http://i90s.vip/2016/09/04/%E4%BD%BF%E7%94%A8Jmeter%E8%BF%9B%E8%A1%8C%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    <id>http://i90s.vip/2016/09/04/使用Jmeter进行接口测试/</id>
    <published>2016-09-04T09:34:06.000Z</published>
    <updated>2016-09-04T09:34:06.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mac下安装Jmeter</title>
    <link href="http://i90s.vip/2016/09/04/Mac%E4%B8%8B%E5%AE%89%E8%A3%85Jmeter/"/>
    <id>http://i90s.vip/2016/09/04/Mac下安装Jmeter/</id>
    <published>2016-09-04T08:47:36.000Z</published>
    <updated>2016-09-04T09:30:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载Jmeter"><a href="#下载Jmeter" class="headerlink" title="下载Jmeter"></a>下载Jmeter</h2><p><a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="external">Apache JMeter 3.0</a><br>将压缩包解压</p>
<h2 id="配置Jmeter环境"><a href="#配置Jmeter环境" class="headerlink" title="配置Jmeter环境"></a>配置Jmeter环境</h2><p>JMeter 是基于 Java 的框架，所以要求系统必须安装JDK。<a id="more"></a></p>
<p><strong>查看mac是否已经安装JDK</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/666cc9e3jw1f7ho5ekughj214d0d0q7i.jpg" alt=""></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -<span class="built_in">version</span></span><br></pre></td></tr></table></figure>
<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">JDK下载地址</a></p>
<h2 id="运行Jmeter"><a href="#运行Jmeter" class="headerlink" title="运行Jmeter"></a>运行Jmeter</h2><p>进入apache-jmeter-3.0的bin目录下<br>运行 sh jmeter 即可打开jmeter软件</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd apache-<span class="keyword">jmeter-3.0/bin</span><br><span class="line"></span><span class="keyword">sh </span><span class="keyword">jmeter</span></span><br></pre></td></tr></table></figure>
<p><img src="http://ww3.sinaimg.cn/large/666cc9e3gw1f7hola8tkkj21kw0zkgrz.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;下载Jmeter&quot;&gt;&lt;a href=&quot;#下载Jmeter&quot; class=&quot;headerlink&quot; title=&quot;下载Jmeter&quot;&gt;&lt;/a&gt;下载Jmeter&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://jmeter.apache.org/download_jmeter.cgi&quot;&gt;Apache JMeter 3.0&lt;/a&gt;&lt;br&gt;将压缩包解压&lt;/p&gt;
&lt;h2 id=&quot;配置Jmeter环境&quot;&gt;&lt;a href=&quot;#配置Jmeter环境&quot; class=&quot;headerlink&quot; title=&quot;配置Jmeter环境&quot;&gt;&lt;/a&gt;配置Jmeter环境&lt;/h2&gt;&lt;p&gt;JMeter 是基于 Java 的框架，所以要求系统必须安装JDK。
    
    </summary>
    
      <category term="软件笔记" scheme="http://i90s.vip/categories/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Mac" scheme="http://i90s.vip/tags/Mac/"/>
    
      <category term="Jmeter" scheme="http://i90s.vip/tags/Jmeter/"/>
    
  </entry>
  
  <entry>
    <title>关于CS,一些你不知道的事</title>
    <link href="http://i90s.vip/2016/09/03/%E5%85%B3%E4%BA%8ECS-%E4%B8%80%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/"/>
    <id>http://i90s.vip/2016/09/03/关于CS-一些你不知道的事/</id>
    <published>2016-09-03T12:27:35.000Z</published>
    <updated>2016-09-03T12:47:29.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>偶然间在论坛上看到的一篇文章，值得思考<br>非常感谢<a href="http://bbs.gter.net/thread-1717877-1-1.html" target="_blank" rel="external">irvine666</a></p>
</blockquote>
<p>　　为了增加可信度，先介绍一下自己。我本科毕业于上海交通大学计算机系，后在上海从事 IT2 年，期间曾经试图创业但失败。然后申请美国大学硕士拿到半奖出国，毕业后到加州硅谷一家超大型公司从事 IT 工作。后因为一些原因跳槽到总部在波士顿的另一家超大型公司接着做 IT 到现在。所以我可以保证：看一下这篇文章并不会浪费我们共同的时间。</p>
<p>　　首先必须承认，CS 是最近 10 年来在美国最好找工作的职业，这点各位差不多都已经知道了，但是接下来的一些东西会让你们知道为什么宣传转 CS 的都是一些非 CS 专业的人，真正的 CS 从业者很少会劝人转 CS。<br><a id="more"></a><br>1、  程序员并不是一个能够长期从事的职业</p>
<p>　　按照业内人士的话来讲，CS 这个行业：越老越不值钱。原因很简单，CS 的技术每天都在更新换代，速度之快已经到了你如果 2 个月不碰它，那么就很难赶上进度。真正的 CS 工作是这样的：每 1-2 周，你会负责把一整个模块搭建起来，在计划书当中包括了好几个你根本没有听说过的东西。你的任务就是在 1-2 周之内，把这些东西全部学懂，然后应用到你的模块当中，并调试通过保证没有任何的漏洞。这个需要很强的学习和应用能力以及很强的熬夜能力。在年纪大了以后，很难比拼过刚毕业 1-2 年的员工。试想一下，你如果作为老板，是愿意聘用每年 12-15 万的 40 岁的有老婆孩子身体也不太好老请病假的老员工，还是 8-10 万一年的能熬夜干劲足没有家庭牵挂的小青年呢？</p>
<p>2、 程序员意味着私人和家庭生活的匮乏</p>
<p>　　除了少数几个养老公司以外（比如：IBM，Salesforce，以及 3 年前的微软），我所了解的绝大部分 IT 公司加班乃至昼夜颠倒是非常正常的事情。如果你能够晚上 7 点下班，并保证回家不加班，那么说明你是非常非常厉害的一个人。过度的加班往往意味着只能牺牲自己的私人和家庭时间。如果你是单身青年，你不会有时间去好好谈恋爱，挑选人生的伴侣；如果你结婚了，你会发现除非配偶不工作，你很难有时间和精力生孩子；如果你有家庭，你的老婆孩子甚至不会感觉到你的存在，你面对电脑的时间会远远超过陪伴他们的时间，而这个，在 5-20 年会有很严重的后果，具体的后果包括家庭破裂，子女叛逆不孝等等。我不止一次听我们的各个老程序员抱怨后悔年轻时没有时间陪伴家人。</p>
<p>3、  程序员的工作对身体伤害很大</p>
<p>　　还是那句话，长期加班 + 心里孤独，会导致很多问题。30 岁左右就脊椎扭曲甚至心态不正常的程序员不在少数，更多数的会带有一生的病痛，手指痉挛，背痛得无法躺下，腿部供血不足，头痛欲裂等等现象会伴随你度过每一个晚上。</p>
<p>4、  程序员的前景并不明朗</p>
<p>　　看待一个行业，并不能够只看它辉煌的时期，而是应当从一生的角度来选择。举个典型的例子，记得我在刚进大学的时候，信息保护和光伏工程这两个专业是最火的，因为所有毕业生都被各大公司疯抢。但是在我毕业的时候，甚至都没有听说过有几个学校还在开办这些专业。就是因为那几年所有的学校都在开办，毕业生的人数迅速超过了社会的需求，同时由于新的技术出现，导致原来的公司迅速被淘汰，就业需求大大减少。从目前来看，CS 这个行业已经充斥着很多泡沫，如果你们能去搜索一下各个 IT 上市公司的 P/E 数据就会发现，整个 tech 板块都充斥着不理性的投资，这个泡沫能吹多大或者还能持续几年？我不知道，但是我知道一旦泡泡破了，大量的 CS 从业人员将会受到影响，裁员失业是不可避免的事情。从目前来看，NASDAQ 已经出现了一些崩盘的征兆，在过去的几周当中，所有的 IT 公司股票都下跌了 25% 左右。</p>
<p>5、  程序员这个行业竞争已经过于激烈</p>
<p>　　虽然大部分 IT 公司还在招人，但是请记住他们只要 “最好” 的人，并不是所有的程序员都能被他们看上。由于人才市场的爆满，合格的 candidate 会获得非常高的报酬，但也意味着即使你成功获得 offer，你所面临的压力会更大。我举 Facebook 为例，它给出的报酬在业内也是算 1，2 名了，但是当你接受 offer 开始，你便面临这残酷的竞争。所有 facebook 的新员工必须经过一个为期 6 周的训练营，在这个期间，你必须学会 facebook 的开发，调试，搭配环境并自己写出一些东西来证明自己。训练营的淘汰率为 10%，也就是说，所有合格拿到 offer 的人（已经很厉害了）当中，10% 的人入职不会超过六周就被 fire。即使你成功通过训练营，每个季度会考核你的 performance，最后 5%-10% 的人将被 fire 掉。这些被裁掉的人的位置，将由更优秀的人来填补。在硅谷，绝大多数公司可能没有训练营淘汰制，但是他们都会有每个季度或者每年的淘汰制。所以拿到 OFFER 才是痛苦的开始。要留下来，只能玩命。</p>
<p>6、  程序员的绿卡之路并不会比别的职业顺利多少</p>
<p>　　首先，程序员的绿卡排期和其他专业是一样的。其次，大家可能还不知道美国政府有一个特别坑爹的规定：“如果一个公司出现 layoff 性质的裁员，那么这个公司所有的绿卡程序将会被拖延半年”。这个规定使得在一些 IT 公司，那绿卡成为 IMPOSSIBLE。比如 ECM。这种公司的宗旨就是业绩说话，他们每年会新建很多的 team，但是到了年底，表现一般的 team 就会被整个裁掉，这样来保证自己整个公司的业绩始终是上升的。在这种公司，每个月都会裁员，即使给你开始办绿卡了，你也永远看不到被批准的一天。相比起来，其他的行业比 IT 稳定多了，一旦开始排期，拿绿卡也会更为顺利。而如果能做到博士或者博后，甚至能够凭借文章申请杰出人才绿卡，在几个月内被批准。</p>
<p>　　所以说，程序员这个职业并不是像外界评论的一样无可匹敌 。它有自己的优势也会有劣势。我想更准确的说法是，如果你决定从事 CS，那么你必须：1. 非常感兴趣，喜欢这个行业；或者 2. 你不喜欢这个行业，但是你愿意用自己的青春，健康，自己未来的私人和家庭生活去换取一些金钱或者短期的荣耀。 </p>
<p>　　最后，我想说任何行业都有成功的人，任何成功的人都具有的一个特点就是几十年如一日的坚持。我希望每个人都有自己的坚持，如果只是听别人说说就决定转这个转那个，那永远不会有成功的一天。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;偶然间在论坛上看到的一篇文章，值得思考&lt;br&gt;非常感谢&lt;a href=&quot;http://bbs.gter.net/thread-1717877-1-1.html&quot;&gt;irvine666&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　为了增加可信度，先介绍一下自己。我本科毕业于上海交通大学计算机系，后在上海从事 IT2 年，期间曾经试图创业但失败。然后申请美国大学硕士拿到半奖出国，毕业后到加州硅谷一家超大型公司从事 IT 工作。后因为一些原因跳槽到总部在波士顿的另一家超大型公司接着做 IT 到现在。所以我可以保证：看一下这篇文章并不会浪费我们共同的时间。&lt;/p&gt;
&lt;p&gt;　　首先必须承认，CS 是最近 10 年来在美国最好找工作的职业，这点各位差不多都已经知道了，但是接下来的一些东西会让你们知道为什么宣传转 CS 的都是一些非 CS 专业的人，真正的 CS 从业者很少会劝人转 CS。&lt;br&gt;
    
    </summary>
    
      <category term="软件笔记" scheme="http://i90s.vip/categories/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="转载" scheme="http://i90s.vip/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="CS" scheme="http://i90s.vip/tags/CS/"/>
    
  </entry>
  
  <entry>
    <title>和软件测试有关的那些事</title>
    <link href="http://i90s.vip/2016/07/11/%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://i90s.vip/2016/07/11/测试相关的那些事/</id>
    <published>2016-07-11T10:55:00.000Z</published>
    <updated>2016-07-11T10:58:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是软件测试？"><a href="#1-什么是软件测试？" class="headerlink" title="1. 什么是软件测试？"></a>1. 什么是软件测试？</h2><p>软件测试是为了发现错误而执行程序的过程。或者说，软件测试是根据软件开发各阶段的规格说明和程序的内部结构而精心设计一批测试用例(即输入数据及其预期的输出结果)，并利用这些测试用例去运行程序，以发现程序错误的过程。</p>
<h2 id="2-软件测试的目的"><a href="#2-软件测试的目的" class="headerlink" title="2.  软件测试的目的?"></a>2.  软件测试的目的?</h2><p>测试的目的是想以最少的人力、物力和时间找出软件中潜在的各种错误和缺陷，通过修正种错误和缺陷提高软件质量，回避软件发布后由于潜在的软件缺陷和错误造成的隐患带来的商业风险。<a id="more"></a></p>
<h2 id="3-什么是需求文档测试？"><a href="#3-什么是需求文档测试？" class="headerlink" title="3. 什么是需求文档测试？"></a>3. 什么是需求文档测试？</h2><p>主要测试需求中是否存在逻辑矛盾以及需求在技术上是否可以实现。</p>
<h2 id="4-什么是设计文档测试"><a href="#4-什么是设计文档测试" class="headerlink" title="4. 什么是设计文档测试?"></a>4. 什么是设计文档测试?</h2><p>测试设计是否符合全部需求以及设计是否合理。</p>
<h2 id="5-什么是α测试"><a href="#5-什么是α测试" class="headerlink" title="5. 什么是α测试?"></a>5. 什么是α测试?</h2><p>Alpha测试(α测试)是由<strong>一个用户在开发环境下进行的测试</strong>，也可以是公司内部的用户在模拟实际操作环境下进行的受控测试，Alpha测试不能由程序员或测试员完成。Alpha测试发现的错误，可以在测试现场立刻反馈给开发人员，由开发人员及时分析和处理。目的是评价软件产品的功能、可使用性、可靠性、性能和支持。尤其注重产品的界面和特色。Alpha测试可以从软件产品编码结束之后开始，或在模块(子系统)测试完成后开始，也可以在确认测试过程中产品达到一定的稳定和可靠程度之后再开始。有关的手册(草稿)等应该在Alpha测试前准备好。</p>
<h2 id="6-什么是β测试"><a href="#6-什么是β测试" class="headerlink" title="6. 什么是β测试?"></a>6. 什么是β测试?</h2><p>Beta测试(β测试)是软件的<strong>多个用户在一个或多个用户的实际使用环境下</strong>进行的测试。开发者通常不在测试现场，Beta测试不能由程序员或测试员完成。因而，Beta测试是在开发者无法控制的环境下进行的软件现场应用。在Beta测试中，由用户记下遇到的所有问题，包括真实的以及主管认定的，定期向开发者报告，开发者在综合用户的报告后，做出修改，最后将软件产品交付给全体用户使用。Beta测试着重于产品的支持性，包括文档、客户培训和支持产品的生产能力。只有当Alpha测试达到一定的可靠程度后，才能开始Beta测试。由于Beta测试的主要目标是测试可支持性，所以Beta测试应该尽可能由主持产品发行的人员来管理。</p>
<h2 id="7-什么是驱动模块？"><a href="#7-什么是驱动模块？" class="headerlink" title="7. 什么是驱动模块？"></a>7. 什么是驱动模块？</h2><p>驱动模块在大多数场合称为”主程序”，它接收测试数据并将这些数据传递到被测试模块.单元测试一个函数单元时，被测单元本身是不能独立运行的，需要为其传送数据，为此写驱动<br>驱动模块主要完成以下事情：<br>1、接受测试输入;<br>2、对输入进行判断;<br>3、将输入传给被测单元，驱动被测单元执行;<br>4、接受被测单元执行结果，并对结果进行判断;<br>5、将判断结果作为用例执行结果输出测试报告。</p>
<h2 id="8-什么是桩模块"><a href="#8-什么是桩模块" class="headerlink" title="8. 什么是桩模块?"></a>8. 什么是桩模块?</h2><p>比如对函数A做单元测试时，被测的函数单元下还包括了一个函数B，为了更好的错误，定位错误，就要为函数B写桩，来模拟函数B的功能，保证其正确。</p>
<h2 id="9-什么是白盒测试"><a href="#9-什么是白盒测试" class="headerlink" title="9. 什么是白盒测试?"></a>9. 什么是白盒测试?</h2><p>:白盒测试(White-box Testing，又称逻辑驱动测试,结构测试),它是知道产品内部工作过程，可通过测试来检测产品内部动作是否按照规格说明书的规定正常进行，按照程序内部的结构测试程序，检验程序中的每条通路是否都有能按预定要求正确工作，而不顾它的功能，白盒测试的主要方法有逻辑驱动、基路测试等，主要用于软件验证。对开发语言的支持：白盒测试工具是对源代码进行的测试，测试的主要内容包括词法分析与语法分析、静态错误分析、动态检测等。目前测试工具主要支持的开发语言包括：标准C、C++、Visual C++、Java、Visual J++等。</p>
<h2 id="10-什么是静态测试"><a href="#10-什么是静态测试" class="headerlink" title="10. 什么是静态测试?"></a>10. 什么是静态测试?</h2><p>通过运行程序测试软件称为测试.通过评审文档、阅读代码等方式测试软件称为静态测试,在动态测试中,通常使用白盒测试和黑盒测试从不同的角度设计测试用例,查找软件代码中的错误.<br>     <strong>静态测试方法是指不运行被测程序本身</strong>，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性。对需求规格说明书、软件设计说明书、源程序做结构分析、流程图分析、符号执行来找错。静态方法通过程序静态特性的分析，找出欠缺和可疑之处，例如不匹配的参数、不适当的循环嵌套和分支嵌套、不允许的递归、未使用过的变量、空指针的引用和可疑的计算等。静态测试结果可用于进一步的查错，并为测试用例选取提供指导。</p>
<h2 id="11-什么是回归测试"><a href="#11-什么是回归测试" class="headerlink" title="11. 什么是回归测试?"></a>11. 什么是回归测试?</h2><p>回归测试的目的是在程序有修改的情况下，保证原有功能正常的一种测试策略和方法。说白了就是，我们测试人员在对程序进行测试时发现bug，然后返还程序员修改，程序员修改后发布新的软件包或新的软件补丁包给我们测试人员，我们就要重新对这个程序测试，已保证程序在修正了以前bug的情况下，正常运行，且不会带来新的错误的这样一个过程。 一般情况下是不需要全面测试的，而是根据修改的情况进行有效的测试。</p>
<h2 id="12-白盒测试有哪几种方法"><a href="#12-白盒测试有哪几种方法" class="headerlink" title="12. 白盒测试有哪几种方法?"></a>12. 白盒测试有哪几种方法?</h2><p>白盒测试也称结构测试或逻辑驱动测试，它是知道产品内部工作过程，可通过测试来检测产品内部动作是否按照规格说明书的规定正常进行，按照程序内部的结构测试程序，检验程序中的每条通路是否都有能按预定要求正确工作，而不顾它的功能，白盒测试的主要方法有逻辑驱动、基路测试等，主要用于软件验证。“白盒”法全面了解程序内部逻辑结构、对所有逻辑路径进行测试。“白盒”法是穷举路径测试。</p>
<h2 id="13-软件的缺陷等级应如何划分"><a href="#13-软件的缺陷等级应如何划分" class="headerlink" title="13. 软件的缺陷等级应如何划分?"></a>13. 软件的缺陷等级应如何划分?</h2><p>1）致命错误，可能导致本模块以及其他相关模块异常，死机等问题;<br>2）严重错误，问题局限在本模块，导致模块功能失效或异常退出<br>3）一般错误，模块功能部分失效;<br>4）建议问题，由问题提出人对测试对象的改进意见;</p>
<h2 id="14-如果能够执行完美的黑盒测试，还需要进行白盒测试吗-白盒与黑盒的区别"><a href="#14-如果能够执行完美的黑盒测试，还需要进行白盒测试吗-白盒与黑盒的区别" class="headerlink" title="14. 如果能够执行完美的黑盒测试，还需要进行白盒测试吗?(白盒与黑盒的区别)"></a>14. 如果能够执行完美的黑盒测试，还需要进行白盒测试吗?(白盒与黑盒的区别)</h2><p>任何工程产品(注意是任何工程产品)都可以使用以下两种方法之一进行测试。<br>黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。 白盒测试：已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否以经过检查。<br>软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试或数据驱动测试。黑盒测试主要是为了发现以下几类错误：<br>1、是否有不正确或遗漏的功能?<br>2、在接口上，输入是否能正确的接受?能否输出正确的结果?<br>3、是否有数据结构错误或外部信息(例如数据文件)访问错误?<br>4、性能上是否能够满足要求?<br>5、是否有初始化或终止性错误?<br>软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试或逻辑驱动测试。白盒测试主要是想对程序模块进行如下检查：<br>1、对程序模块的所有独立的执行路径至少测试一遍。<br>2、对所有的逻辑判定，取“真”与取“假”的两种情况都能至少测一遍。<br>3、在循环的边界和运行的界限内执行循环体。<br>4、测试内部数据结构的有效性，等等。<br>以上事实说明，软件测试有一个致命的缺陷，即测试的不完全、不彻底性。由于任何程序只能进行少量(相对于穷举的巨大数量而言)的有限的测试，在未发现错误时，不能说明程序中没有错误。</p>
<h2 id="15-软件测试应该划分几个阶段-简述各个阶段应重点测试的点-各个阶段的含义"><a href="#15-软件测试应该划分几个阶段-简述各个阶段应重点测试的点-各个阶段的含义" class="headerlink" title="15. 软件测试应该划分几个阶段?简述各个阶段应重点测试的点?各个阶段的含义?"></a>15. 软件测试应该划分几个阶段?简述各个阶段应重点测试的点?各个阶段的含义?</h2><p>大体上来说可分为单元测试,集成测试,系统测试,验收测试,每个阶段又分为以下五个步骤: 测试计划，测试设计，用例设计，执行结果，测试报告初始测试集中在每个模块上，保证源代码的正确性，该阶段成为单元测试，主要用白盒测试方法。 接下来是模块集成和集成以便组成完整的软件包。集成测试集中在证实和程序构成问题上。主要采用黑盒测试方法，辅之以白盒测试方法。软件集成后，需要完成确认和系统测试。确认测试提供软件满足所有功能、性能需求的最后保证。确认测试仅仅应用黑盒测试方法。</p>
<h2 id="16-什么是单元测试？"><a href="#16-什么是单元测试？" class="headerlink" title="16. 什么是单元测试？"></a>16. 什么是单元测试？</h2><p>单元测试是对软件中的基本组成单位进行的测试，如一个模块、一个过程等等。它是软件动态测试的最基本的部分，也是最重要的部分之一，其目的是检验软件基本组成单位的正确性。</p>
<h2 id="17-什么是集成测试？"><a href="#17-什么是集成测试？" class="headerlink" title="17. 什么是集成测试？"></a>17. 什么是集成测试？</h2><p>集成测试是在软件系统集成过程中所进行的测试，其主要目的是检查软件单位之间的接口是否正确。</p>
<h2 id="18-什么是系统测试？"><a href="#18-什么是系统测试？" class="headerlink" title="18. 什么是系统测试？"></a>18. 什么是系统测试？</h2><p>系统测试是对已经集成好的软件系统进行彻底的测试，以验证软件系统的正确性和性能等满足其规约所指定的要求，检查软件的行为和输出是否正确并非一项简单的任务，它被称为测试的“先知者问题”。</p>
<h2 id="19-什么是验收测试？"><a href="#19-什么是验收测试？" class="headerlink" title="19. 什么是验收测试？"></a>19. 什么是验收测试？</h2><p>收测试旨在向软件的购买者展示该软件系统满足其用户的需求。它的测试数据通常是系统测试的测试数据的子集.</p>
<h2 id="20-针对缺陷采取怎样的管理措施"><a href="#20-针对缺陷采取怎样的管理措施" class="headerlink" title="20. 针对缺陷采取怎样的管理措施?"></a>20. 针对缺陷采取怎样的管理措施?</h2><p>1）要更好的管理缺陷，必须引入缺陷管理工具，商用的或者开源的都可。<br>2）根据缺陷的生命周期，考虑缺陷提交的管理、缺陷状态的管理和缺陷分析的管理。<br>3） 所有发现的缺陷(不管是测试发现的还是走读代码发现的)都必须全部即时的、准确的提交到缺陷管理工具中，这是缺陷提交的管理。<br>4）缺陷提交后，需要即时的指派给相应的开发人员，提交缺陷的人需要密切注意缺陷的状态， 帮助缺陷的尽快解决。缺陷解决后需要即时对缺陷的修复进行验证。这样的目的有两个：一个是让缺陷尽快解决;二是方便后面缺陷的分析(保证缺陷相关的信息准确，如龄期等)，这是缺陷状态的管理。<br>5）为了更好的改进开发过程和测试过程，需要对缺陷进行分析，总结如缺陷的类别、缺陷的龄期分布等信息，这是缺陷分析的管理。</p>
<h2 id="21-单元测试、集成测试、系统测试的侧重点是什么"><a href="#21-单元测试、集成测试、系统测试的侧重点是什么" class="headerlink" title="21.单元测试、集成测试、系统测试的侧重点是什么?"></a>21.单元测试、集成测试、系统测试的侧重点是什么?</h2><p>单元测试是在软件开发过程中要进行的最低级别的测试活动，在单元测试活动中，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试，测试重点是系统的模块，包括子程序的正确性验证等。 集成测试，也叫组装测试或联合测试。在单元测试的基础上，将所有模块按照设计要求，组装成为子系统或系统，进行集成测试。实践表明，一些模块虽然能够单独地工作，但并不能保证连接起来也能正常的工作。程序在某些局部反映不出来的问题，在全局上很可能暴露出来，影响功能的实现。测试重点是模块间的衔接以及参数的传递等。系统测试是将经过测试的子系统装配成一个完整系统来测试。它是检验系统是否确实能提供系统方案说明书中指定功能的有效方法。测试重点是整个系统的运行以及与其他软件的兼容性。</p>
<h2 id="22-描述使用bugzilla缺陷管理工具对软件缺陷-BUG-跟踪的管理的流程"><a href="#22-描述使用bugzilla缺陷管理工具对软件缺陷-BUG-跟踪的管理的流程" class="headerlink" title="22.描述使用bugzilla缺陷管理工具对软件缺陷(BUG)跟踪的管理的流程"></a>22.描述使用bugzilla缺陷管理工具对软件缺陷(BUG)跟踪的管理的流程</h2><p>1) 测试人员或开发人员发现bug后，判断属于哪个模块的问题，填写bug报告后，系统会自动通过Email通知项目组长或直接通知开发者。<br>2) 经验证无误后，修改状态为VERIFIED.待整个产品发布后，修改为CLOSED.<br>3) 还有问题，REOPENED，状态重新变为“New”，并发邮件通知。<br>4) 项目组长根据具体情况，重新reassigned分配给bug所属的开发者。<br>5) 若是，进行处理，resolved并给出解决方法。(可创建补丁附件及补充说明)<br>6) 开发者收到Email信息后，判断是否为自己的修改范围。<br>7) 若不是，重新reassigned分配给项目组长或应该分配的开发者。<br>8) 测试人员查询开发者已修改的bug，进行重新测试。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-什么是软件测试？&quot;&gt;&lt;a href=&quot;#1-什么是软件测试？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是软件测试？&quot;&gt;&lt;/a&gt;1. 什么是软件测试？&lt;/h2&gt;&lt;p&gt;软件测试是为了发现错误而执行程序的过程。或者说，软件测试是根据软件开发各阶段的规格说明和程序的内部结构而精心设计一批测试用例(即输入数据及其预期的输出结果)，并利用这些测试用例去运行程序，以发现程序错误的过程。&lt;/p&gt;
&lt;h2 id=&quot;2-软件测试的目的&quot;&gt;&lt;a href=&quot;#2-软件测试的目的&quot; class=&quot;headerlink&quot; title=&quot;2.  软件测试的目的?&quot;&gt;&lt;/a&gt;2.  软件测试的目的?&lt;/h2&gt;&lt;p&gt;测试的目的是想以最少的人力、物力和时间找出软件中潜在的各种错误和缺陷，通过修正种错误和缺陷提高软件质量，回避软件发布后由于潜在的软件缺陷和错误造成的隐患带来的商业风险。
    
    </summary>
    
      <category term="软件笔记" scheme="http://i90s.vip/categories/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="测试分类" scheme="http://i90s.vip/tags/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>五分钟战胜 Python 字符编码</title>
    <link href="http://i90s.vip/2016/06/28/%E4%BA%94%E5%88%86%E9%92%9F%E6%88%98%E8%83%9C-Python-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    <id>http://i90s.vip/2016/06/28/五分钟战胜-Python-字符编码/</id>
    <published>2016-06-28T15:27:13.000Z</published>
    <updated>2016-06-28T15:29:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于很多接触 Python 的人而言，字符的处理和语言整体的温顺可靠相比显得格外桀骜不驯难以驾驭。</p>
<p>本文不谈复杂的理论，就经验教你字符处理八字真言：确定编码，同类交互。</p>
<p>文章针对 Python 2.7 ，主要因为 3 对的编码已经有了很大的改善并且实际原理一样，更改一下操作命令即可。</p>
<p>了解完本文，你可以轻松解决文字处理，特殊平台（ Windows?）下的编码，爬虫编码等问题。</p>
<p>阅读建议 <a id="more"></a></p>
<p>本文分为如下几个部分：</p>
<blockquote>
<p>原理<br>具体操作<br>建议的使用习惯<br>疑难问题解答</p>
</blockquote>
<p>如果想要了解我给出的使用习惯，可以直接跳到建议的使用习惯。</p>
<p>如果只想要解决相关问题可以直接跳到疑难问题解答。</p>
<p>希望本文能够帮到你。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>为了理解方便，这里不谈理论只做类比，具体想要进一步了解各种编码的理论的搜狗一下好了。</p>
<p>首先说一下我们为什么会碰到各式各样的编码问题：</p>
<p>因为我们没有统一编码<br>因为我们没有用对命令（传对数据）<br>再说一下编码是什么， Python 的编码看似复杂，实际上可以看做只有两类编码： Unicode ，二进制</p>
<p>Unicode 相信都很熟悉：，就是\u0000这样的<br>二进制编码也很简单，就是\x00\x00这样的，平常看到的utf-8,cp936都是二进制编码<br>二进制编码是具象的，10001100原样就可以存储，而 Unicode 是抽象的，不能这样存<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Unicode 编码演示</span></span><br><span class="line">print(<span class="string">'Unicode:'</span>)</span><br><span class="line">print(repr(<span class="string">u'Unicode 编码'</span>))`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二进制编码演示</span></span><br><span class="line">print(<span class="string">u'二进制编码:'</span>)</span><br><span class="line">print(repr(<span class="string">'Unicode 编码'</span>))`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只是看个样子，代码不必去深究</span></span><br></pre></td></tr></table></figure></p>
<p>再说怎么做，就是只有同种编码之间才可以操作</p>
<p>举个简单的类比<br>就把一串数据比为烤鸭，我们作为人和鸭子不同种看待烤鸭的态度完全不一样。<br>我们看到的是晚上的配菜，鸭子看到的是自己二舅。<br>那么我在逛烤鸭店的时候用错编码就会报错。<br>因为我在烤鸭店看到了满世界的二舅。<br>这里说的同种就是我们熟悉的各种编码方式：utf-8,unicode,ucs-bom<br>这也就是编码问题的核心，非常重要。<br>最后说一下 Python 的环境</p>
<p>本身代码是用 Ascii 解码的，文件里有 Ascii 无法解码的内容的话要告知 Python 怎么解码<br>内部大量命令都是默认接受 Unicode<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 告知的命令就是下面这一行，删掉就会报错</span></span><br><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line">print(<span class="string">u'测试编码'</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>拿到各种编码的内容自然是不用说，那么如果我们想要自己构造怎么做呢，看下面：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串前面加 u 会默认构造出 Unicode 的字符串</span></span><br><span class="line">unicodeString = <span class="string">u'Unicode 字符串'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串前面什么都不加会构造出默认编码（首行限定了现在的 utf8 ）的字符串</span></span><br><span class="line">utf8String = <span class="string">'Utf-8 字符串'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然，没有首行，默认的编码是 Ascii</span></span><br><span class="line">那么他们之间怎么转换呢，同样很简单：</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接上一段程序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Unicode 转化为二进制编码中的一种： utf8</span></span><br><span class="line">unicodeString.encode(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二进制编码根据自己的编码种类转化为 Unicode</span></span><br><span class="line">utf8String.decode(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果二进制编码中混进了奇怪的东西可以根据需求用特殊的 decode 策略</span></span><br><span class="line">print(repr(<span class="string">'u8 字\x00 符串'</span>.decode(<span class="string">'utf8'</span>, <span class="string">'replace'</span>)))</span><br><span class="line">那么怎么样会出现问题呢：</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接上一段程序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果我们把他们转化成同样的编码方式就可以操作（例如相加）</span></span><br><span class="line">print(repr(unicodeString + utf8String.decode(<span class="string">'utf8'</span>)))</span><br><span class="line">print(repr(unicodeString.encode(<span class="string">'utf8'</span>) + utf8String))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但如果不转化，当然就会出现满世界的烤鸭二舅啦</span></span><br><span class="line">unicodeString + utf8String</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以另一方面也发现，编码转换是需要我们告诉程序怎么做的</span></span><br><span class="line"><span class="comment"># 所有`decode`操作都会生成 Unicode 编码，这是为了方便我之前说的大量接受 Unicode 的内部命令</span></span><br></pre></td></tr></table></figure></p>
<p>所以我们需要确定程序使用的编码，这是我们需要告诉程序的东西</p>
<p>一方面在操作字符串的时候确定是同种编码<br>另一方面在使用非自己写的命令时，一般使用 Unicode ，或者使用接收二进制编码的命令<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"><span class="comment"># 这里拿写入文件举例</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般使用 Unicode</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'Unicode.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f: f.write(<span class="string">u'Unicode 测试'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用接收二进制编码的命令</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'Utf8.txt'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f: f.write(<span class="string">'Utf8 测试'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 你可以反过来做个测试，自然会报错</span></span><br><span class="line"><span class="comment"># 二进制的命令方便了在不知道怎么解码的情况下也能进行操作（写入文件）</span></span><br></pre></td></tr></table></figure></p>
<p>我建议的使用习惯</p>
<p>相信到这里我已经把我对于编码的理解讲完了。</p>
<p>我们为什么会碰到各式各样的编码问题：</p>
<p>因为我们没有统一编码<br>因为我们没有用对命令（传对数据）<br>所以这里再重申一下八字真言：确定编码，同类交互</p>
<p>碰到问题，问一下自己，我现在是哪种编码<br>同一种编码才能交互，那我应该是哪种编码<br>这里给出我的使用习惯：</p>
<p>确定一种内部编码<br>内部编码的选择优先级如下：程序必须使用的编码、第三方包使用的编码、你喜欢的编码、 Unicode<br>在输出时再更改到特定的编码<br>记得在开始整个程序之前确定内部的编码，否则编码一团糟会产生很多不必要的 bug 。</p>
<p>不要迷信内部 Unicode ，例如 Evernote 开发就应该根据第三方包使用的 Utf8 确定内部编码。</p>
<h2 id="疑难问题解答"><a href="#疑难问题解答" class="headerlink" title="疑难问题解答"></a>疑难问题解答</h2><p>编码识别</p>
<p>说了要确定编码，那么拿到一串二进制要怎么确定编码呢？</p>
<p>最简单的方法是chardet：（需要安装）</p>
<p>python -m pip install chardet<br>使用非常简单：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> chardet <span class="keyword">import</span> detect</span><br><span class="line">print(detect(<span class="string">'这是一串 utf8 的测试字符'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：`&#123;'confidence': 0.99, 'encoding': 'utf-8'&#125;`</span></span><br></pre></td></tr></table></figure></p>
<p>另外例如抓取网站，那么头文件中很有可能有提示如何解码，记得不要忘记了。</p>
<p>编码转换</p>
<p>很可能因为字符串中参杂了奇怪的东西，导致即使编码种类正确，依旧无法解码。</p>
<p>我知道我之前讲过了，但可能有人直接跳疑难问题解答嘛。</p>
<p>这里可以使用decode的第二个参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串中混进了\x00</span></span><br><span class="line">rubbishUtf8String = <span class="string">'Utf-8 字\x00 符串'</span></span><br><span class="line"></span><br><span class="line">print(repr(rubbishUtf8String.decode(<span class="string">'utf8'</span>, <span class="string">'replace'</span>)))</span><br><span class="line"></span><br><span class="line">print(repr(rubbishUtf8String.decode(<span class="string">'utf8'</span>, <span class="string">'ignore'</span>)))</span><br></pre></td></tr></table></figure></p>
<p>特殊平台下编码</p>
<p>很多人都说 Windows 是个坑，即使在 Python 3 下面也一样。</p>
<p>因为中文文件名出来都是乱码。</p>
<p>这里使用一个取巧的方法：平台编码再特殊，起码命令行读取和创建一个文件夹不会出乱码吧。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> folder <span class="keyword">in</span> os.walk(<span class="string">'.'</span>).next()[<span class="number">1</span>]:</span><br><span class="line">    print(folder.decode(sys.stdin.encoding))</span><br><span class="line">同样的输入输出也可以这样做优化：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sys_print</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(msg.encode(sys.stdin.encoding))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sys_input</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> raw_input(msg.encode(sys.stdin.encoding)).decode(sys.stdin.encoding)</span><br></pre></td></tr></table></figure></p>
<p>文件写入</p>
<p>如果抓下来一个内容不知道怎么解码，但还是想要写入文件怎么办</p>
<p>写入文件的时候制定用二进制命令即可：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line">import urllib</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'Utf8.txt'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f: f.<span class="built_in">write</span>(<span class="string">'Utf8 测试'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比如抓了个网页，不知道编码也可以写入文件进行一系列操作</span></span><br><span class="line"></span><br><span class="line">content = urllib.urlopen(<span class="string">'http://www.baidu.com'</span>).<span class="built_in">read</span>()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'baidu.txt'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f: f.<span class="built_in">write</span>(content)</span><br></pre></td></tr></table></figure></p>
<p>裸 Unicode 字符</p>
<p>Unicode 存成六个 Ascii 字符怎么办？其实也可以decode<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"><span class="comment"># 这是普通的 Unicode</span></span><br><span class="line">s = <span class="string">u'测'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s: print(i)</span><br><span class="line">print(repr(s))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是裸 Unicode ，实际存成了六个 Ascii</span></span><br><span class="line">s = repr(s)[<span class="number">2</span>:<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s: print(i)</span><br><span class="line">print(repr(s))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转化其实也很简单</span></span><br><span class="line">s = s.decode(<span class="string">'unicode-escape'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s: print(i)</span><br><span class="line">print(repr(s))</span><br></pre></td></tr></table></figure></p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>希望读完这篇文章能对你有帮助，有什么不足之处万望指正（鞠躬）。</p>
<p>有什么想法或者想要关注我的更新，欢迎来Github上Star或者Fork我的项目。</p>
<p>160623</p>
<p>LittleCoder</p>
<p>EOF<br><a href="http://www.v2ex.com/t/287727#reply23" target="_blank" rel="external">转载自V2EX</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于很多接触 Python 的人而言，字符的处理和语言整体的温顺可靠相比显得格外桀骜不驯难以驾驭。&lt;/p&gt;
&lt;p&gt;本文不谈复杂的理论，就经验教你字符处理八字真言：确定编码，同类交互。&lt;/p&gt;
&lt;p&gt;文章针对 Python 2.7 ，主要因为 3 对的编码已经有了很大的改善并且实际原理一样，更改一下操作命令即可。&lt;/p&gt;
&lt;p&gt;了解完本文，你可以轻松解决文字处理，特殊平台（ Windows?）下的编码，爬虫编码等问题。&lt;/p&gt;
&lt;p&gt;阅读建议
    
    </summary>
    
      <category term="软件笔记" scheme="http://i90s.vip/categories/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="转载" scheme="http://i90s.vip/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="python" scheme="http://i90s.vip/tags/python/"/>
    
      <category term="字符编码" scheme="http://i90s.vip/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>测试分类</title>
    <link href="http://i90s.vip/2016/06/13/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"/>
    <id>http://i90s.vip/2016/06/13/测试分类/</id>
    <published>2016-06-13T14:48:16.000Z</published>
    <updated>2016-06-14T12:41:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本篇博文属于对软件测试领域的科普篇，关于软件测试领域，名词颇多，发现有许多测试新手混淆概念，甚至有不少招聘要求中对各种软件测试相关的名词乱用，所以，这里汇总测试相关的名词，也许能理清你对各种名词的概念。</p>
</blockquote>
<h2 id="根据项目流程阶段划分测试"><a href="#根据项目流程阶段划分测试" class="headerlink" title="根据项目流程阶段划分测试  "></a>根据项目流程阶段划分测试  <a id="more"></a></h2><hr>
<p><img src="http://ww1.sinaimg.cn/large/666cc9e3gw1f4tzicsxz2j20df08e74e.jpg" alt=""><br>上图是一个典型瀑布式软件开发流程，那么各项软件测试工作是在项目开发流程中循序渐进的进行的。下面将介绍下测试的含义。</p>
<p><strong>单元测试：</strong> 单元测试是对软件中的基本组成单元进行的测试。目的是检验软件基本组成单位的正确性。</p>
<p><strong>集成测试：</strong>集成测试是在软件系统集成过程中所进行的测试。目的是检查软件单位之间的接口是否正确。</p>
<p><strong>系统测试：</strong>系统测试是对已经集成好的的软件系统进行彻底的测试，以验证软件系统的正确性和性能等是否满足其规约所指定的要求。</p>
<p><strong>验收测试：</strong>验收测试是部署软件之前的最后一个测试操作。验收测试的目的是确保软件准备就绪，向软件购买商展示该软件系统满足其用户的需求。</p>
<h2 id="单元测试阶段"><a href="#单元测试阶段" class="headerlink" title="单元测试阶段"></a>单元测试阶段</h2><p><strong> 模块接口测试 </strong><br>　　  通过所测模块的数据流进行测试。调用所测模块时参数与模块的形式参数的个数、属性和顺序是否匹配。</p>
<p><strong> 局部数据结构测试 </strong><br>　　局部数据结构是为了保证临沭存储在模块内的数据在程序执行过程中完整、正确、模块的局部数据结构往往是错误的根源。</p>
<p><strong> 路径测试 </strong><br>　　对模块中重要的执行路径进行测试。</p>
<p><strong> 错误处理测试 </strong><br>　　比较完善的模块设计要求能遇见出错的条件，并设置是党的出错处理，以便在程序出错时，能够对出错程序重做安排，保证其逻辑上的正确性。</p>
<p><strong> 边界条件测试 </strong><br> 　　软件经常在边界上失效，边界条件测试是一项基础测试，也是后面系统测试中的功能测试的重点。</p>
<h2 id="集成测试阶段："><a href="#集成测试阶段：" class="headerlink" title="集成测试阶段："></a>集成测试阶段：</h2><p>在集成测试中，我们主要关注以下内容：</p>
<ol>
<li>把各个模块连接起来时，穿越模块接口的数据是否会丢失。</li>
<li>各个子模块组合起来，能否达到预期要求的功能。</li>
<li>一个模块的功能是否会对另外一个模块的功能产生不利影响。</li>
<li>全局数据结构是否有问题。</li>
<li>单个模块的误差积累起来是否会被放大，从而达到不可接受的程度。</li>
</ol>
<h2 id="系统测试阶段："><a href="#系统测试阶段：" class="headerlink" title="系统测试阶段："></a>系统测试阶段：</h2><p>　　一般系统的主要测试工作都是集中在系统测试阶段。根据不同的系统所进行的测试种类也很多。</p>
<p><strong> 功能测试 </strong><br>　　功能测试是对产品的各项功能进行验证，一检查是否满足需求的要求。</p>
<p><strong> 性能测试 </strong><br>　　性能测试是通过自动化测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。</p>
<p><strong> 安全测试 </strong><br>   　　安全测试检查系统对非法入侵的防范能力。</p>
<p><strong> 兼容测试 </strong><br>　　兼容性测试主要是测试系统在不同的软硬件环境下是否能够正常的运行。</p>
<h2 id="验收测试阶段："><a href="#验收测试阶段：" class="headerlink" title="验收测试阶段："></a>验收测试阶段：</h2><p>功能确认测试<br>安全可靠性测试<br>易用性测试<br>可扩充性测试<br>兼容性测试<br>资源占有率测试<br>用户文档资料验收</p>
<hr>
<h2 id="白盒测试、黑盒测试、灰盒测试"><a href="#白盒测试、黑盒测试、灰盒测试" class="headerlink" title="白盒测试、黑盒测试、灰盒测试"></a>白盒测试、黑盒测试、灰盒测试</h2><hr>
<p>　　上面是根据项目流程按照测试的各个阶段对测试工具的划分。白盒测试与黑盒测试，主要是测试工作对软件代码的可见程度的划分。这也是测试软件邻居中最基本的两个概念。</p>
<p><strong> 黑盒测试 </strong><br>　　黑盒测试，指的是把被测的软件看做是一个黑盒子，我们不去关心盒子里面的结构式什么样子的，只关心软件的输入数据和输出结果。<br>　　它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当的接受输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。</p>
<p><strong> 白盒测试 </strong><br>　　白盒测试，只的是把盒子盖子打开，去研究里面的源代码和程序结果。<br>　　它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常运行，检验程序中的每条通路是否都能按照预定要求正确工作。</p>
<p><strong> 灰盒测试 </strong><br>　　灰盒测试街与黑盒测试和白盒测试之间。<br>　　可以这样理解，灰盒测试关注输出对于输入的正确性，同时也关注内部表现，但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、时间、判断来判断内部的运行状态，有时候输出是正确的，但内部其实已经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采用这样的一种灰盒的方法。</p>
<hr>
<h2 id="功能测试、性能测试"><a href="#功能测试、性能测试" class="headerlink" title="功能测试、性能测试"></a>功能测试、性能测试</h2><hr>
<p><strong> 功能测试 </strong><br>　　功能测试检查实际的功能是否符合用户的需求。测试的大部分工作也是围绕软件的功能进行，设计软件的目的也是满足客户对其功能的需求。如果偏离这个目的的任何测试工作都是没有意义的。<br>　　功能测试又可以分为很多种：逻辑功能测试、界面测试、易用性测试、安装测试、兼容性测试等。</p>
<p><strong> 性能测试 </strong><br>　　性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。<br>　　软件的性能包括很多方面，主要有时间性能和空间性能两种。<br>　　<strong>时间性能：</strong>主要是指软件的一个经营体的响应时间。比如一个登录所需要的时间，一个交易所需要的时间等。当然，抛开具体的测试环境，来分析一次事物的响应时间是没有任何意义的。需要搭建一个具体且独立的测试环境。<br>　　<strong>空间性能：</strong>主要是指软件运行时所小号的系统资源，比如硬件资源，CPU、内存，网络带宽消耗等。</p>
<hr>
<h2 id="手工测试与自动化测试"><a href="#手工测试与自动化测试" class="headerlink" title="手工测试与自动化测试"></a>手工测试与自动化测试</h2><hr>
<p><strong> 手工测试： </strong><br>　　手工测试就是由人去一个一个的去执行测试用例，通过鼠标键盘等输如一些参数，查看返回结果是否符合预期结果。<br>（其实，不太喜欢别人把一般的功能测试工作叫手工测试，就像一个雕塑家不喜欢别人叫他刻石头的一样。手工测试同样需要业务熟悉、基本测试方法的理解。看似简单的工作却能够发现别人不能发现的软件问题。在目前的测试领域，手工测试仍然是无法替代的一种测试方法）</p>
<p><strong> 自动化测试： </strong><br>　　自动化测试是把以人为驱动的测试行为转化为机器执行的一种过程。通常，在设计了测试用例并通过评审之后，由测试人员根据测试用例中描述的规程一步步执行测试，得到实际结果与期望结果的比较。在此过程中，为了节省人力、时间或硬件资源，提高测试效率，便引入了自动化测试的概念。 </p>
<p>　　自动化测试：又可分为功能自动化测试与性能自动化测试。</p>
<p>　　我们一般所说的自动化测试就是指功能自动化测试，通过相关的测试技术，通过编码的方式用一段程序来测试一个软件的功能，这样就可以重复执行程序来进行重复的测试。如果一个软件一小部分发生改变，我们只要修改一部分代码，就可以重复的对整个软件进行功能测试。这样就大大的提高了测试效率。</p>
<p>　　性能自动化测试，当然，除了早期阶段，现在的性能测试工作都是通过性能测试工具辅助完成的。能过工具可以模拟成千上万的用户向系统发送请求，用来验证系统的处理能力。</p>
<hr>
<h2 id="冒烟测试、回归测试、随机测试"><a href="#冒烟测试、回归测试、随机测试" class="headerlink" title="冒烟测试、回归测试、随机测试"></a>冒烟测试、回归测试、随机测试</h2><hr>
<p>这三种测试在软件功能测试过程中，既不算具体明确的测试阶段也不算是具体的测试方法。</p>
<p><strong> 冒烟测试：</strong></p>
<p>　　是指在对一个新版本进行系统大规模的测试之前，先验证一下软件的基本功能是否实现，是否具备可测性。</p>
<p>　　引入到软件测试中，就是指测试小组在正规测试一个新版本之前，先投入较少的人力和时间验证一个软件 的主要功能，如果主要功能都没有实现，则打回开发组重新开发。这样做的好处是可以节省大量的时间成本和人力成本。</p>
<p><strong> 回归测试： </strong></p>
<p>　　回归测试是指修改了旧代码后，重新时行测试以确认修改后没有引入新的错误或导致其他代码产生错误。</p>
<p>　　回归测试一般是在进行软件的第二轮测试开始的，验证第一轮中发现的问题是否得到修复。当然，回归也是一个循环的过程，如果回归的问题通不过，则需要开发人员修改后再次进行回归，直到通过为止。</p>
<p><strong> 随机测试： </strong></p>
<p>　　是指测试中的所有输入数据都是随机生成的，其目的是模拟用户的真实操作，并发现一些边缘性的错误。</p>
<p>　　随机测试可以发现一些隐蔽的错误，但是也有很多缺点，比如测试不系统，无法统计代码覆盖率和需求覆盖率，发现的问题难以重现。一般是放在测试的最后执行。其实随机测试更专业的升级版叫 探索性测试</p>
<hr>
<p><strong>探索性测试</strong></p>
<p>　　探索性测试可以说是一种测试思维技术。它没有很多实际的测试方法、技术和工具，但是却是所有测试人员都应该掌握的一种测试思维方式。探索性强调测试人员的主观能动性，抛弃繁杂的测试计划和测试用例设计过程，强调在碰到问题时及时改变测试策略。 </p>
<p>　　探索性测试应该是未来测试领域的一个方向。</p>
<p><strong>安全测试</strong></p>
<p>　　安全测试是在IT软件产品的生命周期中，特别是产品开发基本完成到发布阶段，对产品进行检验以验证产品符合安全需求定义和产品质量标准的过程。 </p>
<p>　　安全测试也在越来越受到企业的关注和重视，因为由于安全性问题造成的后果是不可估量的。尤其对于互联网产品最容易遭受各种安全攻击。</p>
<p><strong><a href="http://www.cnblogs.com/fnng/archive/2012/10/24/2737972.html" target="_blank" rel="external">转载自虫师的博客</a></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本篇博文属于对软件测试领域的科普篇，关于软件测试领域，名词颇多，发现有许多测试新手混淆概念，甚至有不少招聘要求中对各种软件测试相关的名词乱用，所以，这里汇总测试相关的名词，也许能理清你对各种名词的概念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;根据项目流程阶段划分测试&quot;&gt;&lt;a href=&quot;#根据项目流程阶段划分测试&quot; class=&quot;headerlink&quot; title=&quot;根据项目流程阶段划分测试  &quot;&gt;&lt;/a&gt;根据项目流程阶段划分测试
    
    </summary>
    
      <category term="软件笔记" scheme="http://i90s.vip/categories/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="转载" scheme="http://i90s.vip/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="测试分类" scheme="http://i90s.vip/tags/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>浅说软件需求分析</title>
    <link href="http://i90s.vip/2016/06/12/%E6%B5%85%E8%AF%B4%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
    <id>http://i90s.vip/2016/06/12/浅说软件需求分析/</id>
    <published>2016-06-12T14:29:41.000Z</published>
    <updated>2016-06-13T14:54:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是需求分析"><a href="#什么是需求分析" class="headerlink" title="什么是需求分析"></a>什么是需求分析</h2><hr>
<p>　　通俗的讲，对用户的意图不断揭示和验叛的过程，要对经过系统可行性分析所确定的系统目标做更为详细的描述。</p>
<p>　　假如你是个建筑工程师，有个客户找你建一个鸡窝，这个时候要需要与客户沟通，来确定客户到底想要一个什么样子的鸡窝。我们应该注意三点：</p>
<p><strong>1 .  准确的理解和描述客户需要的功能。</strong><a id="more"></a></p>
<p>　　客户说，我的鸡窝要三层的，带电梯，饮水池，厕所，饮水池要自动判断水位供水，电梯要可以同时乘坐10只鸡….客户滔滔不绝的讲了一大堆，你也都非常忠实的按照自己的理解再一一的向客户描述一遍，以便于确认客户的需求是否正确。</p>
<p><strong>2 .  帮助客户挖掘需求。</strong></p>
<p>　　等客户把自己的需求说完了，你发现客户没有说鸡的卧室，于是，你向客户提议说：“你看，这鸡的卧室要什么样子的？”，客户连连的拍着脑门说，我差点给忘记了，鸡们啊喜欢晚上在一起聊天，所以呢，需要一个长而大的卧室，但一定要舒适。</p>
<p><strong>3 . 分析客户需求的可行性</strong></p>
<p>　　客户临走时又说，最近了，黄鼠狼很多，我这个鸡窝啊，一楼就不用盖了，直接盖二楼和三楼吧！以免晚上遭遇黄鼠狼的攻击。你这么一分析，客户这要求，按照目前的技术可没法建啊，于是，你向客户提议，一楼采用坚固架子来支撑二三楼的建筑。</p>
<hr>
<h2 id="需求分析困难在哪儿？"><a href="#需求分析困难在哪儿？" class="headerlink" title="需求分析困难在哪儿？"></a>需求分析困难在哪儿？</h2><hr>
<p>有几种原因使需求分析变得困难：（1）客户说不清楚需求；（2）需求自身经常变动；（3）分析人员或客户理解有误。</p>
<p><strong>1 . 客户说不清楚需求</strong></p>
<p> 　　有些客户对需求只有朦胧的感觉，当然说不清楚具体的需求。例如全国各地的很多政府机构在搞网络建设，这些单位的领导和办公人员大多不清楚计算机网络有什么用，反而要软件系统分析人员替他们设想需求。这类工程的需求是如此的主观，以致产生很多贪污腐败现象。<br>　　有些客户心里非常清楚想要什么，但却说不明白。你可能很不以为然。就举日常生活的事例吧，比如说买鞋子。我们非常了解自已的脚，但没法说清楚脚的大小和形状。只能拿鞋子去试，试穿时感觉到舒服才会买鞋（居然也有神通广大的售货员，看一眼客户的手，就知道应该穿什么样的鞋）。<br>　　如果客户本身就懂软件开发，能把需求说得清清楚楚，这样的需求分析将会非常轻松、愉快。如果客户全不懂软件，但信任软件开发方，这事也好办。分析人员可以引导客户，先阐述常规的需求，再由客户否定不需要的，最终确定客户真正的需求。最怕的就是“不懂装懂”或者“半懂充内行”的客户，他们会提出不切实际的需求。如果这些客户甚至觉得自己是上帝的爸爸，那么沟通和协商都会很困难。</p>
<p><strong>2 . 需求自身经常变动  </strong></p>
<p> 　　唐僧曾说：“妖要是有了仁慈之心，就不再是妖，是人妖。”（《大话西游之大圣娶亲》）<br>　　连妖都会变心，别说人了。所以喜新厌旧乃人之常情，世界也因此变得多姿多彩。<br>　　软件的需求会变化吗？<br>　　答：据历史记载，没有一个软件的需求改动少于三次。唯一只改动需求两次的客户是个死人。这个可怜的家伙还是在运送第三次需求的路上被车子撞死的。[Cline 1995]<br>让我们先接受“需求会变动”这个事实吧，免得在需求变动时惊慌失措。明白“需求会变动”这个道理后，在进行需求分析时就要留点神：<br>　　（1）尽可能地分析清楚哪些是稳定的需求，哪些是易变的需求。以便在进行系统设计时，将软件的核心建筑在稳定的需求上，否则将会吃尽苦头。</p>
<p>　　（2）在合同中一定要说清楚“做什么”和“不做什么”。如果合同含含糊糊，日后扯皮的事情就多。要防止象韩复渠那样，在别人请他喝酒吃饭时他什么都点头（人家就更加献殷勤），吃完了他就宣布刚才答应的事都不算数，便扬长而去。</p>
<p><strong>3 .  分析人员和顾客理解有误</strong></p>
<p>　　有个外星人间谍潜伏到地球刺探情报，它给上司写了一份报告：“主宰地球的是车。它们喝汽油，靠四个轮子滚动前进。嗓门极大，在夜里双眼能射出强光。……有趣的是，车里住着一种叫作‘人’的寄生虫，这些寄生虫完全控制了车。”<br>　　软件系统分析人员不可能都是全才。客户表达的需求，不同的分析人员可能有不同的理解。如果分析人员理解错了，可能会导致开发人员白干活，吃力不讨好。我读中学时候最怕写作文逃题，如果逃题了，不管作文写得多长，总是零分。所以分析人员写好需求说明书后，要请客户方的各个代表验证。如果问题很复杂，双方都不太明白，就有必要请开发人员快速构造软件的原型，双方再次论证需求说明书是否正确。<br>　　由于客户大多不懂软件，他们可能觉得软件是万能的，会提出一些无法实现的需求。有时客户还会把软件系统分析人员的建议或答复给想歪了。<br>　　有一个软件人员滔滔不绝地向客户讲解在“信息高速公路上做广告”的种种好处，客户听得津津有味。最后，心动的客户对软件人员说：“好得很，就让我们马上行动起来吧。请您决定广告牌的尺寸和放在哪条高速公路上，我立即派人去做。”</p>
<hr>
<h2 id="需求分析的分类"><a href="#需求分析的分类" class="headerlink" title="需求分析的分类"></a>需求分析的分类</h2><hr>
<p>需求分析一般可分为功能需求、非功能需求和领域需求</p>
<p><strong>1 . 功能需求：</strong></p>
<p>　　 功能需求主要说明了系统实际应做到什么。这是用户最直观也是最主要的需求，如系统的输入输出、系统能完成的功能以及其它相关处理等；</p>
<p><strong>2 . 非功能需求：</strong><br>　　非功能需求又称“约束”，它主要从各个角度对系统起约束和限制作用。如响应时间、存储效率、报表的规格和界面的样式等<br><strong>3 . 领域需求：</strong><br>　　领域需求的来源不是用户，而是系统应用的领域，其主要反映了该领域的基本问题。例如勤工俭学管理系统，其领域需求就涉及到诸如应聘合同书、酬金发放及劳工考核等相关内容，如果这些需求得不到满足，系统就无法正常运行。值得一提的是，领域需求可能是功能需求，也可能是非功能需求。</p>
<hr>
<h2 id="如何进行需求分析"><a href="#如何进行需求分析" class="headerlink" title="如何进行需求分析"></a>如何进行需求分析</h2><p>　　进行需求分析不象情人之间的浪漫做法——“让我摸摸你的头发，感觉它是什么颜色。”我们需要了解需求分析的渠道和过程。<br><img src="http://ww1.sinaimg.cn/large/666cc9e3gw1f4tzk5dph6j20cp08u3z2.jpg" alt=""><br>需求分析的过程<br><img src="http://ww1.sinaimg.cn/large/666cc9e3gw1f4tzkrwicxj20cj06yweu.jpg" alt=""><br><strong>（1）可行性研究</strong></p>
<p>　　它指明现有的软件、硬件技术能否实现用户对系统的要求，从业务角度来决定系统开发是否可行以及在预算范围内能否开发出来。可行性研究的结果是清楚的回答：该系统是否值得开发</p>
<p><strong>（2）需求导出和分析</strong></p>
<p>　　这是一个通过对现有系统分析、与潜在客户讨论、进行任务分析等导出系统需求的过程，也可能需要开发一个或多个不同的系统原型，以帮助分析员了解所要描述的系统。</p>
<p><strong>（3）需求描述</strong></p>
<p>　　需求描述就是把在分析活动中收集的信息通过分析整理之后以文档的形式确定下来。该文档中有两类需求：用户需求是从客户和最终用户角度对系统需求的抽象描述；系统需求是对系统要提供的功能的详尽描述。</p>
<p><strong>（4）需求有效性验证</strong></p>
<p>　　主要是通过评审、验证等一系列活动来找出需求文档中的错漏并加以改正。</p>
<p><strong>（5）需求管理</strong></p>
<p>　　需求管理需求管理是一种系统化方法，可用于获取、组织和记录系统需求并使用户和开发方在系统变更需求上始终保持一致</p>
<hr>
<h2 id="需求分析的方法"><a href="#需求分析的方法" class="headerlink" title="需求分析的方法"></a>需求分析的方法</h2><p><strong>1 .  功能分析方法</strong></p>
<p>　　那怕是天下最无能的市长或书记，都知道在作报告时要先从宏观上讲一、二、三、四、五，再从细节上讲 A、B、C、D、E；需求分析不象侦探推理那样从蛛丝马迹着手。应该先了解宏观的问题，再了解细节的问题。</p>
<p>　　功能分析法功能分解法以系统提供的功能为中心来组织系统。首先定义各种功能, 然后把功能分解为子功能, 同时定义功能之间的接口。数据结构是根据功能/子功能的需要设计的。 其基本策略是以分析员的经验为依据, 确定新系统所期望的处理步骤或子步骤, 然后, 将问题空间映射到功能和子功能上。</p>
<p><strong>2 . 数据流方法</strong></p>
<p>　　周末，小明一觉醒来突然想吃红烧肉，那想得口水直流，于起床，穿好衣服，打开钱包一看空的，好吧，先去银行取钱，然后去菜那买了一肉、各种配料，然后回家，开火，各种材料往锅里一放，开始小火慢炖，半个小时后，小明终于吃上了美味可口的红烧肉。这是一个典型的流程，如果把它看成一个系统功能的话，那么小明吃到红烧肉是这个功能的目的，那么中间要经历许多环节，起床穿衣—取钱—习材料—-制作完成。而且各个功能（步骤）之间是相互联系的，小明总不能不穿衣服直接去取钱吧。</p>
<p>　　数据流法也叫结构化分析, 其基本策略是研究问题域中数据如何流动以及在各个环节上进行何种处理, 从而发现数据流和加工。 问题域被映射为由数据流、加工以及文件、端点等成份构成的数据流图(DFD) , 并用数据字典对数据流和加工进行详细说明。这种方法的关键是动态跟踪数据流动。</p>
<p><strong>3 . 信息建模方法</strong></p>
<p>　　一个贵妇去报案，我丢了一个辆车，小明是警察，然后问贵妇，你丢的什么样的车子？贵妇噼里啪啦的给小明描述车子样子：我的车子有四个轮子，前面两个小，后面两个大，车身是流线型的，后面带尾翼，里面只一排坐位的那种，车坐上都用的真皮做套子，后面…..你听着听头大了，然后对贵妇说：等等，我给你画下来。于是，贵妇边说，你边画，然后贵妇指出画的不对的地方由你来修改。当然了这只是实体的样子。我们还需要知道汽车各个部件的功能以及各部件之间的关系。</p>
<p>　　信息建模法的核心概念是实体和关系, 主要工具是语义数据模型(实体关系图) , 其基本策略是找出现实世界的对象, 然后用属性来描述对象, 增添对象与对象之间的关系, 定义父类与子类, 用父类型/子类型提炼属性的共性, 用关联对象关系作细化的描述, 最后进行规范化处理。 其实质是将问题空间直接映射成模型中的对象。</p>
<p> —-下面三种方法，我还不能理解—–</p>
<p><strong>4 .   面向对象方法</strong></p>
<p>　　我想你如果学习过面向对象编程的话，会很容易理解。</p>
<p>　　面向对象分析 OOA(Object- Oriented Analysis) 的基本策略是通过信息隐藏将比较容易变化的元素隐藏起来, 分析员基于比较稳定的元素建立其思想和规格说明的总体结构。</p>
<p>　　面向对象分析的主要特性是加强了对问题域( Problem Domain) 和系统责任( System Responsibili-ties)的理解; 改进与分析有关的各类人员之间的交流; 对需求的变化具有较强的适应性; 支持软件复用</p>
<p><strong>5 . 面向本体方法</strong></p>
<p>　　面向本体的需求分析 OORA (Ontology- Oriented Require-ments Analysis) , 是 OOA方法的有效补充和提升。 面向本体方法强调相关领域的本质概念以及这些概念之间的关联。其实质是在面向对象方法中引入对象关联, 并给出各种关联的语义语用。</p>
<p>　　OORA方法由 4 个阶段来完成。第一阶段: 用一种自然语言BIDL( Bisiness Information Description Language) 描述事务; 第二阶段: 确认隐含在 BIDL文本中的本体和对象; 第三阶段: 将这些本体和对象转换成另一种语言 Ononet (Ontology and Object- Ori-ented Network) , 得到用 Ononet 书写的需求预定义; 第四阶段: 在采用 Ononet 作为知识表示形式的领域本体知识库中搜索相关的知识, 并和前面的需求预定义合并, 得到软件完整的需求定义。</p>
<p>6 . 形式化方法</p>
<p>　　形式化方法, 广义上讲, 是应用数学的手段来设计、 模拟和分析, 得到像数学公式那样精确的表示。从狭义上讲, 就是使用一种形式语言进行语言公式的形式推理, 用于检查语法的良构性并证明某些属性。在需求分析阶段, 利用形式化方法得到需求规格说明书, 可以规范软件开发过程, 为获得更好的系统性能提供重要保证。</p>
<p>=======粗俗的方法=======<br>可能你对上面的方法看不懂，起码后三种我是看不懂的，怪我知识太少的缘故。</p>
<p>我们来看下面了解需求的方式：</p>
<p>（1）直接与客户交谈。如果分析人员生有足球评论员的那张“大嘴”，就非常容易侃出需求。</p>
<p>（2）有些需求客户讲不清楚，分析人员又猜不透，这时就要请教行家。有些高手真的很厉害，你还没有开始问，他就能讲出前因后果。让你感到“听君一席言，胜读十年书。”</p>
<p>（3）有很多需求可能客户与分析人员想都没有想过，或者想得太幼稚。要经常分析优秀的和蹩脚的同类软件，看到了优点就尽量吸取，看到了缺点就引以为戒。前人既然付了学费，后人就不要拒绝坐享其成。</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><blockquote>
<p>《关于软件需求分析的研究》–邱树伟<br> 《软件工程思想》–林锐</p>
</blockquote>
<p><strong><a href="http://www.cnblogs.com/fnng/archive/2011/09/13/2174268.html" target="_blank" rel="external">转载自虫师的博客</a></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是需求分析&quot;&gt;&lt;a href=&quot;#什么是需求分析&quot; class=&quot;headerlink&quot; title=&quot;什么是需求分析&quot;&gt;&lt;/a&gt;什么是需求分析&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;　　通俗的讲，对用户的意图不断揭示和验叛的过程，要对经过系统可行性分析所确定的系统目标做更为详细的描述。&lt;/p&gt;
&lt;p&gt;　　假如你是个建筑工程师，有个客户找你建一个鸡窝，这个时候要需要与客户沟通，来确定客户到底想要一个什么样子的鸡窝。我们应该注意三点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1 .  准确的理解和描述客户需要的功能。&lt;/strong&gt;
    
    </summary>
    
      <category term="软件笔记" scheme="http://i90s.vip/categories/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="转载" scheme="http://i90s.vip/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="需求分析" scheme="http://i90s.vip/tags/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>pythonの生成正交测试数据</title>
    <link href="http://i90s.vip/2016/05/30/python%E3%81%AE%E7%94%9F%E6%88%90%E6%AD%A3%E4%BA%A4%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/"/>
    <id>http://i90s.vip/2016/05/30/pythonの生成正交测试数据/</id>
    <published>2016-05-30T14:14:41.000Z</published>
    <updated>2016-05-30T14:21:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h2><hr>
<p> 输入为数组，如下所示：<br>a=[[1,2,3],[4,5],[6,7]]<br>a[0],a[1],a[2]···表示各个因素，此时表示a有四个因素<br>a[0]=[1,2,3]表示a[0]有三个值可以选</p>
<hr>
<p>输出为数组，如下所示：<a id="more"></a><br>b= [[1, 4, 6], [1, 5, 7], [2, 4, 7], [2, 5, 6]]<br>b[0],b[1]···表示正交法生成的测试数据</p>
<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><h3 id="output-oracle-py"><a href="#output-oracle-py" class="headerlink" title="output_oracle.py"></a>output_oracle.py</h3><blockquote>
<p>获取数组的因素数和水平数<br>调用Ort_model.py函数 返回相应的正交表<br>将输入数据替换正交表内数 生成正交测试数据</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Ort_model</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ORT_EXPRESSION</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Output_Ort</span><span class="params">(self,input_array)</span>:</span></span><br><span class="line">        self.in_array=input_array</span><br><span class="line">        i_Factors_temp=len(self.in_array)   <span class="comment">#因素数</span></span><br><span class="line">        i_array=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(i_Factors_temp)]</span><br><span class="line">        <span class="comment">#求取水平数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,i_Factors_temp):</span><br><span class="line">            i_array[i]=len(self.in_array[i])</span><br><span class="line">        i_array_temp=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> i_array:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> i_array_temp:</span><br><span class="line">                i_array_temp[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i_array_temp[i] += <span class="number">1</span> </span><br><span class="line">        i_levels_temp=max(i_array_temp.iteritems(), key = <span class="keyword">lambda</span> x: x[<span class="number">1</span>])[<span class="number">0</span>]  <span class="comment">#水平数       </span></span><br><span class="line">        <span class="comment">#正交模型</span></span><br><span class="line">        Model_Ort=Ort_model.ORT_MODEL()</span><br><span class="line">        return_ort=Model_Ort.Ort_mod(i_Factors_temp,i_levels_temp)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> return_ort:</span><br><span class="line">            msg=<span class="string">'input is wrong'</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>,msg,<span class="string">''</span>]</span><br><span class="line">        <span class="comment">#带入数值</span></span><br><span class="line">        i_L=len(return_ort)</span><br><span class="line">        i_Factors=len(return_ort[<span class="number">0</span>])</span><br><span class="line">        return_array = [[<span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> range(i_Factors)] <span class="keyword">for</span> row <span class="keyword">in</span> range(i_L)]  </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i_Factors):</span><br><span class="line">            l_n=[x[j] <span class="keyword">for</span> x <span class="keyword">in</span> return_ort]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(l_n)):</span><br><span class="line">                <span class="keyword">if</span> l_n[i]&lt;len(self.in_array[j]):               </span><br><span class="line">                    return_array[i][j]=self.in_array[j][l_n[i]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    return_array[i][j]=random.choice(self.in_array[j])  <span class="comment">#使用随机函数选择当前可选数据</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>,<span class="string">''</span>,return_array]</span><br></pre></td></tr></table></figure>
<h3 id="Ort-model-py"><a href="#Ort-model-py" class="headerlink" title="Ort_model.py"></a>Ort_model.py</h3><blockquote>
<p>根据因素数和水平数 得到相应的正交表</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ORT_MODEL</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.L4=[</span><br><span class="line">                [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">                [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">                ]  <span class="comment">#2 3 </span></span><br><span class="line">        self.L8=[</span><br><span class="line">                [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">                [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">                [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">                [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">                ] <span class="comment">#2 7</span></span><br><span class="line">        self.L9=[</span><br><span class="line">                [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                [<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">                [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">                [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>],</span><br><span class="line">                [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">                [<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">                [<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>],</span><br><span class="line">                [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">                ]<span class="comment">#3 4</span></span><br><span class="line">        self.L16=[</span><br><span class="line">                 [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                 [<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">                 [<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">                 [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">                 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">                 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">                 [<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">                 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>],</span><br><span class="line">                 [<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">                 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>],</span><br><span class="line">                 [<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">                 [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>],</span><br><span class="line">                 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>],</span><br><span class="line">                 [<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">                 ]<span class="comment">#4 5</span></span><br><span class="line">        self.L25=[</span><br><span class="line">                  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">                  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">                  [<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>],</span><br><span class="line">                  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>],</span><br><span class="line">                  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">                  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">                  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">                  [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                  [<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">                  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>],</span><br><span class="line">                  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],</span><br><span class="line">                  [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>],</span><br><span class="line">                  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>],</span><br><span class="line">                  [<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">                  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],</span><br><span class="line">                  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>],</span><br><span class="line">                  [<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>],</span><br><span class="line">                  [<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">                  [<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>],</span><br><span class="line">                  [<span class="number">5</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">                  [<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>],</span><br><span class="line">                  [<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>],</span><br><span class="line">                  [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>],</span><br><span class="line">                  [<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">                  ]<span class="comment">#5 6</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Ort_mod</span><span class="params">(self,i_factors,i_levels)</span>:</span></span><br><span class="line">        self.i_fac=i_factors</span><br><span class="line">        self.i_lev=i_levels</span><br><span class="line">        <span class="keyword">if</span> (self.i_fac==<span class="number">3</span> <span class="keyword">and</span> self.i_lev&lt;=<span class="number">2</span>):<span class="comment">#2 3 </span></span><br><span class="line">            <span class="keyword">return</span> self.L4</span><br><span class="line">        <span class="keyword">if</span> (self.i_fac==<span class="number">7</span> <span class="keyword">and</span> self.i_lev&lt;=<span class="number">2</span>):<span class="comment">#2 7</span></span><br><span class="line">            <span class="keyword">return</span> self.L8</span><br><span class="line">        <span class="keyword">if</span> (self.i_fac==<span class="number">4</span> <span class="keyword">and</span> self.i_lev&lt;=<span class="number">3</span>):<span class="comment">#3 4</span></span><br><span class="line">            <span class="keyword">return</span> self.L9</span><br><span class="line">        <span class="keyword">if</span> (self.i_fac==<span class="number">5</span> <span class="keyword">and</span> self.i_lev&lt;=<span class="number">4</span>):<span class="comment">#4 5</span></span><br><span class="line">            <span class="keyword">return</span> self.L16</span><br><span class="line">        <span class="keyword">if</span> (self.i_fac==<span class="number">6</span> <span class="keyword">and</span> self.i_lev&lt;=<span class="number">5</span>):<span class="comment">#5 6</span></span><br><span class="line">            <span class="keyword">return</span> self.L25</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;程序说明&quot;&gt;&lt;a href=&quot;#程序说明&quot; class=&quot;headerlink&quot; title=&quot;程序说明&quot;&gt;&lt;/a&gt;程序说明&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt; 输入为数组，如下所示：&lt;br&gt;a=[[1,2,3],[4,5],[6,7]]&lt;br&gt;a[0],a[1],a[2]···表示各个因素，此时表示a有四个因素&lt;br&gt;a[0]=[1,2,3]表示a[0]有三个值可以选&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;输出为数组，如下所示：
    
    </summary>
    
      <category term="软件笔记" scheme="http://i90s.vip/categories/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="python" scheme="http://i90s.vip/tags/python/"/>
    
      <category term="正交" scheme="http://i90s.vip/tags/%E6%AD%A3%E4%BA%A4/"/>
    
  </entry>
  
  <entry>
    <title>标准正交表</title>
    <link href="http://i90s.vip/2016/05/29/%E6%A0%87%E5%87%86%E6%AD%A3%E4%BA%A4%E8%A1%A8/"/>
    <id>http://i90s.vip/2016/05/29/标准正交表/</id>
    <published>2016-05-29T13:14:20.000Z</published>
    <updated>2016-05-30T14:23:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标准表"><a href="#标准表" class="headerlink" title="标准表"></a>标准表</h2><hr>
<table>
<thead>
<tr>
<th style="text-align:center">水平数</th>
<th style="text-align:center">1级</th>
<th style="text-align:center">2级</th>
<th style="text-align:center">3级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2水平</td>
<td style="text-align:center">L4(2^3)</td>
<td style="text-align:center">L8(2^7)</td>
<td style="text-align:center">L16(2^15)</td>
</tr>
<tr>
<td style="text-align:center">3水平</td>
<td style="text-align:center">L9(3^4)</td>
<td style="text-align:center">L27(3^13)</td>
<td style="text-align:center">L81(3^40)</td>
</tr>
<tr>
<td style="text-align:center">4水平</td>
<td style="text-align:center">L16(4^5)</td>
<td style="text-align:center">L64(4^21)</td>
<td style="text-align:center">L256(4^85)</td>
</tr>
<tr>
<td style="text-align:center">5水平</td>
<td style="text-align:center">L25(5^6)</td>
<td style="text-align:center">L125(5^31)</td>
<td style="text-align:center">L625(5^156)</td>
</tr>
</tbody>
</table>
<h2 id="标准正交表"><a href="#标准正交表" class="headerlink" title="标准正交表"></a>标准正交表</h2><a id="more"></a>
<hr>
<p><strong>L4(2^3):</strong><br>L4=[<br>                [0,0,0],<br>                [0,1,1],<br>                [1,0,1],<br>                [1,1,0]<br>                ]  #2 3 </p>
<p><strong>L8(2^7):</strong><br>L8=[<br>                [0,0,0,0,0,0,0],<br>                [0,0,0,1,1,1,1],<br>                [0,1,1,0,0,1,1],<br>                [0,1,1,1,1,0,0],<br>                [1,0,1,1,0,1,0],<br>                [1,0,1,1,0,1,0],<br>                [1,1,0,1,0,0,1],<br>                [1,1,0,1,0,0,1]<br>                ] #2 7</p>
<p><strong>L9(3^4): </strong><br>L9=[<br>                [0,0,0,0],<br>                [0,1,1,1],<br>                [0,2,2,2],<br>                [1,0,1,2],<br>                [1,1,2,0],<br>                [1,2,0,1],<br>                [2,0,2,1],<br>                [2,1,0,2],<br>                [2,2,1,0]<br>                ]#3 4</p>
<p><strong>L16(4^5): </strong><br>L16=[<br>                 [0,0,0,0,0],<br>                 [0,1,1,1,1],<br>                 [0,2,2,2,2],<br>                 [0,3,3,3,3],<br>                 [1,0,1,2,3],<br>                 [1,1,0,3,2],<br>                 [1,2,3,0,1],<br>                 [1,3,2,1,0],<br>                 [2,0,2,3,1],<br>                 [2,1,3,2,0],<br>                 [2,2,0,1,3],<br>                 [2,3,1,0,2],<br>                 [3,0,3,1,2],<br>                 [3,1,2,0,3],<br>                 [3,2,1,3,0],<br>                 [3,3,0,2,1]<br>                 ]#4 5</p>
<p><strong>L25(5^6): </strong><br>L25=[<br>                  [1,1,1,1,1,1],<br>                  [1,2,2,2,2,2],<br>                  [1,3,3,3,3,3],<br>                  [1,4,4,4,4,4],<br>                  [1,5,5,5,5,5],<br>                  [2,1,2,3,4,5],<br>                  [2,2,3,4,5,1],<br>                  [2,3,4,5,1,2],<br>                  [2,4,5,1,2,3],<br>                  [2,5,1,2,3,4],<br>                  [3,1,3,5,2,4],<br>                  [3,2,4,1,3,5],<br>                  [3,3,5,2,4,1],<br>                  [3,4,1,3,5,2],<br>                  [3,5,2,4,1,3],<br>                  [4,1,4,2,5,3],<br>                  [4,2,5,3,1,4],<br>                  [4,3,1,4,2,5],<br>                  [4,4,2,5,3,1],<br>                  [4,5,3,1,4,2],<br>                  [5,1,5,4,3,2],<br>                  [5,2,1,5,4,3],<br>                  [5,3,2,1,5,4],<br>                  [5,4,3,2,1,5],<br>                  [5,5,4,3,2,1]<br>                  ]#5 6</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;标准表&quot;&gt;&lt;a href=&quot;#标准表&quot; class=&quot;headerlink&quot; title=&quot;标准表&quot;&gt;&lt;/a&gt;标准表&lt;/h2&gt;&lt;hr&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;水平数&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;1级&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;2级&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;3级&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;2水平&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;L4(2^3)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;L8(2^7)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;L16(2^15)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;3水平&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;L9(3^4)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;L27(3^13)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;L81(3^40)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;4水平&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;L16(4^5)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;L64(4^21)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;L256(4^85)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;5水平&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;L25(5^6)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;L125(5^31)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;L625(5^156)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;标准正交表&quot;&gt;&lt;a href=&quot;#标准正交表&quot; class=&quot;headerlink&quot; title=&quot;标准正交表&quot;&gt;&lt;/a&gt;标准正交表&lt;/h2&gt;
    
    </summary>
    
      <category term="软件笔记" scheme="http://i90s.vip/categories/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="正交表" scheme="http://i90s.vip/tags/%E6%AD%A3%E4%BA%A4%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>正交试验法原理</title>
    <link href="http://i90s.vip/2016/05/28/%E6%AD%A3%E4%BA%A4%E8%AF%95%E9%AA%8C%E6%B3%95%E5%8E%9F%E7%90%86/"/>
    <id>http://i90s.vip/2016/05/28/正交试验法原理/</id>
    <published>2016-05-28T12:20:08.000Z</published>
    <updated>2016-05-30T14:21:29.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>由于要整理测试用例 用到了正交法生成测试用例<br>特对正交实验法进行下整理</p>
</blockquote>
<p><strong> 正交实验法概念 </strong><br>来自百度百科的解释<a href="http://baike.baidu.com/link?url=_RWY0sTNRmIpVMElPKw9SzkmJ4j4PbW_vwErYeAsU0c0Oo2jdOSV1YE3nC8EPfWtdSfSh6OEqQLXYts8SAjUQq" target="_blank" rel="external">正交试验法</a><a id="more"></a></p>
<blockquote>
<p>正交实验法就是利用排列整齐的表 -、<strong>正交表</strong>来对试验进行整体设计、综合比较、统计分析，实现通过少数的实验次数找到较好的生产条件，以达到最高生产工艺效果，<strong>这种试验设计法是从大量的试验点中挑选适量的具有代表性的点，利用已经造好的表格—正交表来安排试验并进行数据分析的方法。</strong>正交表能够在因素变化范围内均衡抽样，使每次试验都具有较强的代表性，由于正交表具备均衡分散的特点，保证了全面实验的某些要求，这些试验往往能够较好或更好的达到实验的目的。</p>
</blockquote>
<p><strong> 关于正交表 </strong></p>
<blockquote>
<p>日本著名的统计学家田口玄一将正交试验选择的水平组合列成表格，称为正交表。例如作一个三因素三水平的实验，按全面实验要求，须进行33=27种组合的实验，且尚未考虑每一组合的重复数。若按L9(33) 正交表按排实验，只需作9次，按L18(37) 正交表进行18次实验，显然大大减少了工作量。因而正交实验设计在很多领域的研究中已经得到广泛应用。</p>
</blockquote>
<p><strong> 正交实验法特点 </strong></p>
<blockquote>
<p>均匀分散，齐整可比</p>
</blockquote>
<p><strong>正交表的三个特性</strong><br>一、 正交性</p>
<ol>
<li>任一列中，不同数字出现次数相等</li>
<li>任两列中，同一横行所组成的数字对出现的次数相等<br>二、 可比性</li>
<li>任一列的个水平都出现，使得部分试验中包含所有因素的所有水平</li>
<li>任一2列建的所有组合全部出现，使任一两因素间都是全面实验<br>三、 综合可比性</li>
<li>任一列各水平出现的次数都相等</li>
<li>任两列间所有可能的组合出现的次数都相等<blockquote>
<p>正交性即均衡性是核心，是基础，代表性和综合可比性是正交性的必然结果，从而使正交表得以具体应用</p>
</blockquote>
</li>
</ol>
<p><strong> 正交实验过程 </strong></p>
<blockquote>
<p>正交实验设计包括两部分内容：第一，是怎样安排实验；第二，是怎样分析实验结果。</p>
</blockquote>
<p><strong>利用正交实验设计测试用例的步骤</strong></p>
<ol>
<li>明确实验目的，确定考核指标</li>
<li>挑因素，选水平</li>
<li>选择格式的正交表</li>
<li>进行表头设计</li>
<li>确定实验方案</li>
</ol>
<p><strong>正交表的构成</strong><br>行数(Runs)：正交表中的行的个数，即试验的次数，也是我们通过正交实验法设计的测试用例的个数。<br>因素数(Factors) ：正交表中列的个数，即我们要测试的功能点。<br>水平数(Levels)：任何单个因素能够取得的值的最大个数。正交表中的包含的值为从0到数“水平数-1”或从1到“水平数” 。即要测试功能点的输入条件。<br>正交表的形式：<br>L行数(水平数^因素数)</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;由于要整理测试用例 用到了正交法生成测试用例&lt;br&gt;特对正交实验法进行下整理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt; 正交实验法概念 &lt;/strong&gt;&lt;br&gt;来自百度百科的解释&lt;a href=&quot;http://baike.baidu.com/link?url=_RWY0sTNRmIpVMElPKw9SzkmJ4j4PbW_vwErYeAsU0c0Oo2jdOSV1YE3nC8EPfWtdSfSh6OEqQLXYts8SAjUQq&quot;&gt;正交试验法&lt;/a&gt;
    
    </summary>
    
      <category term="软件笔记" scheme="http://i90s.vip/categories/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="正交实验" scheme="http://i90s.vip/tags/%E6%AD%A3%E4%BA%A4%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>pythonの将数组写入oracle内</title>
    <link href="http://i90s.vip/2016/05/19/python%E3%81%AE%E5%B0%86%E6%95%B0%E7%BB%84%E5%86%99%E5%85%A5oracle%E5%86%85/"/>
    <id>http://i90s.vip/2016/05/19/pythonの将数组写入oracle内/</id>
    <published>2016-05-19T13:09:08.000Z</published>
    <updated>2016-05-19T13:23:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>将给定的数组写入oracle内，保存到指定新表内<br>首先需要安装插件cx_oracle<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cx_Oracle</span><br><span class="line"><span class="comment">#程序目的：将二维数组内的数值写入oracle数据库相应的表内</span></span><br><span class="line"><span class="comment">#return [状态位，错误信息]</span></span><br><span class="line"><span class="comment">#0表示输出成功，错误信息为空</span></span><br><span class="line"><span class="comment">#1表示输出失败，返回相应错误信息</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>通过OUTPUT_ORACLE类实现功能 </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#----连接数据库-----</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OUTPUT_ORACLE</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#读取Oracle配置文件</span></span><br><span class="line">        Config_file=open(<span class="string">"Config.txt"</span>)</span><br><span class="line">        self.Oracle_Config=Config_file.readline()</span><br><span class="line">        Config_file.close()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">RW_Oracle</span><span class="params">(self,table_name,write_array)</span>:</span></span><br><span class="line">        self.tab_name=<span class="string">"create table "</span>+table_name  <span class="comment">#创建新表</span></span><br><span class="line">        self.w_array=write_array</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            conn=cx_Oracle.connect(self.Oracle_Config)</span><br><span class="line">            cursor=conn.cursor()</span><br><span class="line">        <span class="keyword">except</span> cx_Oracle.DatabaseError,msg:</span><br><span class="line">            cursor.close ()</span><br><span class="line">            conn.close ()</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>,msg]</span><br><span class="line"><span class="comment">#         try:</span></span><br><span class="line"><span class="comment">#             cursor.execute('drop table table_cc') #先删除表</span></span><br><span class="line"><span class="comment">#         except cx_Oracle.DatabaseError,msg:</span></span><br><span class="line"><span class="comment">#             cursor.close ()</span></span><br><span class="line"><span class="comment">#             conn.close ()</span></span><br><span class="line"><span class="comment">#             return [1,msg]</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cursor.execute(self.tab_name)  <span class="comment">#新建表格</span></span><br><span class="line">        <span class="keyword">except</span> cx_Oracle.DatabaseError,msg:</span><br><span class="line">            cursor.close ()</span><br><span class="line">            conn.close ()</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>,msg]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.w_array:</span><br><span class="line">            cursor.close ()</span><br><span class="line">            conn.close ()</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>,<span class="string">''</span>]</span><br><span class="line">        <span class="comment">#获取表名</span></span><br><span class="line">        Table_Name=table_name.split(<span class="string">'('</span>) <span class="comment">#用括号将表名分隔开</span></span><br><span class="line">        Insert_sql_temp=<span class="string">'insert into '</span>+Table_Name[<span class="number">0</span>]+<span class="string">' values('</span></span><br><span class="line">        <span class="comment">#创建插入SQL语句</span></span><br><span class="line">        x_len=len(self.w_array)     <span class="comment">#行数</span></span><br><span class="line">        y_len=len(self.w_array[<span class="number">0</span>])  <span class="comment">#列数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,x_len):</span><br><span class="line">            array_temp=<span class="string">''</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,y_len):</span><br><span class="line">                <span class="keyword">if</span> j==y_len<span class="number">-1</span>:</span><br><span class="line">                    array_temp=array_temp+str(self.w_array[i][j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    array_temp=array_temp+str(self.w_array[i][j])+<span class="string">','</span></span><br><span class="line">            Insert_sql=Insert_sql_temp+array_temp+<span class="string">')'</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                cursor.execute(Insert_sql)</span><br><span class="line">            <span class="keyword">except</span> cx_Oracle.DatabaseError,msg:</span><br><span class="line">                cursor.close ()</span><br><span class="line">                conn.close ()</span><br><span class="line">                <span class="keyword">return</span> [<span class="number">1</span>,msg]</span><br><span class="line">        <span class="comment">#提交数据</span></span><br><span class="line">        conn.commit(); </span><br><span class="line">        <span class="comment">#关闭数据库连接</span></span><br><span class="line">        cursor.close ()</span><br><span class="line">        conn.close ()</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>,<span class="string">''</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong> 存在的问题 </strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">写入效率不高，有待进一步优化</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;将给定的数组写入oracle内，保存到指定新表内&lt;br&gt;首先需要安装插件cx_oracle&lt;br&gt;
    
    </summary>
    
      <category term="软件笔记" scheme="http://i90s.vip/categories/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Oracle" scheme="http://i90s.vip/tags/Oracle/"/>
    
      <category term="python" scheme="http://i90s.vip/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pythonの将数组写入excel内</title>
    <link href="http://i90s.vip/2016/05/18/python%E3%81%AE%E5%B0%86%E6%95%B0%E7%BB%84%E5%86%99%E5%85%A5excel%E5%86%85/"/>
    <id>http://i90s.vip/2016/05/18/pythonの将数组写入excel内/</id>
    <published>2016-05-18T13:00:51.000Z</published>
    <updated>2016-05-19T13:24:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>将给定的数组写入excel内，保存到指定路径下<br>首先需要安装两个插件 xlrd xlwt<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*- </span></span><br><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#程序目的：将二维数组内的数值写入excel内，并保存到相应的路径</span></span><br><span class="line"><span class="comment">#return [状态位，错误信息]</span></span><br><span class="line"><span class="comment">#0表示输出成功，错误信息为空</span></span><br><span class="line"><span class="comment">#1表示输出失败，返回相应错误信息</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong> 通过OUTPUT_EXCEL类实现该功能 </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OUTPUT_EXCEL</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.file=xlwt.Workbook()</span><br><span class="line">        self.table=self.file.add_sheet(<span class="string">'sheet 1'</span>) <span class="comment">#默认存到Sheet 1内</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">RW_Excel</span><span class="params">(self,excel_name,save_path,write_array)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> write_array: <span class="comment">#判断数组是否为空</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.file.save(excel_name)</span><br><span class="line">            <span class="keyword">except</span> IOError,msg:</span><br><span class="line">                <span class="keyword">return</span> [<span class="number">1</span>,msg]</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        x_len=len(write_array)</span><br><span class="line">        y_len=len(write_array[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">0</span>,x_len):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,y_len):</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    self.table.write(i,j,write_array[i][j])</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="keyword">print</span> i ,j</span><br><span class="line">                    <span class="keyword">return</span> [<span class="number">1</span>,<span class="string">'Data error'</span>]</span><br><span class="line">        file_name_path=save_path+excel_name</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.file.save(file_name_path)</span><br><span class="line">        <span class="keyword">except</span> IOError,msg:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>,msg]</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>,<span class="string">''</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong> 存在的问题 </strong><br><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">由于使用xlwt xlrd插件，写入excel的行不能超过</span><span class="number">2</span><span class="xml"></span><span class="keyword">^16</span><span class="xml">，也就是最多只能写入</span><span class="number">65536</span><span class="xml">行</span></span><br></pre></td></tr></table></figure></p>
<p><strong> 未验证的可行的解决方法 </strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用openpyxl插件代替xlwt和xlrd插件</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;将给定的数组写入excel内，保存到指定路径下&lt;br&gt;首先需要安装两个插件 xlrd xlwt&lt;br&gt;
    
    </summary>
    
      <category term="软件笔记" scheme="http://i90s.vip/categories/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="python" scheme="http://i90s.vip/tags/python/"/>
    
      <category term="excel" scheme="http://i90s.vip/tags/excel/"/>
    
  </entry>
  
  <entry>
    <title>连载：面向对象葵花宝典：思想、技巧与实践(36-40章)</title>
    <link href="http://i90s.vip/2016/05/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B85/"/>
    <id>http://i90s.vip/2016/05/16/面向对象葵花宝典5/</id>
    <published>2016-05-16T12:50:50.000Z</published>
    <updated>2016-05-26T15:33:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>无意间发现这篇文章，文章讲解由浅入深，读完后感触很深<br>特全文转到自己的博客，方便以后自己随时查看<br>文章转载自爱技术的华仔的博客[<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">http://blog.csdn.net/yunhua_lee</a>]<br>非常感谢<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">爱技术的华仔</a></p>
</blockquote>
<h1 id="第三十六章"><a href="#第三十六章" class="headerlink" title="第三十六章"></a>第三十六章</h1><p>经过前面深入的阐述，SOLID的原则我们已经基本上讲清楚了，但如果想熟练的应用SOLID原则，仅仅知道SOLID是什么（what）还不够，我们还需要知道SOLID原则在什么时候和什么场景应用（when或where）。<a id="more"></a></p>
<p>幸运的是，SOLID原则的5个独立原则在实际应用中基本上都是独挡一面，并不会在某个地方需要同时从可选的几个原则中挑选一个最优的原则来应用，这样大大降低了我们应用SOLID原则的难度。</p>
<p>SOLID原则具体的应用场景如下：</p>
<p>SRP原则：用于类的设计</p>
<p>当我们想出一个类，或者设计出一个类的原型后，使用SRP原则核对一下类的设计是否符合SRP要求。</p>
<p>OCP原则：总的指导思想</p>
<p>OCP原则是一个总的指导思想，在面向对象的设计中，如果能够符合LSP/ISP/DIP原则，一般情况下就能够符合OCP原则了。<br>除了在面向对象的软件设计中外，OCP也可以用于指导系统<a href="http://lib.csdn.net/base/16" target="_blank" rel="external">架构</a>设计，例如常见的CORBA、COM协议，其实都可以认为是OCP原则的具体应用和实现。</p>
<p>LSP原则：用于指导类继承的设计</p>
<p>当我们设计类之间的继承关系时，使用LSP原则来判断这种继承关系是否符合LSP要求。</p>
<p>ISP原则：用于指导接口的设计</p>
<p>ISP原则可以认为是SRP原则的一个变种，本质上和SRP的思想是一样。SRP用于指导类的设计，而ISP用于指导接口的设计。</p>
<p>DIP原则：用于指导类依赖的设计</p>
<p>当我们设计类之间的依赖关系时，可以使用DIP原则来判断这种依赖是否符合DIP原则。<br>DIP原则和LSP原则相辅相成：DIP原则用于指导抽象出接口或者抽象类，而LSP原则指导从接口或者抽象类派生出新的子类。</p>
<h1 id="第三十七章"><a href="#第三十七章" class="headerlink" title="第三十七章"></a>第三十七章</h1><p>设计模式”这个词几乎成为了软件设计的代名词，很多人非常天真的以为掌握了设计模式就掌握了软件设计，但实际上如果只是握了设计模式，软件设计的门都还没摸到！</p>
<p>========================================================</p>
<p>谈起设计模式，那是几乎无人不知，无人不晓，大名鼎鼎的“GOF”（中文有的翻译为“四人帮”）惊世之作，真是“平生不识GOF，学尽设计也枉然！”</p>
<p>然而，设计模式真的是软件设计的“瑞士军刀”，切、削、锯、钻样样精通么？</p>
<p>读过设计模式的朋友估计不少，但真正注意过《设计模式》的副标题的估计很少，而这个副标题却是避免误解设计模式的关键。《设计模式》的副标题是：可复用面向对象软件的基础！</p>
<p> 不要小看了这短短的一句话，如果你没有看这句话，或者只是一扫而过并没有仔细体会，那么你很可能就认为设计模式是一把“瑞士军刀”，能够解决所有的设计问题，而实际上“<strong>设计模式只是一把锤子</strong>”，有个谚语叫做“如果你手里有一把锤子，那么所有的问题都变成了钉子”，如果你拿着设计模式这把锤子倒出去敲，要么东西被敲坏，要么就不起作用。</p>
<p>为什么说设计模式只是一把锤子呢？我们还是从副标题来看。《设计模式》的副标题揭示了《设计模式》的两个主要约束：</p>
<p>1）设计模式解决的是“可复用”的设计问题；<br>2）设计模式应用的领域是“面向对象”；</p>
<p>相信经过我这么一提醒，大家基本上都能够明白了为什么“设计模式只是一把锤子”了：</p>
<p>1）设计模式只能解决“可复用”的设计问题，其它的例如性能设计、可靠性设计、安全性设计、可服务性设计等都不是设计模式能够解决的；</p>
<p>2）设计模式只是在面向对象的语言中应用，如果是非面向对象的语言，就不怎么好用了。当然，你可以在C语言中用上设计模式，但毕竟要折腾不少，用起来也不那么得心用手。</p>
<p>所以，当你遇到一个问题就想到设计模式的时候，一定要注意“设计模式只是一把锤子”，不要拿着这把锤子到处去敲！</p>
<h1 id="第三十八章"><a href="#第三十八章" class="headerlink" title="第三十八章"></a>第三十八章</h1><p>很多人能够熟练背诵出所有的设计模式，能够快速画出各种设计模式的UML类图，也能够熟练的写出《设计模式》一书中各个模式的样例代码。但一到实际的项目设计和开发的时候，往往都会陷入迷茫：要么无从下手，不知道哪个地方要用设计模式；要么生搬硬套，胡乱使用设计模式，将方案和代码搞得一团乱麻。</p>
<p>===========================================================================</p>
<p>【知易行难 —— 设计模式应用的问题】<br>形而下者谓之器，形而上者谓之道。<br>                                               —《易经·系辞》</p>
<p>正如很多流行的技术（面向对象、UML等）一样，几乎大部分人都会宣称自己“掌握、熟练掌握”，甚至“精通”，然而，真正掌握的或者精通的，实在是少之又少。</p>
<p>一种典型的现象是：很多人能够熟练背诵出所有的设计模式，能够快速画出各种设计模式的UML类图，也能够熟练的写出《设计模式》一书中各个模式的样例代码。但一到实际的项目设计和开发的时候，往往都会陷入迷茫：要么无从下手，不知道哪个地方要用设计模式；要么生搬硬套，胡乱使用设计模式，将方案和代码搞得一团乱麻。</p>
<p>这是什么原因呢，难道是设计模式不好用，或者设计模式根本就是一个噱头？<br>答案不在于设计模式本身是否有用，而是在于我们没有掌握正确的学习和应用设计模式的方法。</p>
<p>学习《设计模式》一书中的23个设计模式，只是掌握了《设计模式》的“器”，但并没有掌握设计模式的“道”。就像一个工匠，锯、钻、锤、刨样样精通，但如果不知道什么地方该用锯，什么地方该用钻，肯定是一个不合格的工匠。为了能够更好的学习和应用设计模式，我们也需要掌握设计模式的“道”。</p>
<p>设计模式的“道”就是用来指导我们什么时候用设计模式，为什么要用设计模式，23个设计模式只是告诉了我们how，而设计模式之道却可以告诉我们why和where！</p>
<p>【拨云见日 —— 寻找设计模式之道】<br>熟悉《设计模式》一书内容的同学可能会想到：《设计模式》一书中，不是每个模式都有“适用性”的说明么？这个其实就是回答了where和why的问题啊！</p>
<p>例如：Facade模式的“适用性”说明如下（摘自《设计模式》中文版一书）：<br> <img src="http://ww1.sinaimg.cn/large/666cc9e3gw1f497id22urj20pd0agahg.jpg" alt=""><br>上面这一段文字，看起来回答了where和why的问题，但实际上我个人感觉作用并不大。</p>
<p>首先，这段描述太长了：以上这段文字是否花了你几分钟的时间去阅读和理解？</p>
<p>其次，这段描述比较抽象：什么事复杂，什么叫做简单，什么叫做很大依赖性。。。。。。可能每个人理解都不一样。</p>
<p>再者，23个模式，所有的“适应性”条款加起来估计有几十条条，你能够背住么？即使你能够全部背住，你能够全部理解么？即使你能够全部理解，当面对一个具体问题的时候，你知道几十条里面哪一条适应你的情况么？</p>
<p>所以，《设计模式》一书关于“适用性”的描述，实际上还是太复杂，太多了，不具备很强的实践知道意义和可操作性。</p>
<p>我们需要的是一个更简单的指导思想，大道至简，最好是一两句话就能够描述！<br>幸运的是，答案竟然就在《设计模式》一书中，但这个答案并不是那么明显！</p>
<p>《设计模式》一书的内容侧重点是23个模式的详细阐述，大部分人可能都是直奔主题，逐一去研究每个模式，而对于开头部分第1章和第2章的内容并没有详细研读和思考，或者对于这两章只是简单的浏览，并未认真领会和思考，由此错过了最重要的内容。再加上GoF在这2章的内容中，既要引入一个全新的概念，又要提纲挈领的介绍各个模式，还要引入实例进行分析，以至于大量的内容将真正核心的内容反而给淹没或者冲淡了。</p>
<p>设计模式之道就隐藏在“2.6.2 封装实现依赖关系”的最后一段，很简单的一句话：<br><strong>对变化的概念进行封装（encapsulate the concept that varies）</strong></p>
<p>你看到这句话可能有点失望，前面分析了那么久，卖了那么多的关子，结果就这么简简单单一句话，这不是在忽悠么？<br>你可千万别小看了这句话，“大道至简”，设计模式之道也不例外，但“简”并不意味着没用，相反，正因为其“简”，每个人的理解才一致，也更好掌握，实践中才更好应用。正所谓：“真传一句话，假传万卷书”。</p>
<p>GoF在《设计模式》一书中最早提出这个原则，后来不断的有其他专家进行阐述，其中《设计模式精解》（《Design pattern explained》）一书的阐述我认为是最精辟的：<strong>Find what varies and encapsulate it，翻译一下即“找到变化，封装变化”</strong>。虽然含义和GoF描述的基本一致，但其更加容易理解。</p>
<p>正所谓：踏破铁鞋无觅处，得来全不费工夫！</p>
<p>【庖丁解牛 —— 解析设计模式之道】<br>现在，让我们来深入理解“找到变化，然后封装变化”的设计模式之道。<br>首先，“找到变化”解决了“在哪里”使用设计模式的问题，即回答了“where”的问题。</p>
<p>“找到变化”看起来是比较抽象的一句话，但在实践中非常好应用和操作，而且不同领域、不同行业的系统都可以完美的应用这句话。虽然不同领域、不同行业变化的因素、方式、时机等都不一样，但每个领域或者行业的需求分析人员、设计人员，对自己所处行业和领域的可能变化肯定是有比较深刻的理解的，什么会变化、会如何变化、什么时候会变化。。。。。。等等，肯定都能够自己判断，这种判断并不需要什么高深的技巧和知识水平，只需要一定的经验积累。</p>
<p>如果我们刚接触一个行业或者领域，经验积累并不够，那怎么办呢？是否就无法“找到变化”了？<br>其实也不然，有一个万能的办法，只是要花费更多的精力了。</p>
<p>我的这个万能办法就是“唯一不变的是变化本身”，也就是说，如果你不知道什么会变化，那么就抱着怀疑一切的想法，一切都可能是变化的。</p>
<p>但光有这条指导原则还不行，如果我们真的抱着“一切都是可能变化的”想法，然后封装一切变化，那么就会陷入变化的漩涡无法自拔，因为变化是会递归的，A可能变成B，B也可能继续变化，于是这样无穷无尽，系统是不可能做出来的。</p>
<p>所以我们需要一个终止条件，避免陷入无穷无尽的变化递归漩涡。这个终止条件就是“有限时间内可能发生的变化”。这里的“有限时间”随行业和领域的不同而变化。例如（以下时间仅供参考）：<br>互联网行业可以说：半年内可能发生的变化。。。。。。<br>电信行业可以说：1年内可能发生的变化。。。。。。<br>金融行业可以说：2年内可能发生的变化。。。。。。<br>政府行业可以说：3年内可能发生的变化。。。。。。</p>
<p>有了这个指导原则后，你可以这样去问有经验的前辈、大虾、大牛等： XXX在1年内会发生变化么？会怎样变化？</p>
<p>就这样，即使你是菜鸟，通过这么一招“借花献佛”，也能够轻松发现“变化”的地方。</p>
<p>其次，“封装变化”解决了“为什么”使用设计模式的问题，即回答了“why”的问题。<br>为什么我们要用设计模式，是因为我们要封装变化！但我们为什么要封装变化呢？<br>答案很明显：变化不好！</p>
<p>当然这个“不好”不是从业务的角度来说的，而是从系统的角度来说的。从业务的角度来说，“变化”是好的，变化意味着新的机会；但从系统的角度来说，变化并不好，因为变化必然要求系统改动，改动就意味着风险！</p>
<p>虽然变化给系统带来风险，但我们不能因此而“拒绝变化”，因为拒绝变化就意味着失去了机会，简单来说，赚不到钱的系统，设计再优美，功能再强大，系统再稳定，也不过是一堆无用的摆设：<br>客户给你提了新需求，你不做，能拿到合同么。。。。。。<br>行业正在兴起新的流行功能，你不做，你的系统有人用么。。。。。。<br>一项创新带来了新的机遇，你不做，能抢占市场么。。。。。。</p>
<p>所以我们要“拥抱变化”，但我们又不能让变化带来太大的风险，所以就提出了“封装变化”。“封装变化”意味着将变化的影响范围控制最小，将风险降到最低。</p>
<p>我们来看看，变化会带来哪些问题和风险：<br>1）开发人员需要编码以适应变化，设计不好的方案将导致大量的编码工作量、自测工作量；<br>2）测试人员不单要测试因变化而新增的那部分，还要测试受影响的部分，设计不好的方案，牵一发而动全身，导致测试工作量大大增加；<br>3）如果为了适应某个变化而对系统做了比较大的改动，则系统的质量风险将上升，很可能导致上线失败，或者上线后出现各种问题；</p>
<p>因此，我们要尽量减少变化带来的工作量和风险，而减少的最有效方法就是将变化的影响范围缩小，即：将变化封装起来，使其只在有限的范围内有影响。</p>
<p>【举一反三 —— 活学活用设计模式之道】<br>就像一个武林高手有了深厚的内功，天下万物皆可成为手中的利器，而不必拘泥于具体的武器和招数一样，掌握了设计模式之道后，我们其实也完全可以不拘泥于只是用《设计模式》一书中的23个设计模式，可以根据需要选择最合适的方案。</p>
<p>例如：<br>不同的业务有不同的规则排列组合，规则引擎可以封装各种变化的规则。。。。。。<br>类之间的依赖是变化的，<a href="http://lib.csdn.net/base/17" target="_blank" rel="external">spring</a>使用XML配置文件来封装这种变化。。。。。。<br>每个银行的卡都不一样，银联封装了这种变化，使得不同银行可以互通。。。。。。</p>
<p>总之，你可以使用类和设计模式来封装变化，你也可以使用配置文件和模块来封装变化，你也可以使用一个系统来封装变化。。。。。。</p>
<h1 id="第三十九章"><a href="#第三十九章" class="headerlink" title="第三十九章"></a>第三十九章</h1><p>又是设计原则，又是设计模式，到底该用哪个呢？ =============================================================================</p>
<p>在“设计模型”一章中，我们提到设计原则和设计模式是互补的，设计原则和设计模式互补体现在：设计原则主要用于指导“类的定义”的设计，而设计模式主要用于指导“类的行为”的设计。</p>
<p>举一个很简单的例子：假设我们要设计一个图形类Shape，这个类既支持三角形，又支持矩形，其代码如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.designpattern.diagram;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 设计不好的Shape类，同时兼顾三角形和矩形的职责，不符合SRP设计原则 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BadShape</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//三角形的属性  </span></span><br><span class="line">    Position a;  </span><br><span class="line">    Position b;  </span><br><span class="line">    Position c;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//矩形的属性  </span></span><br><span class="line">    Position m;  </span><br><span class="line">    <span class="keyword">int</span> length;  </span><br><span class="line">    <span class="keyword">int</span> width;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTriangle</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 画出三角形  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 画出矩形  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有经验的朋友都会觉得这个设计不太合理，因为其不符合类的SRP设计原则。因此，合理的做法是将这个类按照SRP原则拆分，具体拆分方法如下：<br>NormalShape.java</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.designpattern.diagram;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 将BadShape拆开为三角形和矩形两个图形，并提取出NormalShape这个父类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">NormalShape</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span>(<span class="params"></span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NormalTriangle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.oo.designpattern.diagram;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 三角形类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalTriangle</span> <span class="keyword">extends</span> <span class="title">NormalShape</span> </span>&#123;  </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//三角形的属性  </span></span><br><span class="line">    Position a;  </span><br><span class="line">    Position b;  </span><br><span class="line">    Position c;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO：绘画三角形  </span></span><br><span class="line">        <span class="keyword">if</span>(Config.CURRENT_SYSTEM == Config.WINDOWS)&#123;  </span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> 调用Windows的画图方法  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( Config.CURRENT_SYSTEM == Config.LINUX)&#123;  </span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> 调用Linux的画图方法  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( Config.CURRENT_SYSTEM == Config.MAC)&#123;  </span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> 调用Mac的画图方法  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>NormalRectangle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.oo.designpattern.diagram;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 矩形类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalRectangle</span> <span class="keyword">extends</span> <span class="title">NormalShape</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//矩形的属性  </span></span><br><span class="line">    Position m;  </span><br><span class="line">    <span class="keyword">int</span> length;  </span><br><span class="line">    <span class="keyword">int</span> width;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 绘画矩形  </span></span><br><span class="line">        <span class="keyword">if</span>(Config.CURRENT_SYSTEM == Config.WINDOWS)&#123;  </span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> 调用Windows的画图方法  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( Config.CURRENT_SYSTEM == Config.LINUX)&#123;  </span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> 调用Linux的画图方法  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( Config.CURRENT_SYSTEM == Config.MAC)&#123;  </span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> 调用Mac的画图方法  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样拆分之后，从类的设计原则来看，已经是符合要求了。</p>
<p>接下来我们再使用设计模式来继续完善这个设计，这里就需要使用设计模式之道来指导我们设计了，即：<strong>找到变化，封装变化</strong>。</p>
<p>关于图形类一个比较明显的变化是跨平台，比如说要同时支持Windows、Linux、Mac三个桌面操作系统，那么实际画图的方法和需要调用的函数可能就随着平台的不同而变化，因此我们要找出一种方法来封装这种变化。</p>
<p>参考《设计模式》，可以知道这种方法就是“Bridge模式”，使用了Bridge后，会多出几个接口和实现类。<br>具体实现如下：<br>GoodShape.java<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.designpattern.diagram;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 在NormalShape的基础上，增加Bridge设计模式的实现，使其更加适应于跨平台 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GoodShape</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> ShapeDraw _draw;  <span class="comment">//将不同平台的实现封装到一个新的接口ShapeDraw  </span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span>(<span class="params"></span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>GoodTriangle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.oo.designpattern.diagram;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 按照Bridge设计模式设计的三角形类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodTriangle</span> <span class="keyword">extends</span> <span class="title">GoodShape</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    GoodTriangle(ShapeDraw draw)&#123;  </span><br><span class="line">        <span class="keyword">this</span>._draw = draw;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">        <span class="keyword">this</span>._draw.drawTriangle();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>GoodRectangle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.oo.designpattern.diagram;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 按照Bridge设计模式设计的矩形类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodRectangle</span> <span class="keyword">extends</span> <span class="title">GoodShape</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    GoodRectangle(ShapeDraw draw)&#123;  </span><br><span class="line">        <span class="keyword">this</span>._draw = draw;   </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">        <span class="keyword">this</span>._draw.drawRectangle();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ShapeDraw.java<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.designpattern.diagram;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 按照Bridge设计模式进行设计的画图的接口，封装了跨平台不同的实现 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">interface</span> <span class="title">ShapeDraw</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTriangle</span>(<span class="params"></span>)</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span>(<span class="params"></span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>WindowsDraw.java<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.designpattern</span><span class="selector-class">.diagram</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * Windwos上的画图实现 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">WindowsDraw</span> <span class="selector-tag">implements</span> <span class="selector-tag">ShapeDraw</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void drawTriangle() &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void drawRectangle() &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>LinuxDraw.java<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.designpattern</span><span class="selector-class">.diagram</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * Linux上的画图实现 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">LinuxDraw</span> <span class="selector-tag">implements</span> <span class="selector-tag">ShapeDraw</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void drawTriangle() &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void drawRectangle() &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MacDraw.java<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.designpattern</span><span class="selector-class">.diagram</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * Mac上的画图实现 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">MacDraw</span> <span class="selector-tag">implements</span> <span class="selector-tag">ShapeDraw</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void drawTriangle() &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void drawRectangle() &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，按照设计原则和设计模式进行重构后，原来不合理的设计逐步演变为一个优秀的设计了</p>
<h1 id="第四十章"><a href="#第四十章" class="headerlink" title="第四十章"></a>第四十章</h1><p>掌握了设计模式之道后，我们将以全新的方法来理解设计模式，这个方法更简单、更直观，不信？看几个样例就知道了</p>
<p>=====================================================================</p>
<p>DECORATOR 模式（以设计模式之道来理解）<br>【业务】<br>假设你进入了一个信息安全管理非常严格的公司，这家公司不允许员工自行打印文档，所有的文档打印都需要交给文档打印系统统一管理。文档打印系统会记录每次打印的时间、内容、打印人员。。。。。。等等，以便后续出现问题的时候进行追查。</p>
<p>由于公司有很多的部门，每个部门的安全要求并不完全一样，同时每个部门关于文档打印也有自己的一些规定。</p>
<p>我们的任务就是要开发一套能够支持整个公司文档打印需求的系统。</p>
<p>【发现变化】<br>文档打印系统面对的变化主要体现在：文档打印要求是变化的，不同的部门有不同的要求，同一个部门也可能修改自己的打印需求。</p>
<p>例如：<br>A 部门是一个战略规划的部门，里面的资料都非常重要，打印的时候需要在页眉位置打印 “绝密”，在页脚的位置打印 “密级申明”，同时要加上 “绝密文档” 的水印；<br>B 部门是内部培训部门，打印培训材料的时候需要在页眉位置打印 “内部公开”，但不需要密级申明，同时加上 “培训资料” 的水印<br>C 部门是对外宣传部门，打印宣传材料的时候只需要加上 “公司 logo” 的水印；</p>
<p>【传统方法】<br>传统方法使用类继承来封装打印请求，为每个部门创建一个打印的子类。详细示例代码如下：<br>PrintTask.Java – 文档打印系统开发小组负责维护</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 打印任务类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">abstract</span> public <span class="class"><span class="keyword">class</span> <span class="title">PrintTask</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">abstract</span> public void print(<span class="type">String</span> text);  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">SecretPrint</span>.java -- 文档打印系统开发小组负责维护:</span><br><span class="line">[java] view plain copy</span><br><span class="line"><span class="keyword">package</span> com.oo.designpattern.decorator;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 绝密文档的打印 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SecretPrint</span> <span class="keyword">extends</span> <span class="title">PrintTask</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    public void print(<span class="type">String</span> text) &#123;  </span><br><span class="line">        <span class="type">Printer</span>.printHeader(<span class="string">"绝密"</span>);  </span><br><span class="line">        <span class="type">Printer</span>.printText(text);  </span><br><span class="line">        <span class="type">Printer</span>.printFooter(<span class="string">"本文包含绝密信息，请勿泄露！"</span>);  </span><br><span class="line">        <span class="type">Printer</span>.printTextWaterMark(<span class="string">"绝密文档"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InternalPrint.java – 文档打印系统开发小组负责维护:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 内部公开的文档打印 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InternalPrint</span> <span class="keyword">extends</span> <span class="title">PrintTask</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    public void print(<span class="type">String</span> text) &#123;  </span><br><span class="line">        <span class="type">Printer</span>.printHeader(<span class="string">"内部公开"</span>);  </span><br><span class="line">        <span class="type">Printer</span>.printText(text);  </span><br><span class="line">        <span class="type">Printer</span>.printTextWaterMark(<span class="string">"培训资料"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PublicPrint.java – 文档打印系统开发小组负责维护:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.awt.<span class="type">Image</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 对外宣传的文档打印 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PublicPrint</span> <span class="keyword">extends</span> <span class="title">PrintTask</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">Image</span> _logo;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    public void print(<span class="type">String</span> text) &#123;  </span><br><span class="line">        <span class="type">Printer</span>.printText(text);  </span><br><span class="line">        <span class="type">Printer</span>.printImgWaterMark(_logo);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>文档打印系统实现如下：<br>PrintServer – 文档打印系统开发小组负责维护<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 文档打印系统 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> class PrintServer &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 执行打印任务 </span><br><span class="line">     * @param task </span><br><span class="line">     * @param text </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> executePrintTask(PrintTask task, <span class="keyword">String</span> <span class="built_in">text</span>)&#123;  </span><br><span class="line">        <span class="built_in">log</span>();  </span><br><span class="line">        task.<span class="built_in">print</span>(<span class="built_in">text</span>);  </span><br><span class="line">        audit();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 记录日志 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="built_in">log</span>()&#123;  </span><br><span class="line">        <span class="comment">// 省略具体实现代码  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 记录审计相关信息 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> audit()&#123;  </span><br><span class="line">        <span class="comment">// 省略具体实现代码  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义好不同的打印任务后，每个部门根据自己的需要，选择不同的任务发给文档打印系统。<br>例如，A 部门的打印处理如下：<br>SecretDepartment.java  – A 部门负责维护<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * A 部门的打印处理 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> SecretDepartment &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">print</span>(<span class="keyword">String</span> <span class="built_in">text</span>)&#123;  </span><br><span class="line">        PrintTask task = new SecretPrint();  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//PrintServer 即 “文档打印系统”  </span></span><br><span class="line">        PrintServer.executePrintTask(task, <span class="built_in">text</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>传统方法使用类继承来封装变化的打印需求，当面对变化时，存在如下问题：<br>1）新增部门的时候，需要文档打印系统提供一个新的打印任务类，将导致出现大量的 <strong><em>Print 类；<br>例如：新建了一个 D 部门，D 部门只需要打印纯文本即可，那么已有的 SecretPrint、InternalPrint、PublicPrint 类都无法满足需求，必须新增一个 PurePrint 的类；<br>2）某个部门的打印需求变更的时候，需要改变已有的 </em></strong>Print 类；<br>例如：C 部门希望在对外宣传材料的页眉上打印公司名称，则需要修改 PublicPrint 类。</p>
<p>【设计模式方法】<br>设计模式封装变化的方法就是 Decorator 模式。Decorator 模式定义如下：<br>“动态的给一个对象添加一些额外的职责”</p>
<p>《设计模式》一书中关于 Decorator 模式的描述并不很直观，我理解 Decorator 模式为 “通过聚合的方式将动态变化的职责组合起来”。</p>
<p>我们详细看看 Decorator 模式是如何封装变化的。<br>首先，将变化的职责封装为独立的类。传统方式实现中，不同的职责是对应不同的函数调用，而设计模式中，不同的职责是不同的类；<br>其次，通过聚合将变化的职责组合起来。传统方式中，不同职责的组合是通过在一个函数中写多行代码来体现的，而设计模式中，通过对象的聚合将不同职责组合起来。<br>【Decorator 模式结构】</p>
<p><img src="http://ww4.sinaimg.cn/large/666cc9e3gw1f497e2h1ovj20nw0eljth.jpg" alt=""></p>
<p>Component：定义一个对象接口（对应结构图中的 operation 函数），可以给这些对象动态添加职责<br>ConcreteComponent：定义一个对象，这个对象是实际的 Component，将被 Decorator 修饰<br>Decorator：定义修饰对象的接口，Decorator 实现的关键在于聚合了一个 Component 对象<br>ConcreteDecorator：具体的修饰对象</p>
<p>【代码实现】<br>使用 Decorator 设计模式实现的文档打印系统代码如下：<br><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong> 类设计 <strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></p>
<p>PrintComponent.java – 文档打印系统开发小组负责维护<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 打印组件的父类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PrintComponent</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span>(<span class="params"></span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PrintDecorator.java – 文档打印系统开发小组负责维护<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 修饰的打印任务，对应 Decorator 模式中的 Decorator </span><br><span class="line"> * Decorator 可以聚合 ConcreteComponent 或者其他 Decorator </span><br><span class="line"> * 这样可以使得打印任务能够嵌套执行下去，直到最后完成所有打印任务 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintDecorator</span> <span class="keyword">extends</span> <span class="title">PrintComponent</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">abstract</span> public void print();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TextComponent.java – 文档打印系统开发小组负责维护<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.oo.designpattern.decorator.<span class="type">Printer</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 文本打印，对应 Decorator 模式中的 ConcreteComponent </span><br><span class="line"> * 打印任务到 ConcreteComponent 就算真正完成了 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TextComponent</span> <span class="keyword">extends</span> <span class="title">PrintComponent</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> _text;  </span><br><span class="line">    <span class="type">TextComponent</span>(<span class="type">String</span> text)&#123;  </span><br><span class="line">        <span class="keyword">this</span>._text = text;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    public void print() &#123;  </span><br><span class="line">        <span class="type">Printer</span>.printText(<span class="keyword">this</span>._text);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HeaderDecorator.java – 文档打印系统开发小组负责维护<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.oo.designpattern.decorator.<span class="type">Printer</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 页眉打印 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HeaderDecorator</span> <span class="keyword">extends</span> <span class="title">PrintDecorator</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">PrintComponent</span> _comp; <span class="comment">// 被修饰的打印组件  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> _text;         <span class="comment">// 需要打印的页眉内容  </span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 初始化的时候，必须包含其它打印组件 comp，这是实现 Decorator 模式的前提 </span><br><span class="line">     * 同时也需要指定当前组件所需的参数，不能在 print 函数的参数中指定， </span><br><span class="line">     * 因为每个 Decorator 所需的参数是不一样的 </span><br><span class="line">     * @param comp </span><br><span class="line">     * @param text </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="type">HeaderDecorator</span>(<span class="type">PrintComponent</span> comp, <span class="type">String</span> text) &#123;  </span><br><span class="line">        <span class="keyword">this</span>._comp = comp;  </span><br><span class="line">        <span class="keyword">this</span>._text = text;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 打印 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    public void print() &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 打印的时候将当前 Decorator 和被修饰的 Component 分开，这是 Decorator 模式的关键  </span></span><br><span class="line">        <span class="type">Printer</span>.printHeader(_text);  <span class="comment">// 打印页眉  </span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">//_comp 本身如果是 Decorator，就会嵌套打印下去  </span></span><br><span class="line">        <span class="comment">//_comp 本身如果不是 Decorator，而是 ConcreteComponent，则打印任务到此结束  </span></span><br><span class="line">        _comp.print();                 </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FooterDecorator.java<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.oo.designpattern.decorator.<span class="type">Printer</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 页脚打印，和页眉打印类似，此处省略相同的注释代码 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FooterDecorator</span> <span class="keyword">extends</span> <span class="title">PrintDecorator</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">PrintComponent</span> _comp;   </span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> _text;           </span><br><span class="line">  </span><br><span class="line">    <span class="type">FooterDecorator</span>(<span class="type">PrintComponent</span> comp, <span class="type">String</span> text) &#123;  </span><br><span class="line">        <span class="keyword">this</span>._comp = comp;  </span><br><span class="line">        <span class="keyword">this</span>._text = text;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 打印 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    public void print() &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Printer</span>.printFooter(_text);  <span class="comment">// 打印页脚  </span></span><br><span class="line">          </span><br><span class="line">        _comp.print();                 </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TextWatermarkDecorator.java<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.oo.designpattern.decorator.<span class="type">Printer</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 文本水印打印，和页眉打印类似，此处省略相同的注释代码 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TextWatermarkDecorator</span> <span class="keyword">extends</span> <span class="title">PrintDecorator</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">PrintComponent</span> _comp;   </span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> _text;           </span><br><span class="line">  </span><br><span class="line">    <span class="type">TextWatermarkDecorator</span>(<span class="type">PrintComponent</span> comp, <span class="type">String</span> text) &#123;  </span><br><span class="line">        <span class="keyword">this</span>._comp = comp;  </span><br><span class="line">        <span class="keyword">this</span>._text = text;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 打印 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    public void print() &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Printer</span>.printTextWaterMark(_text);  <span class="comment">// 打印文本水印  </span></span><br><span class="line">          </span><br><span class="line">        _comp.print();                 </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ImgWatermarkDecorator.java<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.awt.<span class="type">Image</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.oo.designpattern.decorator.<span class="type">Printer</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 图片水印打印，和页眉打印类似，此处省略相同的注释代码 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ImgWatermarkDecorator</span> <span class="keyword">extends</span> <span class="title">PrintDecorator</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">PrintComponent</span> _comp;   </span><br><span class="line">    <span class="keyword">private</span> static <span class="type">Image</span> _logo; <span class="comment">// 图片水印只能是公司 logo          </span></span><br><span class="line">  </span><br><span class="line">    <span class="type">ImgWatermarkDecorator</span>(<span class="type">PrintComponent</span> comp) &#123;  </span><br><span class="line">        <span class="keyword">this</span>._comp = comp;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 打印 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    public void print() &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Printer</span>.printImgWaterMark(<span class="type">ImgWatermarkDecorator</span>._logo);  <span class="comment">// 打印图片水印  </span></span><br><span class="line">          </span><br><span class="line">        _comp.print();                 </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PrintServer.java<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> PrintServer &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 执行打印任务 </span><br><span class="line">     * @param comp </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executePrintTask</span><span class="params">(PrintComponent comp)</span></span>&#123;  </span><br><span class="line">        <span class="built_in">log</span>();  </span><br><span class="line">        comp.print();  </span><br><span class="line">        audit();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 记录日志 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="comment">// 省略具体实现代码  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 记录审计相关信息 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="comment">// 省略具体实现代码  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong> 类使用 <strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></p>
<p>A 部门的打印处理如下（如下代码请仔细阅读，特别是注释部分）：<br>SecretDepartment.java  – A 部门负责维护<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * A 部门的打印处理，注意与传统方法中的 SecretDepartment 类对比 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> class SecretDepartment &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 打印任务 1，对应传统方式的 SecretePrint 类 </span><br><span class="line">     * @param text </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">print</span>(<span class="keyword">String</span> <span class="built_in">text</span>)&#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">/** </span><br><span class="line">         * 使用 Decorator 设计模式后，打印任务不再是一个单独的类 SecretPrint 类， </span><br><span class="line">         * 而是通过将多个打印项目聚合成一个打印任务 </span><br><span class="line">         */</span>  </span><br><span class="line">        PrintComponent textComp = <span class="keyword">new</span> TextComponent(<span class="built_in">text</span>);  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 注意 header 聚合了 textComp  </span></span><br><span class="line">        PrintDecorator header = <span class="keyword">new</span> HeaderDecorator(textComp, <span class="string">"绝密"</span>);    </span><br><span class="line">        <span class="comment">// 注意 footer 聚合了 header，而不是 textComp，这样就能够嵌套执行下去  </span></span><br><span class="line">        PrintDecorator footer = <span class="keyword">new</span> FooterDecorator(header, <span class="string">"本文包含绝密信息，请勿泄露！"</span>);  </span><br><span class="line">        <span class="comment">// 注意 watermark 聚合了 footer，而不是 textComp，这样就能够嵌套执行下去  </span></span><br><span class="line">        PrintDecorator watermark = <span class="keyword">new</span> TextWatermarkDecorator(footer, <span class="string">"绝密文档"</span>);  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//PrintServer 即 “文档打印系统”，与传统的 PrintServer 相比，这里不需要知道打印的 text 内容  </span></span><br><span class="line">        <span class="comment">//text 内容已经封装到 TextComponent 中去了（对应代码行 14 行）  </span></span><br><span class="line">        PrintServer.executePrintTask(watermark);  <span class="comment">// 注意这里传递给打印系统的是最后一个 Decorator 对象 watermark  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * A 部门的第二个打印任务，将文本水印改为图片水印，并且不再打印页脚 </span><br><span class="line">     * @param text </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> print2(<span class="keyword">String</span> <span class="built_in">text</span>)&#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">/** </span><br><span class="line">         * 新增打印任务，无需文档管理系统增加新的类，只要 A 部门自己修改代码即可 </span><br><span class="line">         */</span>  </span><br><span class="line">        PrintComponent textComp = <span class="keyword">new</span> TextComponent(<span class="built_in">text</span>);  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 注意 header 聚合了 textComp  </span></span><br><span class="line">        PrintDecorator header = <span class="keyword">new</span> HeaderDecorator(textComp, <span class="string">"绝密"</span>);    </span><br><span class="line">        <span class="comment">// 注意 watermark 聚合了 header，而不是 textComp，这样就能够嵌套执行下去  </span></span><br><span class="line">        PrintDecorator watermark = <span class="keyword">new</span> ImgWatermarkDecorator(header);  </span><br><span class="line">          </span><br><span class="line">        PrintServer.executePrintTask(watermark);    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，使用了设计模式的方法后，打印业务的变化，可以通过类似数学上的排列组合已有的打印功能来完成，而不再需要新的打印类了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;无意间发现这篇文章，文章讲解由浅入深，读完后感触很深&lt;br&gt;特全文转到自己的博客，方便以后自己随时查看&lt;br&gt;文章转载自爱技术的华仔的博客[&lt;a href=&quot;http://blog.csdn.net/yunhua_lee&quot;&gt;http://blog.csdn.net/yunhua_lee&lt;/a&gt;]&lt;br&gt;非常感谢&lt;a href=&quot;http://blog.csdn.net/yunhua_lee&quot;&gt;爱技术的华仔&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;第三十六章&quot;&gt;&lt;a href=&quot;#第三十六章&quot; class=&quot;headerlink&quot; title=&quot;第三十六章&quot;&gt;&lt;/a&gt;第三十六章&lt;/h1&gt;&lt;p&gt;经过前面深入的阐述，SOLID的原则我们已经基本上讲清楚了，但如果想熟练的应用SOLID原则，仅仅知道SOLID是什么（what）还不够，我们还需要知道SOLID原则在什么时候和什么场景应用（when或where）。
    
    </summary>
    
      <category term="软件笔记" scheme="http://i90s.vip/categories/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="转载" scheme="http://i90s.vip/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="面向对象" scheme="http://i90s.vip/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>连载：面向对象葵花宝典：思想、技巧与实践(28-35章)</title>
    <link href="http://i90s.vip/2016/05/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B84/"/>
    <id>http://i90s.vip/2016/05/15/面向对象葵花宝典4/</id>
    <published>2016-05-15T12:38:19.000Z</published>
    <updated>2016-05-26T15:22:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>无意间发现这篇文章，文章讲解由浅入深，读完后感触很深<br>特全文转到自己的博客，方便以后自己随时查看<br>文章转载自爱技术的华仔的博客[<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">http://blog.csdn.net/yunhua_lee</a>]<br>非常感谢<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">爱技术的华仔</a></p>
</blockquote>
<h1 id="第二十八章"><a href="#第二十八章" class="headerlink" title="第二十八章"></a>第二十八章</h1><p>前面通过实例讲解了一个一环扣一环的面向对象的开发流程：用例模型 -&gt; 领域模型 -&gt; 设计模型（类模型 + 动态模型），解答了面向对象如何做的问题。接下来我们就要讲“如何做好面向对象设计”的技巧了<a id="more"></a></p>
<p>===================================================================<br><strong>【内聚】</strong><br>参考维基百科的解释，内聚的含义如下：</p>
<blockquote>
<p>cohesion refers to the degree to which the elements of a <a href="http://en.wikipedia.org/wiki/Module_(programming" target="_blank" rel="external">module</a>) belong together.<br>（<a href="http://en.wikipedia.org/wiki/Cohesion_(computer_science)）" target="_blank" rel="external">http://en.wikipedia.org/wiki/Cohesion_(computer_science)）</a></p>
</blockquote>
<p>翻译一下即：<strong>内聚指一个模块内部元素彼此结合的紧密程度</strong>。</p>
<p>看起来很好理解，但深入思考一下，其实没有那么简单。<br>首先：“模块”如何理解？<br>你一定会说，“模块”当然就是我们所说的系统里的“XX模块”了，例如一个ERP系统的“权限”模块，一个电子商务的“支付”模块，一个论坛网站的“用户管理”模块。。。。。。等等</p>
<p>你说的没错，但在面向对象领域，谈到“内聚”的时候，模块的概念远远不止我们通常所理解的“系统内的某个模块”这个范围，而是可大可小，大到一个子系统，小到一个函数，你都可以理解为内聚里所说的“模块”。</p>
<p>所以，你可以用“内聚”来判断一个函数设计是否合理，一个类设计是否合理，一个接口设计是否合理，一个包设计是否合理，一个模块/子系统设计是否合理。</p>
<p>其次：“元素”究竟是什么？<br>有了前面对“模块”的深入研究后，元素的含义就比较容易明确了（不同语言稍有不同）。<br>函数：函数的元素就是“代码”<br>类/接口：类的元素是“函数、属性”<br>包：包的元素是“类、接口、全局数据”等<br>模块：模块的元素是“包、命名空间”等</p>
<p>再次：“结合”是什么？<br>英文的原文是“belong”，有“属于”的意思，翻译成中文“结合”，更加贴近中文的理解。但“结合”本身这个词容易引起误解。绝大部分人看到“结合”这个单词，想到的肯定是“你中有我、我中有你”这样的含义，甚至可能会联想到“美女和帅哥”的结合，抑或“青蛙王子和公主”的结合这种情况。<br>这样的理解本身也并没有错，但比较狭隘。<br>我们以类的设计为例：假如一个类里面的函数都是只依赖本类其它函数（当然不能循环调用啦），那内聚性肯定是最好的，因为“结合”得很紧密。</p>
<p>但如果这个类的函数并不依赖本类的函数呢？我们就一定能说这个类的内聚性不好么？<br>其实也不尽然，最常见的就是CRUD操作类，这几个函数相互之间没有任何结合关系（某些设计可能会先查询再修改，但这样的设计不是事务安全的），但其实这几个函数的内聚性非常高。</p>
<p>所以，关于内聚的结合概念，我认为不是非常恰当的描述。那么，就究竟什么才是真正的“内聚”呢？<br>答案就藏在显而易见的地方，翻开你的词典，仔细看看cohesion的含义，你会看到另外一个解释：凝聚力！</p>
<p><strong>“凝聚力”就是“内聚”的核心思想</strong>，抛开面向对象不谈，我们日常工作中几乎随处可见“凝聚力”：<br>你可能会说，你的团队很有凝聚力。。。。。。<br>领导可能会说：我们要增强团队的凝聚力。。。。。。<br>成功学大师会说：凝聚力是一个团队成功的基石。。。。。。。</p>
<p>面向对象领域的“凝聚力”，和团队的“凝聚力”是一样的概念。<br>l 判断团队凝聚力时，我们关注团队成员是否都专注于团队的目标；判断面向对象模块的凝聚力时，我们同样关注元素是否专注于模块的目标，即：模块本身的职责！<br>l 判断团队凝聚力时，我们还会关注团队成员之间是否互相吸引和帮助；判断面向对象模块凝聚力时，我们同样关注元素间的结合关系；</p>
<p>虽然判断内聚性的时候我们会考虑元素的结合情况，<strong>但其实是否专注模块的职责，才是内聚性的充要条件</strong>。<br>当模块的元素全部都专注于模块的职责的时候，即使元素间的结合不是很紧密，也是符合内聚性的要求的，这也是CRUD设计符合内聚性的原因。</p>
<p>所以，判断一个模块（函数、类、包、子系统）“内聚性”的高低，最重要的是关注模块的元素是否都忠于模块的职责，简单来说就是“不要挂羊头卖狗肉”。</p>
<p><strong>【耦合】</strong></p>
<p>参考维基百科，耦合的定义如下：</p>
<blockquote>
<p> coupling or dependency is the degree to which each <a href="http://en.wikipedia.org/wiki/Module_(programming" target="_blank" rel="external">program module</a>) relies on each one of the other modules<br>（<a href="http://en.wikipedia.org/wiki/Coupling_(computer_science)）" target="_blank" rel="external">http://en.wikipedia.org/wiki/Coupling_(computer_science)）</a></p>
</blockquote>
<p>简单翻译一下：耦合（或者称依赖）是程序模块相互之间的依赖程度。</p>
<p>从定义来看，耦合和内聚是相反的：内聚关注模块内部的元素结合程度，耦合关注模块之间的依赖程度。</p>
<p>理解耦合的关键有两点：什么是模块，什么是依赖。</p>
<p>什么是模块？<br>模块和内聚里面提到的模块一样，耦合中的模块其实也是可大可小。常见的模块有：函数、类、包、子模块、子系统等</p>
<p><strong>什么是依赖？</strong><br>依赖这个词很好理解，通俗的讲就是某个模块用到了另外一个模块的一些元素。<br>例如：A类使用了B类作为参数，A类的函数中使用了B类来完成某些功能。。。。。。等等</p>
<h1 id="第二十九章"><a href="#第二十九章" class="headerlink" title="第二十九章"></a>第二十九章</h1><p><strong>高内聚低耦合</strong>，可以说是每个程序猿，甚至是编过程序，或者仅仅只是在大学里面学过计算机，都知道的一个简单的设计原则。<br>虽然如此流行和人所众知，但其实<strong>真正理解的人并不多，很多时候都是人云亦云</strong>。</p>
<p>===============================================================<br>要想真正理解“高内聚低耦合”，需要回答两个问题：<br>1）为什么要高内聚低耦合？<br>2）高内聚低耦合是否意味内聚越高越好，耦合越低越好？</p>
<p><strong>第一个问题：为什么要高内聚低耦合？</strong><br>经典的回答是：降低复杂性。<br>确实很经典，当然，其实也是废话！我相信大部分人看了后还是不懂，什么叫复杂性呢？</p>
<p>要回答这个问题，其实可以采用逆向思维，即：如果我们不做到这点，将会怎样？<br>首先来看内聚，试想一下，假如我们是低内聚，情况将会如何？</p>
<p>前面我们在阐述内聚的时候提到内聚的关键在于“元素的凝聚力”，如果内聚性低，则说明凝聚力低；对于一个团队来说，如果凝聚力低，则一个明显的问题是“不稳定”；对于一个模块来说，内聚性低的问题也是一样的“不稳定”。具体来说就是如果一个模块内聚性较低，则这个模块很容易变化。一旦变化，设计、编码、测试、编译、部署的工作量就上来了，而一旦一个模块变化，与之相关的模块都需要跟着改变。</p>
<p>举一个简单的例子，假设有这样一个设计不好的类：Person，其同时具有“学生”、“运动员”、“演员”3个职责，有另外3个类“老师”、“教练”、“导演”依赖这个类。<br><strong>Person.java</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.cohesion.low;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “人”的类设计 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 学生的职责：学习 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> student's responsibility  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 运动员的职责：运动 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> sportsman's responsibility  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 演员的职责：扮演 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> actor's responsibity  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Teacher.java</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.cohesion.low;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “老师”的类设计 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Teacher</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span>(<span class="params">Person student</span>)</span>&#123;  </span><br><span class="line">        student.study(); <span class="comment">//依赖Person类的“学生”相关的职责  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Coach.java</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.cohesion.low;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “教练”的类设计 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Coach</span> &#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">train</span>(<span class="params">Person trainee</span>)</span>&#123;  </span><br><span class="line">        trainee.play();  <span class="comment">//依赖Person类的“运动员”职责  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Director.java</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.cohesion.low;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “导演”的类设计 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Director</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct</span>(<span class="params">Person actor</span>)</span>&#123;  </span><br><span class="line">        actor.act(); <span class="comment">//依赖Person类“演员”的相关职责  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的样例中，Person类就是一个典型的“低内聚”的类，很容易发生改变。比如说，现在老师要求学生也要考试，则Person类需要新增一个方法：test，如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.cohesion.low;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “人”的类设计 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 学生的职责：学习 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> student's responsibility  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 学生的职责：考试 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> student's responsibility  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 运动员的职责：运动 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> sportsman's responsibility  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 演员的职责：扮演 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> actor's responsibity  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Coach和Director类都依赖于Person类，Person类改变后，虽然这个改动和Coach、Director都没有关系，但Coach和Director类都需要重新编译测试部署（即使是PHP这样的脚本语言，至少也要测试）。</p>
<p>同样，Coach和Director也都可能增加其它对Person的要求，这样Person类就需要同时兼顾3个类的业务要求，且任何一个变化，Teacher、Coach、Director都需要重新编译测试部署。</p>
<p>对于耦合，我们采用同样的方式进行分析，<strong>即：如果高耦合，将会怎样？</strong><br>高耦合的情况下，模块依赖了大量的其它模块，这样任何一个其它依赖的模块变化，模块本身都需要受到影响。所以，高耦合的问题其实也是“不稳定”，当然，这个不稳定和低内聚不完全一样。对于高耦合的模块，可能本身并不需要修改，但每次其它模块修改，当前模块都要编译、测试、部署，工作量同样不小。</p>
<p>我们同样以一个样例来说明。假设我们要设计一个Boss类，Boss是要管整个公司的，那么我们假设这是一家“麻雀虽小五脏俱全”的公司，同时有“研发、测试、技术支持、销售、会计、行政”等部门。<br><strong>Boss.java</strong><br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.coupling</span><span class="selector-class">.high</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “老板”类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">Boss</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    private Tester tester;  </span><br><span class="line">    private Developer developer;  </span><br><span class="line">    private Supporter supporter;  </span><br><span class="line">    private Administration admin;  </span><br><span class="line">    private Accountant accountant;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * Boss每天检查工作，看到下面的代码，是否觉得Boss很忙？ </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">check</span>()&#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//检查测试工作  </span></span><br><span class="line">        tester<span class="selector-class">.report</span>();  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//检查研发工作  </span></span><br><span class="line">        developer<span class="selector-class">.report</span>();  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//检查技术支持工作  </span></span><br><span class="line">        supporter<span class="selector-class">.report</span>();  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//检查行政工作  </span></span><br><span class="line">        admin<span class="selector-class">.report</span>();  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//检查财务工作  </span></span><br><span class="line">        accountant<span class="selector-class">.report</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Accountant.java</strong><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.coupling.high;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * “财务”类 </span><br><span class="line"> * </span><br><span class="line"> */  </span><br><span class="line">public class Accountant &#123;  </span><br><span class="line">  </span><br><span class="line">    public void report()&#123;  </span><br><span class="line">        System.out.print("Accountant report");  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="strong">**Administration.java**</span></span><br><span class="line"><span class="strong">**[java]**</span> [<span class="string">view plain</span>](<span class="link">http://blog.csdn.net/yunhua_lee/article/details/25074707#</span>) [<span class="string">copy</span>](<span class="link">http://blog.csdn.net/yunhua_lee/article/details/25074707#</span>)</span><br><span class="line"> [<span class="string">![在CODE上查看代码片</span>](<span class="link">https://code.csdn.net/assets/CODE_ico.png</span>)](<span class="link">https://code.csdn.net/snippets/328340</span>)[<span class="string">![派生到我的代码片</span>](<span class="link">https://code.csdn.net/assets/ico_fork.svg</span>)](<span class="link">https://code.csdn.net/snippets/328340/fork</span>)</span><br><span class="line"></span><br><span class="line">package com.oo.coupling.high;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * “行政”类  </span><br><span class="line"> * </span><br><span class="line"> */  </span><br><span class="line">public class Administration &#123;  </span><br><span class="line">  </span><br><span class="line">    public void report()&#123;  </span><br><span class="line">        System.out.print("Administration report");  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Developer.java</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.coupling.high;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “开发”类 </span><br><span class="line"> * @author Administrator </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Developer</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.print(<span class="string">"Developer report"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Supporter.java</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.coupling.high;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “技术支持”类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Supporter</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.print(<span class="string">"Supporter report"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Tester.java</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.coupling.high;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “测试”类 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tester</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.print(<span class="string">"Tester report"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好吧，Boss很忙，我们也很钦佩，但是有一天，研发的同学觉得他们应该做更多的事情，于是他们增加了一个“研究”的工作，且这个工作也不需要报告给Boss，例如：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.coupling.high;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * “开发”类 </span><br><span class="line"> * @author Administrator </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Developer</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.print(<span class="string">"Developer report"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 研发新增加一个研究的任务，这个任务也不需要向Boss汇报 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">research</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.print(<span class="string">"Developer is researching big data, hadoop :)"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然这个工作不需要报告给Boss，但由于Developer类修改了，那么Boss类就需要重新编译测试部署。其它几个Tester、Supporter类等也是类似，一旦改变，即使这些类和Boss类半毛钱关系都没有，Boss类还是需要重新编译测试部署，所以Boss类是很不稳定的。</p>
<p>所以，无论是“低内聚”，还是“高耦合”，其本质都是“不稳定”，不稳定就会带来工作量，带来风险，这当然不是我们希望看到的，所以我们应该做到“高内聚低耦合”。</p>
<p>回答完第一个问题后，我们来看第二个问题：高内聚低耦合是否意味着内聚越高越好，耦合越低越好？<br>按照我们前面的解释，内聚越高，一个类越稳定；耦合越低，一个类也很稳定，所以当然是内聚越高越好，耦合越低越好了。<br>但其实稍有经验的同学都会知道这个结论是错误的，并不是内聚越高越好，耦合越低越好，<strong>真正好的设计是在高内聚和低耦合间进行平衡，也就是说高内聚和低耦合是冲突的</strong>。</p>
<p>我们详细来分析一下为什么高内聚和低耦合是冲突的。<br>对于内聚来说，最强的内聚莫过于一个类只写一个函数，这样内聚性绝对是最高的。但这会带来一个明显的问题：类的数量急剧增多，这样就导致了其它类的耦合特别多，于是整个设计就变成了“高内聚高耦合”了。由于高耦合，整个系统变动同样非常频繁。</p>
<p>同理，对于耦合来说，最弱的耦合是一个类将所有的函数都包含了，这样类完全不依赖其它类，耦合性是最低的。但这样会带来一个明显的问题：内聚性很低，于是整个设计就变成了“低耦合低内聚”了。由于低内聚，整个类的变动同样非常频繁。<br>对于“低耦合低内聚”来说，还有另外一个明显的问题：几乎无法被其它类重用。原因很简单，类本身太庞大了，要么实现很复杂，要么数据很大，其它类无法明确该如何重用这个类。</p>
<p>所以，内聚和耦合的两个属性，排列组合一下，<strong>只有“高内聚低耦合”才是最优的设计</strong>。<br>因此，在实践中我们需要牢牢记住需要在高内聚和低耦合间进行平衡，而不能走极端。 具体如何平衡，且听下回分解。</p>
<h1 id="第三十章"><a href="#第三十章" class="headerlink" title="第三十章"></a>第三十章</h1><p>前面详细阐述了“高内聚低耦合”的总体设计原则，但如何让设计满足这个原则，并不是一件简单的事情，幸好各位前辈和大牛已经帮我们归纳总结出来了，这就是“设计原则”和“设计模式”。毫不夸张的说，<strong>只要你吃透这些原则和模式并熟练应用，就能够做出很好的设计</strong>。</p>
<p>==================================================================</p>
<p><strong>【SRP原则详解】</strong><br>SRP，single responsibility principle，中文翻译为“单一职责原则”！</p>
<p>这是面向对象类设计的第一个原则，也是看起来最简单的一个原则，但这实际上远远没有那么简单，很多人都不一定真正理解了！</p>
<p>我们随便找几个网上的解释，看看各位大师或者经典网站是如何解释的：<br>百度百科（<a href="http://baike.baidu.com/view/1545205.htm" target="_blank" rel="external">http://baike.baidu.com/view/1545205.htm</a>）：</p>
<blockquote>
<p>一个类应该有且仅有一个职责。关于职责的含意，面向对象大师Robert.C.Martin有一个著名的定义：所谓一个类的职责是指引起该类变化的原因，如果一个类具有一个以上的职责，那么就会有多个不同的原因引起该类变化，其实就是耦合了多个互不相关的职责，就会降低这个类的内聚性。</p>
</blockquote>
<p>说句实话，虽然是面向对象大师Martin的解释，我还是看得不甚明白：引起类变化的原因太多了，例如：<br>给类加一个方法是变化吧？<br>给类加一个属性是变化吧？<br>类的函数增加一个参数是变化吧？<br>。。。。。。<br>引起这些变化的原因太多了，如果每个原因都是一个职责，那SRP原则简直就没法判断了！</p>
<p>Wiki百科（<a href="http://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="external">http://en.wikipedia.org/wiki/Single_responsibility_principle</a> ）内容和百度百科基本一致，看起来百度百科像wiki百科的翻译：）</p>
<blockquote>
<p>Martin defines a responsibility as a reason to change, and concludes that a class or module should have one, and only one, reason to change.</p>
</blockquote>
<p>除了这些标准的解释外，还有一种说法：SRP就是指每个类只做一件事！<br>这个解释更通俗易懂，也更加适合中国人理解。虽然比Martin大师的解释更清楚一些，但仔细想想，还是有个地方比较难以理解：什么叫做“一件事”？</p>
<p>比如说一个学生信息管理类，这个类有“添加学生信息”、“查询学生信息”、“修改学生信息”、“删除学生信息”，那么这是4件事情，还是一件事情呢？</p>
<p>看起来好像是4个事情，但稍有经验的朋友应该都知道，这4个事情绝大部分情况下都是一个类来实现的，而不是分成4个类！</p>
<p>所以关键的问题在于：什么是“一件事”？是每个功能一件事情么？ </p>
<p>其实答案就在我们自己身上，因为只要我们工作，无时不刻的承担着一定的“职责”！<br>现在让我们抛开面向对象，抛开软件，抛开计算机，来看看我们自己的“职责”。</p>
<p>比如说，我是一个程序猿，我的职责应该是“写程序”，但写程序有很多事情，例如：编码，单元测试、系统测试，bug修复，开会，写文档。。。。。。<br>再比如说，我的BOSS是一个管理者，他的职责是“管理程序猿”，他也有很多工作，例如：制定计划，团队建设、开会、协调资源、写文档。。。。。。<br>又比如说，我是一个快递员，也有很多工作：分包、快递、收款、开会。。。。。。</p>
<p>这些职责其实都不是我们自己定义的，而是公司或者部门或者组织给我们安排工作的时候定义的，也就是说：“职责”是站在他人的角度来定义的，而不是自己定义的，也许你想把自己定义成CEO，但你的老板会真的让你当CEO么？</p>
<p>经过对我们自己的职责的分析，我们可以得出两个关于职责的重要结论：<br>1） 职责是站在他人的角度来定义的<br>2） 职责不是一件事，而是很多事情，但这些事情都是和职责紧密相关的</p>
<p>对应到面向对象设计领域，我们可以说一个类的职责应该如下定义：<br>1） 类的职责是站在其它类的角度来定义的；<br>2） 类的职责包含多个相关功能；</p>
<p>因此，SRP可以翻译成“<strong>一个类只负责一组相关的事情</strong>”，对应到代码中就是：一个类有多个方法，这些方法是相关的。</p>
<p>当然，如果你再让我解释什么是“相关”，那我只能吐血了：）</p>
<p>有了这个定义，我们再来看“学生信息管理类”，很明显，学生管理类具有的4个功能都是和“管理”相关的，按照SRP原则，应该只设计一个“学生信息管理类”就可以了。</p>
<p><strong>【SRP原则范围】</strong><br>但现实世界往往比理想要复杂，一个最典型的例子就是“办公一体机”。<br>根据SRP原则，打印机可以设计成一个类，复印机也可以设计成一个类，扫描仪也可以设计成一个类，传真机还是可以设计成一个类，但偏偏就是出了个“办公一体机”，这个机器集成了“打印、复印、扫描、传真”4个职责！<br>如果我们要设计一个“办公一体机”的类，怎么也不可能设计出一个符合SRP原则的“办公一体机”的类来！</p>
<p>怎么办？是SRP不正确么，还是我们永远都不要设计“办公一体机”这样的类？</p>
<p>其实SRP也没有错，“办公一体机”也应该设计，但：不要用SRP来约束“办公一体机”这样的类！<br>也就是说，SRP其实是有适应范围的，SRP只适合那些基础类，而不适合基于基础类构建复杂的聚合类。</p>
<p>在“办公一体机“的样例中，“打印机”、“复印机”、“扫描仪”、“传真机”都是基础类，每个类都承担一个职责，而办公一体机是“聚合类”，同时集成了4种功能！</p>
<p>细心的朋友可能会继续问道：SRP不能应用于聚合类，那么如何保证聚合类的设计质量呢？<br>这个问题的答案在GoF的《设计模式》一书中有详细的答案，即：优先使用对象组合，而不是类继承。详细内容请参考后续“设计模式”部分的内容</p>
<h1 id="第三十一章"><a href="#第三十一章" class="headerlink" title="第三十一章"></a>第三十一章</h1><p>开闭原则是一个大部分人都知道，但大部分人都不懂的设计原则！</p>
<p>====================================================================<br>OCP，Open-Closed Principle，中文翻译为“开闭原则”。</p>
<p>当我第一次看到OCP原则时，我的感觉就是这原则也太抽象了吧，什么开，什么闭呢？</p>
<p>然后我去寻找更加详细的答案，最经典也是最常见的解释就是维基百科了：<br><a href="http://en.wikipedia.org/wiki/Open/closed_principle" target="_blank" rel="external">http://en.wikipedia.org/wiki/Open/closed_principle</a> </p>
<blockquote>
<p>“software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification”;</p>
</blockquote>
<p>翻译一下就是：对扩展开放，对修改封闭！</p>
<p>虽然这句解释更详细了，但其实还是很难理解，我因此去请教了一个前辈高人，他的回答更加惊世骇俗：不修改代码就可以增加新功能！！</p>
<p>当时我听到这句话就震惊了，这是多么神奇的事情啊，不修改代码就能够增加新功能！<br>但问题是：怎么做到的呢？难道这个原则是有关<a href="http://lib.csdn.net/base/2" target="_blank" rel="external">人工智能</a>，又或者有什么高超的技巧，能够做到不修改代码增加新功能？</p>
<p>这么牛逼的原则当然要继续探索了，但怎么也没有找到“不修改代码就可以增加新功能”的独门秘籍！</p>
<p>于是对这个原则有了怀疑，经过继续的探索和查看各种资料，才发现原来是各位大师们在解释这个原则的时候隐藏了非常重要的“主语”，而这才是OCP原则的关键！</p>
<p>大师们省略的主语一个就是consumer（翻译成使用者、消费者），一个就是provider（翻译成生产者、提供着），例如A类调用了B类的方法，则A就是consumer，B就是provider。</p>
<p>完整的OCP原则实际上应该这样表述：open for provider extension，closed for consumer modification，翻译一下就是：对使用者修改关闭，对提供者扩展开放！</p>
<p>更通俗的意思就是：提供者增加新的功能，但使用者不需要修改代码！</p>
<p>虽然到这里我们已经基本上将OCP原则解释清楚了，但实际上细心的朋友还是会发现有问题的：提供者增加新的功能，使用者不修改代码就能用上么？<br>比如说：你设计一款有关车游戏，需要设计一个“car”的类，这个类原来有“加速”、“刹车”、“转向”三个功能，现在你要加一个新功能“改装”，游戏中其它类例如player，不修改代码就可以用上“改装”这个功能么？</p>
<p>很显然这是不可能的，我都新加了一个函数，你都不调用就能用新的功能，这也太邪乎了吧？</p>
<p>答案在于所谓的增加新功能，并不是增加一个全新的功能，而是原有的功能有了替代实现，这也是英文的“extension”所隐含的深意！</p>
<p>继续以赛车car作为例子，假设现在你设计了“卡车”、“跑车”、“家用车”三种车，现在要增加一种车“卡丁车”，只要“卡丁车”也实现了“加速”、“刹车”、“转向”，那么player不需要修改代码，就可以玩“卡丁车”了；但如果你增加了一种“改装”的功能，那么player必须修改才能使用“改装”功能。</p>
<p>对应到代码上来说，OCP的应用原则如下：<br>1） <strong>接口不变</strong>：包括函数名、函数参数、函数返回值等，可以应用OCP<br>2） <strong>接口改变</strong>：已有函数修改名称、参数、返回值，或者增加新的函数，OCP都不再适应</p>
<p>虽然OCP原则是针对类设计提出来的原则，但其思想其实适应很广，系统和系统、子系统和子系统、模块和模块之间都可以应用OCP原则，而且不同的地方应用其实都是遵循同一个原则：<strong>通过接口交互</strong>！例如：<br>1） 类之间应用OCP：使用interface进行交互；<br>2）模块和模块、系统和系统：使用规定好的协议，不管是私有的还是公开的，例如HTTP、SOAP</p>
<h1 id="第三十二章"><a href="#第三十二章" class="headerlink" title="第三十二章"></a>第三十二章</h1><h1 id="LSP是唯一一个以人名命名的设计原则，而且作者还是一个“女博士”"><a href="#LSP是唯一一个以人名命名的设计原则，而且作者还是一个“女博士”" class="headerlink" title="LSP是唯一一个以人名命名的设计原则，而且作者还是一个“女博士” "></a>LSP是唯一一个以人名命名的设计原则，而且作者还是一个“女博士” </h1><hr>
<p><strong>LSP</strong>，Liskov substitution principle，中文翻译为“<strong>里氏替换原则</strong>”。</p>
<p>这是面向对象原则中唯一一个以人名命名的原则，虽然Liskov在中国的知名度没有UNIX的几位巨匠（Kenneth Thompson、Dennis Ritchie）、GOF四人帮那么响亮，但查一下资料，你会发现其实Liskov也是非常牛的：2008年图灵奖获得者，历史上第一个女性计算机博士学位获得者。其详细资料可以在维基百科上查阅：<a href="http://en.wikipedia.org/wiki/Barbara_Liskov" target="_blank" rel="external">http://en.wikipedia.org/wiki/Barbara_Liskov</a> </p>
<p>言归正传，我们来看看LSP原则到底是怎么一回事。<br>LSP最原始的解释当然来源于Liskov女士了，她在1987年的OOPSLA大会上提出了LSP原则，1988年，她将文章发表在ACM的SIGPLAN Notices杂志上，其中详细解释了LSP原则：<br>A type hierarchy is composed of subtypes and supertypes. The intuitive idea of a subtype is one whose objects provide all the behavior of objects of another type (the supertype) plus something extra.What is wanted here is something like the following substitution property: If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.</p>
<p>英文比较长，看起来比较累，我们简单的翻译并归纳一下：<br>1） <strong>子类的对象提供了父类的所有行为</strong>，且加上子类额外的一些东西（可以是功能，也可以是属性）；<br>2） 当程序基于父类实现时，<strong>如果将子类替换父类而程序不需要修改</strong>，则说明符合LSP原则</p>
<p>虽然我们稍微翻译和整理了一下，但实际上还是很拗口和难以理解。<br>幸好还有Martin大师也觉得这个不怎么通俗易懂，Robert Martin在1996年为《C++ Reporter》写了一篇题为《The The Liskov Substitution Principle》的文章，解释如下：<br>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</p>
<p>翻译一下就是：函数使用指向父类的指针或者引用时，必须能够在不知道子类类型的情况下使用子类的对象。</p>
<p>Martin大师解释了一下，相对容易理解多了。但Martin大师还不满足，在2002年，Martin在他出版的《Agile   Software   Development   Principles   Patterns   and   Practices》一书中，又进一步简化为：<br>Subtypes   must   be   substitutable   for   their   base   types。</p>
<p>翻译一下就是：子类必须能替换成它们的父类。</p>
<p>经过Martin大师的两次翻译，我相信LSP原则本身已经解释得比较容易理解了，但问题的关键是：如何满足LSP原则？或者更通俗的讲：什么情况下子类才能替换父类？</p>
<p>我们知道，对于调用者来说（Liskov解释中提到的P），和父类交互无非就是两部分：调用父类的方法、得到父类方法的输出，中间的处理过程，P是无法知道的。</p>
<p>也就是说，调用者和父类之间的联系体现在两方面：函数输入，函数输出。详细如下图：<br> <img src="http://ww3.sinaimg.cn/large/666cc9e3gw1f4977znz1ij208401na9x.jpg" alt=""><br>有了这个图之后，如何做到LSP原则就清晰了：<br>1） <strong>子类必须实现或者继承父类所有的公有函数</strong>，否则调用者调用了一个父类中有的函数，而子类中没有，运行时就会出错；<br>2） <strong>子类每个函数的输入参数必须和父类一样</strong>，否则调用父类的代码不能调用子类；<br>3） <strong>子类每个函数的输出</strong>（返回值、修改全局变量、插入数据库、发送网络数据等）必须不比父类少，否则基于父类的输出做的处理就没法完成。</p>
<p>有了这三条原则后，就可以很方便的判断类设计是否符合LSP原则了。需要注意的是第3条的关键是“不比父类少”，也就是说可以比父类多，即：父类的输出是子类输出的子集。</p>
<p>有的朋友看到这三条原则可能有点纳闷：这三条原则一出，那子类还有什么区别哦，岂不都是一样的实现了，那还会有不同的子类么？</p>
<p>其实如果仔细研究这三条原则，就会发现其中<strong>只是约定了输入输出，而并没有约束中间的处理过程</strong>。例如：同样一个写数据库的输出，A类可以是读取XML数据然后写入数据库，B类可以是从其它数据库读取数据然后本地的数据库，C类可以是通过分析业务日志得到数据然后写入数据库。这3个类的处理过程都不一样，但最后都写入数据到数据库了。</p>
<p>LSP原则最经典的例子就是“长方形和正方形”这个例子。从数学的角度来看，正方形是一种特殊的长方形，但从面向对象的角度来观察，正方形并不能作为长方形的一个子类。原因在于对于长方形来说，设定了宽高后，面积 = 宽 <em> 高；但对于正方形来说，设定高同时就设定了宽，设定宽就同时设定了高，最后的面积并不是等于我们设定的 宽 </em> 高，而是等于最后一次设定的宽或者高的平方。</p>
<p>具体代码样例如下：<br>Rectangle.Java<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.oo.java.principles.lsp;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 长方形 </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Rectangle &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> _width;  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> _height;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 设定宽 </span><br><span class="line">     * @param width </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setWidth(<span class="keyword">int</span> <span class="built_in">width</span>)&#123;  </span><br><span class="line">        <span class="keyword">this</span>._width = <span class="built_in">width</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 设定高 </span><br><span class="line">     * @param height </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setHeight(<span class="keyword">int</span> <span class="built_in">height</span>)&#123;  </span><br><span class="line">        <span class="keyword">this</span>._height = <span class="built_in">height</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 获取面积 </span><br><span class="line">     * @return </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getArea()&#123;  </span><br><span class="line">        <span class="built_in">return</span> <span class="keyword">this</span>._width * <span class="keyword">this</span>._height;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Square.java<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.oo.java.principles.lsp;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 正方形 </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Square extends Rectangle &#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 设定“宽”，与长方形不同的是：设定了正方形的宽，同时就设定了正方形的高 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setWidth(<span class="keyword">int</span> <span class="built_in">width</span>)&#123;  </span><br><span class="line">        <span class="keyword">this</span>._width = <span class="built_in">width</span>;  </span><br><span class="line">        <span class="keyword">this</span>._height = <span class="built_in">width</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 设定“高”，与长方形不同的是：设定了正方形的高，同时就设定了正方形的宽 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setHeight(<span class="keyword">int</span> <span class="built_in">height</span>)&#123;  </span><br><span class="line">        <span class="keyword">this</span>._width = <span class="built_in">height</span>;  </span><br><span class="line">        <span class="keyword">this</span>._height = <span class="built_in">height</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>UnitTester.java<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.oo.java.principles.lsp;  </span><br><span class="line">  </span><br><span class="line">public class UnitTester &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] <span class="built_in">args</span>)&#123;  </span><br><span class="line">        Rectangle <span class="built_in">rectangle</span> = <span class="built_in">new</span> Rectangle();  </span><br><span class="line">        <span class="built_in">rectangle</span>.setWidth(<span class="number">4</span>);  </span><br><span class="line">        <span class="built_in">rectangle</span>.setHeight(<span class="number">5</span>);  </span><br><span class="line">          </span><br><span class="line">        //如下assert判断为<span class="literal">true</span>  </span><br><span class="line">        assert( <span class="built_in">rectangle</span>.getArea() == <span class="number">20</span>);  </span><br><span class="line">          </span><br><span class="line">        <span class="built_in">rectangle</span> = <span class="built_in">new</span> Square();  </span><br><span class="line">        <span class="built_in">rectangle</span>.setWidth(<span class="number">4</span>);  </span><br><span class="line">        <span class="built_in">rectangle</span>.setHeight(<span class="number">5</span>);  </span><br><span class="line">          </span><br><span class="line">        //&lt;span <span class="built_in">style</span>=<span class="string">"color:#ff0000;"</span>&gt;如下assert判断为<span class="literal">false</span>，断言失败，抛出java.lang.AssertionError&lt;/span&gt;  </span><br><span class="line">        assert( <span class="built_in">rectangle</span>.getArea() == <span class="number">20</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这个样例同时也给出了一个判断子类是否符合LSP的取巧的方法，即：针对父类的单元测试用例，传入子类是否也能够测试通过。如果测试能够通过，则说明符合LSP原则，否则就说明不符合LSP原则</p>
<h1 id="第三十三章"><a href="#第三十三章" class="headerlink" title="第三十三章"></a>第三十三章</h1><p><strong>ISP</strong>，Interface Segregation Principle，中文翻译为“<strong>接口隔离原则</strong>”。</p>
<p>和DIP原则一样，ISP原则也是大名鼎鼎的Martin大师提出来的，他在1996年的C++ Reporter发表“ The Interface Segregation Principle”的文章详细阐述了ISP原则，并且在他的经典著作《 Agile Software Development, Principles, Patterns》（中文翻译为：敏捷软件开发：原则、模式与实践）、《Practices, and Agile Principles, Patterns, and Practices in C#》（中文翻译为：敏捷软件开发：原则、模式与实践（C#版））中详细解释了ISP原则。</p>
<p>ISP最原始的定义如下：<br>“CLIENTS SHOULD NOT BE FORCED TO DEPEND UPON INTERFACES THAT THEY DO NOT USE.”<br>翻译成中文就是“客户端不应该被强迫去依赖它们并不需要的接口”。</p>
<p>单纯从字面意思来看，ISP原则是5个原则中最好理解的一个了。但是我们深入思考一下，其实发现也没有那么简单。如果你还记得我们前面讲的那些原则，你可能会想到一个问题：既然有了SRP，为什么还要ISP？</p>
<p>现在我们来回想一下SRP原则，如果类满足了SRP原则，那么基于这个类提炼的接口不就自然而然的满足了ISP原则了么？为什么我们还要费神费力的又搞一个ISP原则呢？</p>
<p>Martin大师自然不会是吃饱了没事做，故意整个东东来折腾大家，他在ISP的论文中有这么一句话交代了ISP原则，可惜的是很多人都没有把这句话贴出来：<br>The ISP acknowledges that there are objects that require non-cohesive interfaces;<br>however it suggests that clients should not know about them as a single class. Instead, clients<br>should know about abstract base classes that have cohesive interfaces.</p>
<p>翻译一下：ISP原则承认对象需要非内聚的接口，然而ISP原则建议客户端不需要知道整个类，只需要知道具有内聚接口的抽象父类即可。</p>
<p>也就是说，<strong>ISP应用的场景是某些类不满足SRP原则，但使用这些类的客户端（即调用的类）应该根据接口来使用它，而不是直接使用它</strong>。</p>
<p>虽然翻译了一下，但还是比较抽象，给个例子一看就明白了，而且已经有一个很好的例子了，即SRP原则中的“一体机”。</p>
<p>在“一体机”的样例中，虽然“一体机”同时具备“打印、复印、扫描、传真”的功能，但我们并不会设计一个“一体机”的接口，而是设计4个接口。这样调用接口的类可以根据自己需要精确使用某个接口，而不是调用一个大而全的接口。</p>
<p>具体代码如下：</p>
<p>ICopier.Java</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.java.principles.isp;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 复印机接口 </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICopier</span> &#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 复印 </span><br><span class="line">     * @param paper </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">copy</span>(<span class="params">Paper paper</span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IFaxMachine.java<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.oo.java.principles.isp;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * 传真机接口 </span><br><span class="line"> */  </span><br><span class="line">public interface IFaxMachine &#123;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 传真 </span><br><span class="line">     * @param msg </span><br><span class="line">     */  </span><br><span class="line">    void fax(String msg);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">IPrinter.java</span><br><span class="line"><span class="strong">**[java]**</span> [<span class="string">view plain</span>](<span class="link">http://blog.csdn.net/yunhua_lee/article/details/27698945#</span>) [<span class="string">copy</span>](<span class="link">http://blog.csdn.net/yunhua_lee/article/details/27698945#</span>)</span><br><span class="line"> [<span class="string">![在CODE上查看代码片</span>](<span class="link">https://code.csdn.net/assets/CODE_ico.png</span>)](<span class="link">https://code.csdn.net/snippets/370671</span>)[<span class="string">![派生到我的代码片</span>](<span class="link">https://code.csdn.net/assets/ico_fork.svg</span>)](<span class="link">https://code.csdn.net/snippets/370671/fork</span>)</span><br><span class="line"></span><br><span class="line">package com.oo.java.principles.isp;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * 打印机接口 </span><br><span class="line"> */  </span><br><span class="line">public interface IPrinter &#123;  </span><br><span class="line">      </span><br><span class="line">    /** </span><br><span class="line">     * 打印 </span><br><span class="line">     * @param doc </span><br><span class="line">     */  </span><br><span class="line">    void print(Document doc);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>IScanner.java<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.java.principles.isp;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 扫描仪接口 </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IScanner</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 扫描 </span><br><span class="line">     * @param paper </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scan</span>(<span class="params">Paper paper</span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MultiFuncPrinter.java<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.java</span><span class="selector-class">.principles</span><span class="selector-class">.isp</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 多功能打印机（一体机） </span><br><span class="line"> * 实现了IFaxMachine（传真机）、ICopier（复印机）、IPrinter（打印机）、IScanner（扫描仪）4个接口 </span><br><span class="line"> * 而不是提供一个IMultiFuncPrinter的接口，同时提供以上接口的功能 </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">MultiFuncPrinter</span> <span class="selector-tag">implements</span> <span class="selector-tag">IFaxMachine</span>, <span class="selector-tag">ICopier</span>, <span class="selector-tag">IPrinter</span>, <span class="selector-tag">IScanner</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void scan(Paper paper) &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void print(Document doc) &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void copy(Paper paper) &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void fax(String msg) &#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>People.java<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.java</span><span class="selector-class">.principles</span><span class="selector-class">.isp</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 人 </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">People</span> &#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 复印操作，copy方法依赖ICopier接口，而不是使用MutiFuncPrinter类 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">copy</span>(ICopier copier, Paper paper)&#123;  </span><br><span class="line">        copier<span class="selector-class">.copy</span>(paper);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 打印操作，print方法依赖IPrinter接口，而不是使用MutiFuncPrinter类 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">print</span>(IPrinter printer, Document doc)&#123;  </span><br><span class="line">        printer<span class="selector-class">.print</span>(doc);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 传真操作，fax方法依赖IFaxMachine接口，而不是使用MutiFuncPrinter类 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">fax</span>(IFaxMachine faxer, String message)&#123;  </span><br><span class="line">        faxer<span class="selector-class">.fax</span>(message);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 扫描操作，scan方法依赖IScanner接口，而不是使用MutiFuncPrinter类 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">scan</span>(IScanner scanner, Paper paper)&#123;  </span><br><span class="line">        scanner<span class="selector-class">.scan</span>(paper);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Tester.java<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.oo.java.principles.isp;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Tester &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> mai(String args[])&#123;  </span><br><span class="line">        People people = <span class="keyword">new</span> People();  </span><br><span class="line">        MultiFuncPrinter mfp = <span class="keyword">new</span> MultiFuncPrinter();  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//如下函数都是使用mfp作为参数，但实际上是使用了MultiFuncPrinter类实现了的不同接口  </span></span><br><span class="line">        people.<span class="keyword">copy</span>(mfp, <span class="keyword">new</span> Paper());     <span class="comment">//使用了MultiFuncPrinter类的ICopier接口，  </span></span><br><span class="line">        people.fax(mfp, <span class="string">"I love oo"</span>);      <span class="comment">//使用了MultiFuncPrinter类的IFaxMachine接口，  </span></span><br><span class="line">        people.<span class="keyword">print</span>(mfp, <span class="keyword">new</span> Document()); <span class="comment">//使用了MultiFuncPrinter类的IPrinter接口，  </span></span><br><span class="line">        people.scan(mfp, <span class="keyword">new</span> Paper());     <span class="comment">//使用了MultiFuncPrinter类的IScanner接口，  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="第三十四章"><a href="#第三十四章" class="headerlink" title="第三十四章"></a>第三十四章</h1><p>DIP，dependency inversion principle<strong>，中文翻译为“依赖倒置原则”。</strong></p>
<p>DIP是大名鼎鼎的Martin大师提出来的，他在1996 5月的C++ Reporter发表“ The Dependency Inversion Principle”的文章详细阐述了DIP原则，并且在他的经典著作《 Agile Software Development, Principles, Patterns》（中文翻译为：敏捷软件开发：原则、模式与实践）、《Practices, and Agile Principles, Patterns, and Practices in C#》（中文翻译为：敏捷软件开发：原则、模式与实践（C#版））中详细解释了DIP原则。</p>
<p>DIP原则主要有两点含义：<br>1） 高层模块不应该直接依赖低层模块，两者都应该依赖抽象层；<br>2） 抽象不能依赖细节，细节必须依赖抽象；</p>
<p>虽然DIP原则的解释非常清楚，但要真正理解也不那么简单，因为有几个关键的术语都比较抽象，我们需要更详细的解析：<br>1）什么是模块？<br>英文中用到了module、component，但我们这是在讲类的设计原则，为什么要把DIP拉进来呢？<br>其实Martin大师只是讲一个设计原则而已，这个原则可以应用到软件系统不同的层级。<br>例如：站在<a href="http://lib.csdn.net/base/16" target="_blank" rel="external">架构</a>层的角度，模块可以指子系统subsystem<br>站在子系统的角度，模块可以指module，component<br>站在模块的角度：模块可以指类<br>所以说，这里的模块应该是一个广义的概念，而不是狭义的软件系统里各个子模块。</p>
<p>2）什么是依赖？<br>这里的依赖对应到具体的面向对象领域其实包含几个内容：<br>高层模块“依赖”低层模块：指高层模块需要调用低层模块的方法；<br>高层模块依赖抽象层：指高层模块基于抽象层编程；<br>低层模块依赖抽象层：指低层模块继承（inheritance）或者实现（implementation）抽象层；<br>细节依赖抽象：其实和上一个依赖是同一个意思；</p>
<p>所以说，大师就是大师啊，一个简简单单的“依赖”将各种情况都概括进来了，只是苦了我们这些平凡人，要么导致无法理解，要么导致理解错误：（</p>
<p>我们以一个简单样例来详细解释这些依赖，样例包含一个Player类，代表玩家；ICar接口，代表汽车；Benz、Ford、Chery代表具体的汽车，详细的代码如下</p>
<p>【Player】<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.oop</span><span class="selector-class">.dip</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 玩家，对应DIP中的“高层模块”  </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">Player</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 开福特 </span><br><span class="line">     * 不好的依赖：对应DIP中的“高层模块依赖低层模块”，Player直接使用了Ford类对象作为参数，Ford类修改，Player类【需要】重新编译测试 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">play</span>(Ford car)  </span><br><span class="line">    &#123;  </span><br><span class="line">        car<span class="selector-class">.accelerate</span>();  </span><br><span class="line">        car<span class="selector-class">.shift</span>();  </span><br><span class="line">        car<span class="selector-class">.steer</span>();  </span><br><span class="line">        car<span class="selector-class">.brake</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 开奔驰 </span><br><span class="line">     * 不好的依赖：对应DIP中的“高层模块依赖低层模块”，Player直接使用了Benz类对象作为参数，Benz类修改，Player类【需要】重新编译测试 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">play</span>(Benz car)  </span><br><span class="line">    &#123;  </span><br><span class="line">        car<span class="selector-class">.accelerate</span>();  </span><br><span class="line">        car<span class="selector-class">.shift</span>();  </span><br><span class="line">        car<span class="selector-class">.steer</span>();  </span><br><span class="line">        car<span class="selector-class">.brake</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 开奇瑞 </span><br><span class="line">     * 不好的依赖：对应DIP中的“高层模块依赖低层模块”，Player直接使用了Chery类对象作为参数，Chery类修改，Player类【需要】重新编译测试 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">play</span>(Chery car)  </span><br><span class="line">    &#123;  </span><br><span class="line">        car<span class="selector-class">.accelerate</span>();  </span><br><span class="line">        car<span class="selector-class">.shift</span>();  </span><br><span class="line">        car<span class="selector-class">.steer</span>();  </span><br><span class="line">        car<span class="selector-class">.brake</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 开车 </span><br><span class="line">     * 好的依赖： 对应DIP中的“高层模块依赖抽象层”，Player依赖ICar接口，不需要知道具体的车类型，Ford、Benz、Chery类修改，Player类【不需要】重新编译测试，只有ICar修改的时候Player才需要修改 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">play</span>(ICar car)  </span><br><span class="line">    &#123;  </span><br><span class="line">        car<span class="selector-class">.accelerate</span>();  </span><br><span class="line">        car<span class="selector-class">.shift</span>();  </span><br><span class="line">        car<span class="selector-class">.steer</span>();  </span><br><span class="line">        car<span class="selector-class">.brake</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>【ICar】<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.oo.oop.dip;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 汽车接口，对应DIP中的抽象层 </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICar</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 加速 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accelerate</span>(<span class="params"></span>)</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 换挡 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shift</span>(<span class="params"></span>)</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 转向 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">steer</span>(<span class="params"></span>)</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     * 刹车 </span><br><span class="line">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brake</span>(<span class="params"></span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>【Benz】<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.oop</span><span class="selector-class">.dip</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 奔驰，实现了ICar接口，对应DIP中的“低层依赖抽象层”  </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">Benz</span> <span class="selector-tag">implements</span> <span class="selector-tag">ICar</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void accelerate() &#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//加速非常快  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Benz accelerate: very fast !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void shift() &#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//自动挡  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Benz shift:  automatic transmission !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void steer() &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//非常平稳  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Benz steer:  very smooth，ESP &amp;&amp; DSC &amp;&amp; VSC !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void brake() &#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//刹车辅助系统  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Benz steer:  ABS &amp;&amp; EBA &amp;&amp; BAS &amp;&amp; BA !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>【Ford】<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.oop</span><span class="selector-class">.dip</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 福特，实现了ICar接口，对应DIP中的“低层依赖抽象层”  </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">Ford</span> <span class="selector-tag">implements</span> <span class="selector-tag">ICar</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void accelerate() &#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//加速快  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Ford accelerate: fast !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void shift() &#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//手自一体变速器  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Ford shift:  Tiptronic transmission !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void steer() &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//平稳  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Ford steer:  smooth，ESP !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void brake() &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//刹车辅助系统  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Ford steer:  ABS &amp;&amp; EBA &amp;!!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>【Chery】<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com<span class="selector-class">.oo</span><span class="selector-class">.oop</span><span class="selector-class">.dip</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span><br><span class="line"> * 奇瑞，实现了ICar接口，对应DIP中的“低层依赖抽象层”  </span><br><span class="line"> * </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">Chery</span> <span class="selector-tag">implements</span> <span class="selector-tag">ICar</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void accelerate() &#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//加速慢  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Chery accelerate: slow !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void shift() &#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//手动挡  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Chery shift:  manual transmission !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void steer() &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//平稳  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Chery steer:  smooth，ESP &amp;&amp; DSC !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">@Override</span>  </span><br><span class="line">    public void brake() &#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//刹车辅助系统  </span></span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Chery steer:  only ABS !!"</span>);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="第三十五章"><a href="#第三十五章" class="headerlink" title="第三十五章"></a>第三十五章</h1><p><strong>NOP，No Overdesign Priciple，不要过度设计原则</strong>。</p>
<p>这应该是你第一次看到这个原则，而且你也不用上网查了，因为这个不是大师们创造的，而是我创造的：）</p>
<p>之所以提出这个原则，是我自己吃过苦头，也在工作中见很多人吃过类似的苦头。</p>
<p>你可能也见过这样的场景：<br>产品提出了一个需求，设计师眼光非常长远，他甚至把5年后可能的业务变化都提出来并且加以设计了，让你不得不佩服设计师的高瞻远瞩的眼光，并且由衷的从心底赞叹：牛逼啊！</p>
<p>但很快你就会发现，设计师是很牛逼，但你开发的时候就很苦逼了，设计方案巨复杂，工作量巨大，即使你发扬一不怕苦二不怕累的精神，每天加班加点奋斗了三个月终于做出来了，但你苦逼完了，测试跟着苦逼了：很多东西测试都没办法测试！</p>
<p>怎么会出现这样的情况呢？我们做面向对象不就是为了应对变化、拥抱变化么？</p>
<p>要回答这个问题其实很简单，孔夫子在《论语》中已经为我们解答了：“子贡问：‘师与商也孰贤？’子曰：‘师也过，商也不及。’曰：‘然则师愈与？’子曰：‘过犹不及。’”</p>
<p>什么事情过头了就和没有达到是一样的效果，面向对象的设计也不例外。面向对象的初衷虽然是为了拥抱变化，但这个变化也是有一个度的，而不是预测得越长越好，原因很简单：预测越长，预测的结果正确性越低！谁能在2000年预测SUN公司的衰落？谁又能在2005年预测苹果的崛起？</p>
<p>除了预测时间越长准确性越差的问题外，过分设计会导致设计方案不必要的复杂、代码量庞大，投入产出不成正比，项目计划无法按时完成。。。。。。等等很多问题。</p>
<p>有时候过分设计比设计不足的影响和危害更大，因为如果设计不足，我们还有“重构”这个利器，也不会出现浪费大量人力物力的情况；<br>而如果过分设计，如果后面发现原来的设计不正确或者不合理，首先原有的投入浪费了，其次是即使重构，也需要花费更多的人力物力。</p>
<p>所以，在设计过程中要时刻谨记NOP原则，避免过度设计！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;无意间发现这篇文章，文章讲解由浅入深，读完后感触很深&lt;br&gt;特全文转到自己的博客，方便以后自己随时查看&lt;br&gt;文章转载自爱技术的华仔的博客[&lt;a href=&quot;http://blog.csdn.net/yunhua_lee&quot;&gt;http://blog.csdn.net/yunhua_lee&lt;/a&gt;]&lt;br&gt;非常感谢&lt;a href=&quot;http://blog.csdn.net/yunhua_lee&quot;&gt;爱技术的华仔&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;第二十八章&quot;&gt;&lt;a href=&quot;#第二十八章&quot; class=&quot;headerlink&quot; title=&quot;第二十八章&quot;&gt;&lt;/a&gt;第二十八章&lt;/h1&gt;&lt;p&gt;前面通过实例讲解了一个一环扣一环的面向对象的开发流程：用例模型 -&amp;gt; 领域模型 -&amp;gt; 设计模型（类模型 + 动态模型），解答了面向对象如何做的问题。接下来我们就要讲“如何做好面向对象设计”的技巧了
    
    </summary>
    
      <category term="软件笔记" scheme="http://i90s.vip/categories/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="转载" scheme="http://i90s.vip/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="面向对象" scheme="http://i90s.vip/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>连载：面向对象葵花宝典：思想、技巧与实践(21-27章)</title>
    <link href="http://i90s.vip/2016/05/13/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B83/"/>
    <id>http://i90s.vip/2016/05/13/面向对象葵花宝典3/</id>
    <published>2016-05-13T14:38:40.000Z</published>
    <updated>2016-05-26T15:21:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>无意间发现这篇文章，文章讲解由浅入深，读完后感触很深<br>特全文转到自己的博客，方便以后自己随时查看<br>文章转载自爱技术的华仔的博客[<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">http://blog.csdn.net/yunhua_lee</a>]<br>非常感谢<a href="http://blog.csdn.net/yunhua_lee" target="_blank" rel="external">爱技术的华仔</a></p>
</blockquote>
<h1 id="第二十一章-SSD"><a href="#第二十一章-SSD" class="headerlink" title="第二十一章 SSD"></a>第二十一章 SSD</h1><p>用例图是用来描述系统的，而SSD（系统序列图）又是来描述用例的，oh my god，这不是在玩我们么？<img src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/crazy.gif" alt="抓狂"><a id="more"></a></p>
<p>System Sequence Diagram，缩写为SSD（注意不要与SSD硬盘混淆），中文翻译为“<strong>系统顺序图</strong>”，主要用于描述某个用例的某个分支场景下，外部参与者与系统的交互过程。简单来说：SSD就是用例的可视化描述。</p>
<p>细心的朋友可能会发现，前面我们在介绍“用例方法”的时候说不需要画图，这里又说SSD是用来描述用例的，这不是互相冲突了么？</p>
<p>事实上并不冲突，原因在于：用例方法分析需求的时候，确实不需要图；但用例方法分析完成后得到的用例，我们可以使用SSD让用例更直观一些。</p>
<p>SSD有几点需要特别注意：<br>1）SSD不是标准的UML图形：UML只有顺序图、用例图，但是没有一个专门的“系统顺序图”；之所以叫做“系统”顺序图，是因为这个顺序图中只有两类对象：系统、与系统交互的对象；<br>2）SSD是用来描述某个用例的某个分支，而不是描述系统的结构；<br>3）画SSD的时候，整个系统被当做一个黑盒，不涉及系统的分解；<br>4）不需要为每个用例每个分支都画一个SSD，挑出关键的用例和分支即可；</p>
<p>有的朋友可能会有疑问：如何知道哪些用例的哪些分支是关键的呢？</p>
<p>我的答案是：你认为是关键的你就画，你认为不是关键的你就不画；如果你认为所有的用例都很关键，那么所有的用例你都画即可，只要你不怕麻烦或者工作量太大；如果你认为所有的用例都很简单，那么一个都不画也可以。至于你的判断是否正确，主要靠经验积累，当经验不够的时候，也可以求助有经验的人。</p>
<p>以POS机为例，假如我们认为POS机的正常处理流程是关键分支，则对应的SSD如下：<br> <img src="http://ww4.sinaimg.cn/large/666cc9e3gw1f4972ruegnj20ek0sx761.jpg" alt=""><br>仔细对照SSD和POS机的用例，我们会发现SSD和用例基本上是对应的，但并不完全对应，例如：<br>Ø 用例中第1步是“顾客携带选择好的商品到收银台”，但SSD中第1步是开始交易；<br>Ø 用例中“顾客将钱交给收银员”，但SSD中并没有对应的步骤；<br>Ø 用例中最后一步是“买单完成，顾客携带商品和小票离开”，但SSD中最后一步是“交易结束”；</p>
<p>为什么会出现这种不对应的情况呢？<br>主要原因在于：用例是整个业务的流程，而SSD是站在系统的角度来描述系统与外部对象的交互，这就需要我们在画SSD的时候做一些技巧性的处理：<br>Ø 删除系统无关的业务步骤<br>例如上述的“顾客将钱交给收银员”，这个步骤和POS机没有关系，因此无需体现，再说了，就算你想体现，你也体现不了；<br>Ø 将业务语言转换为系统语言<br>例如用例中是描述“顾客携带选择好的商品到收银台”，但对应系统来说，这就意味了“交易开始”；同样，“买单完成，顾客携带商品和小票离开”意味着“交易结束”。</p>
<p>有的朋友可能会认为，应该在用例分析的时候就应该详细写清楚。例如，“买单完成，顾客携带商品和小票离开，收银员告诉POS机交易结束”。<br>这种想法本身没错，但问题在于，理想和现实总是有差距的，用例不可能那么完善，甚至有的时候用例可能都存在错误，如果我们自己没有一定的分析和理解能力，完全依赖原始的用例，这样做是不可能设计出优秀的系统的，甚至连合格的系统都可能做不到。</p>
<p>综合上面的分析，我们可以看到，SSD虽然来源于用例，但还需要在用例的基础上稍微加工一下，使得SSD能够更加聚焦于“系统”这个主角。</p>
<p>最后小小吐槽一下：<strong>用例图是用来描述系统的，而SSD又是来描述用例的，oh my god，这不是在玩我们么？</strong></p>
<h1 id="第二十二章-领域模型"><a href="#第二十二章-领域模型" class="headerlink" title="第二十二章 领域模型"></a>第二十二章 领域模型</h1><p>领域模型是面向对象分析和设计的第一步！！</p>
<p>完成了需求分析之后，我们已经有了一个良好的开端，但我们的主角“面向对象”还不见踪影。<br>前面我们提到，需求分析和面向对象是没有直接关系的，需求分析阶段是不区分是面向对象还是面向过程，那么什么时候才真正开始面向对象的工作呢？</p>
<p>答案就在本章：<strong>领域建模</strong>。<br>从领域模型开始，我们就开始了面向对象的分析和设计过程，可以说，领域模型是完成从需求分析到面向对象设计的一座桥梁。</p>
<p>领域模型，顾名思义，就是需求所涉及的领域的一个建模，更通俗的讲法是业务模型。<br>参考百度百科（<a href="http://baike.baidu.cn/view/757895.htm" target="_blank" rel="external">http://baike.baidu.cn/view/757895.htm</a> ），领域模型定义如下：</p>
<blockquote>
<p>领域模型是对领域内的概念类或现实世界中对象的可视化表示，又称概念模型、领域对象模型、分析对象模型。它专注于分析问题领域本身，发掘重要的业务领域概念，并建立业务领域概念之间的关系。</p>
</blockquote>
<p>从这个定义我们可以看出，领域模型有两个主要的作用：<br>1）发掘重要的业务领域概念<br>2）建立业务领域概念之间的关系</p>
<p>【领域建模三字经】<br>领域模型如此重要，很多同学可能会认为领域建模很复杂，需要很高的技巧。然而事实上领域建模非常简单，简单得有点难以让人相信，领域建模的方法概括一下就是“找名词”！</p>
<p>许多同学看到这个方法后估计都会笑出来：太假了吧，这么简单，找个初中生都会啊，那我们公司那些分析师和设计师还有什么用哦？</p>
<p>分析师和设计师当然有用，后面我们会看到，即使是简单的找名词这样的操作，也涉及到分析和提炼，而不是简单的摘取出来就可，这种情况下分析师和设计师的经验和技能就能够派上用场了。但领域模型分析也确实相对简单，即使没有丰富的经验和高超的技巧，至少也能完成一个能用的领域模型。</p>
<p>虽然我们说“找名词”很简单，但一个关键的问题还没有说明：从哪里找？<br>如果你还记得领域模型是“需求到面向对象的桥梁”，那么你肯定一下子就能想到：从需求模型中找，具体来说就是从用例中找。</p>
<p>归纳一下域建模的方法就是“从用例中找名词”。<br>当然，找到名词后，为了能够更加符合面向对象的要求和特点，我们还需要对这些名词进一步完善，这就是接下来的步骤：加属性，连关系！</p>
<p>最后我们总结出领域建模的三字经方法：<strong>找名词、加属性、连关系</strong>。</p>
<p>欲知具体如何操作，请看下回分解</p>
<h1 id="第二十三章"><a href="#第二十三章" class="headerlink" title="第二十三章"></a>第二十三章</h1><p>看起来有点不可思议，需求阶段“白纸黑字”的用例文档，经过我们一步一步的操作，逐步就得到了“图形化”的领域模型，面向对象初具雏形。</p>
<p>领域建模的三字经方法：<strong>找名词、加属性、连关系</strong>。</p>
<p>我们接下来以一个样例看看领域模型具体如何建模。</p>
<h2 id="1-1-找名词"><a href="#1-1-找名词" class="headerlink" title="1.1 找名词"></a>1.1 找名词</h2><p>我们以POS机买单的用例来看看具体如何建领域模型。</p>
<p>首先，将用例中所有的名词挑选出来（如下用例文档中<strong>蓝色加粗</strong>的词组）：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">【用例名称】</span><br><span class="line">买单</span><br><span class="line">【场景】</span><br><span class="line">Who：*<span class="strong">*顾客、收银员*</span>*</span><br><span class="line">Where：商店的*<span class="strong">*收银台*</span>*</span><br><span class="line">When：营业时间</span><br><span class="line">【用例描述】</span><br><span class="line">1. *<span class="strong">*顾客*</span><span class="strong">*携带选择好的*</span><span class="strong">*商品*</span><span class="strong">*到收银台；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">2. 收银员逐一扫描商品*</span><span class="strong">*条形码*</span><span class="strong">*，系统根据条形码查询商品信息；</span><br><span class="line">2.1 *</span><span class="strong">*扫描仪*</span><span class="strong">*坏了，必须支持手工输入条形码；</span><br><span class="line">2.2 商品的*</span><span class="strong">*条形码*</span><span class="strong">*无法扫描，必须支持手工输入条形码；</span><br><span class="line">2.3 条形码能够扫描，但查询不到信息，需要收银员和顾客沟通，放弃购买此产品</span><br><span class="line">3. 扫描完毕，系统显示商品总额，收银员告诉顾客商品总额；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">4. 顾客将*</span><span class="strong">*钱*</span><span class="strong">*交给收银员；</span><br><span class="line">4.1 顾客的钱不够，顾客和收银员沟通，删除某商品；</span><br><span class="line">4.2 顾客的钱不够，顾客和收银员沟通，删除某类商品中的一个或几个（例如买了*</span><span class="strong">*5包烟*</span><span class="strong">*，去掉两包）</span><br><span class="line">4.3 顾客觉得某个商品价格太高，要求删除某商品；</span><br><span class="line">4-A：顾客使用*</span><span class="strong">*信用卡*</span><span class="strong">*支付</span><br><span class="line">4-A.1 信用卡支付流程（请读者自行思考完善，可以写在这里，如果太多，也可以另外写一个子用例）</span><br><span class="line">4-B：顾客使用*</span><span class="strong">*购物卡*</span><span class="strong">*支付</span><br><span class="line">        4-B.1 购物卡支付流程</span><br><span class="line">4-C：顾客使用*</span><span class="strong">*会员卡*</span><span class="strong">*积分支付</span><br><span class="line">        4-C.1 会员卡积分支付流程</span><br><span class="line">5. 收银员清点钱数，输入收到的款额，系统给出找零的数目；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">6. 收银员将找零的钱还给顾客，并打印*</span><span class="strong">*小票*</span><span class="strong">*；</span><br><span class="line">7. *</span><span class="strong">*买单*</span><span class="strong">*完成，顾客携带*</span><span class="strong">*商品*</span><span class="strong">*和*</span><span class="strong">*小票*</span><span class="strong">*离开；</span><br><span class="line">【用例价值】</span><br><span class="line">顾客买完单以后，就可以携带商品离开，而超市也将得到收入；</span><br><span class="line">【约束和限制】</span><br><span class="line">1. POS机必须符合国标XXX；</span><br><span class="line">2. 键盘和屏幕使用*</span><span class="strong">*中文*</span><span class="strong">*，因为收银员都是*</span><span class="strong">*中国人*</span><span class="strong">*；</span><br><span class="line">3. 一次买单数额不能超过99999RMB；</span><br><span class="line">4. POS机要非常稳定，至少一天内不要出现故障；</span></span><br></pre></td></tr></table></figure></p>
<p>名词列表：<br>顾客、收银员、收银台、商品、条形码、扫描仪、钱、5包烟、信用卡、会员卡、小票、买单、键盘、屏幕、中文、中国人</p>
<p>通过这种简单的方法，我们很轻松的就识别出了领域中的各种概念，但是还不能高兴的太早，识别领域概念的工作还没有结束，接下来我们还需要提炼。</p>
<p>有了前面步骤识别的名词列表后，提炼的工作就相对很简单了，只需要删除不是领域对象的名词即可。<br>但具体应该删除什么名词，是和不同的业务领域强相关的，并没有完全统一的标准，此时分析师的行业和领域经验起决定作用，而这也正是菜鸟和专家的区别。</p>
<p>以我们的收银机为例，提炼的过程如下：<br>1）删除“收银台”：收银台只是一个物理设备，且这个设备与我们的POS机也没有任何交互，所以不能算作领域模型中的一个概念；<br>2）删除“5包烟”：5包烟只是用例中举例时的一个实例，是一个具体的商品，已经包含在“商品”中了；<br>3）删除“中文”：“中文”只是“键盘”和“屏幕”的一个属性，并不是一个独立的领域概念；<br>4）删除“中国人”：“中国人”只是“收银员”的一个属性，并不是一个独立的领域概念；<br>5）删除“条形码”：“条形码”只是“商品”的一个属性，并不是一个独立的领域概念；</p>
<p>经过上面的提炼步骤后，就得到了真正的POS机领域类，详细如下：<br><strong>顾客、收银员、商品、扫描仪、钱、信用卡、会员卡、小票、买单、键盘、屏幕</strong></p>
<h2 id="1-2-加属性"><a href="#1-2-加属性" class="headerlink" title="1.2. 加属性"></a>1.2. 加属性</h2><p>找出领域模型的名词后，接下来一个重要工作就是将这些名词相关的属性找出来，使其更加准确。</p>
<p>但加属性和前面找名词有一点点差别：有的属性并没有在用例中明确给出，需要分析人员和设计人员额外添加，此时也是分析师的行业和领域经验起决定作用。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名词</th>
<th style="text-align:center">属性</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">顾客</td>
<td style="text-align:center">NA</td>
<td style="text-align:center">对于POS机来说，并不需要识别顾客的相关信息，因此在领域模型中，顾客是没有属性的</td>
</tr>
<tr>
<td style="text-align:center">收银员</td>
<td style="text-align:center">国籍、编号</td>
<td style="text-align:center">“国籍”由找名词步骤中的“中国人”提炼</td>
</tr>
<tr>
<td style="text-align:center">商品</td>
<td style="text-align:center">条形码、名称、价格</td>
<td style="text-align:center">名称和价格并没有在用例中体现，但毫无疑问这是商品最基本的属性</td>
</tr>
<tr>
<td style="text-align:center">扫描仪</td>
<td style="text-align:center">NA</td>
<td style="text-align:center">扫描仪是POS机的一个输入设备，POS机不需要识别扫描仪的相关信息，因此在领域模型中，扫描仪也是没有属性的</td>
</tr>
<tr>
<td style="text-align:center">钱（现金）</td>
<td style="text-align:center">数量，币别</td>
<td style="text-align:center">从领域分析的角度来讲，“现金”更专业一些</td>
</tr>
<tr>
<td style="text-align:center">信用卡</td>
<td style="text-align:center">卡号</td>
<td style="text-align:center">NA</td>
</tr>
<tr>
<td style="text-align:center">会员卡</td>
<td style="text-align:center">会员号、积分、有效期</td>
<td style="text-align:center">NA</td>
</tr>
<tr>
<td style="text-align:center">小票</td>
<td style="text-align:center">交易信息、POS机信息、收银员信息</td>
<td style="text-align:center">小票的属性在用例中并没有详细体现，但有经验的分析师能够很容易识别出来</td>
</tr>
<tr>
<td style="text-align:center">买单（交易）</td>
<td style="text-align:center">商品列表、日期时间、总额、支付信息</td>
<td style="text-align:center">这里的属性看起来和“小票”一样，是因为“小票”本质上是给客户的一个交易记录。这里为了更加符合软件系统的属于习惯，可以将“买单“改为“交易”。</td>
</tr>
<tr>
<td style="text-align:center">键盘</td>
<td style="text-align:center">NA</td>
<td style="text-align:center">和扫描仪类似，POS机不需要识别键盘信息</td>
</tr>
<tr>
<td style="text-align:center">屏幕</td>
<td style="text-align:center">NA</td>
<td style="text-align:center">和扫描仪类似，POS机不需要识别屏幕信息</td>
</tr>
</tbody>
</table>
<h2 id="1-3-连关系"><a href="#1-3-连关系" class="headerlink" title="1.3. 连关系"></a>1.3. 连关系</h2><p>有了类，也有了属性，接下来自然就是找出它们的关系了。</p>
<p>有了前面的工作，看起来连关系自然也是睡到渠成的事情，但不要忘了我们的这个例子是非常简单的，在一些复杂的系统中，领域模型之间的关系并不那么明显，菜鸟可能就只能看到最显而易见的一些联系，而系统分析师和设计师可以凭着丰富的经验、良好的技巧识别出来，这也是系统分析师和设计师的价值所在。</p>
<p>POS机的领域类关系如下（仅供参考，并不要求每个分析师和设计师都一定是这么理解，但总体来说应该相似）：<br>  <img src="http://ww3.sinaimg.cn/large/666cc9e3gw1f4973bk17xj20wp0g90w8.jpg" alt=""></p>
<p>看起来有点不可思议，需求阶段白纸黑字的用例文档，经过我们一步一步的操作，最后得到了图形化的领域模型。<br>只要曾经画过甚至只是看过UML类图的同学都应该很容易发现，领域模型和设计类图非常相似，面向对象终于有了雏形了</p>
<h1 id="第二十四章"><a href="#第二十四章" class="headerlink" title="第二十四章"></a>第二十四章</h1><p>完成领域类到软件类的转换，这就是面向对象领域设计阶段的主要任务。</p>
<p>经过领域模型的分析后，面向对象已经初具雏形，但领域类并不能指导我们进行编码工作，因为领域类只是从用例模型中提炼出来的反应业务领域的概念，而并不是真正意义上的软件类。</p>
<p>“革命尚未成功，同志还需努力”，我们需要再进一步，完成<strong>领域类到软件类的转换</strong>，这就是面向对象领域设计阶段的主要任务。</p>
<p>设计阶段是整个面向对象分析和设计的高潮阶段。在设计阶段中，我们将要输出设计模型，并且需要综合各种方法、技巧，运用十八般武艺，使出浑身解数，以求能够设计出满足各种需要的设计方案。</p>
<p>这也是最考验设计师功力的时候，因为设计并没有一个量化的标准，也没有一个标准答案，更多的时候需要设计师综合知识、技能、经验、灵感等因素，综合权衡而得出一个方案。世界上找不到两片相同的叶子，同样，你也找不到两个完全一样的设计方案。毫不夸张的说，面向对象的设计更多时候是一项艺术。</p>
<p>虽然我们说面向对象设计是一门艺术，但这并不意味着只有天才才能进行面向对象设计，面向对象设计也是有一定的规律和方法可寻的，我们将在接下来的章节逐一介绍。</p>
<p>【设计模型总览】<br>设计模型主要包含2部分内容：<strong>静态模型、动态模型</strong>，任何一个模型的缺失或者不完善，都将导致最终的设计质量不高，甚至可能导致最终的系统没有实现业务需求。</p>
<p>静态模型又可以称为“类模型”，主要关注系统的“静态”结构，描述了系统包含的类， 以及类的名称、职责、属性、方法，类与类之间的关系。<br>动态模型关注系统的“动态”行为，描述类本身的一些动作或者状态变化，以及类之间如何配合以完成最终的业务功能。只有结合静态模型和动态模型，我们才能够真正的将一个系统描述清楚。</p>
<p>静态模型和动态模型对于后续的编码也具有不同的指导意义。静态模型主要用于指导类的声明，包括类名称，属性名，方法名；而动态模型主要用于指导类的实现，主要就是每个方法内部的具体实现。</p>
<h1 id="第二十五章"><a href="#第二十五章" class="headerlink" title="第二十五章"></a>第二十五章</h1><p>面向对象设计和弹吉他差不多，有很多成熟的理论和技巧，学会弹吉他并不难，你只需要应用这些理论和技巧即可！</p>
<p><strong>【师傅领进门，修行在个人】</strong><br>“类模型”是整个面向对象设计模型的核心，是面向对象设计阶段的主要输出，也是设计师们最能够发挥自己才能的地方。</p>
<p>虽然“类模型”如此重要，但面向对象设计技术经过几十年的发展后，目前已经形成了很成熟的一套体系，因此真正在进行“类模型”设计的时候，其实难度并不高，这也是多亏了众多前辈们的无私贡献，才能使得我们这些芸芸众生也能轻松掌握这些原本带有艺术色彩的技能。</p>
<p>不过话又说回来了，入门容易精通难，“类模型”的设计也是如此，虽然有前辈们各种各样的思想结晶指导着我们，但毕竟如何理解、如何应用这些思想结晶，还是要看个人的领悟力和把握力。就像同样的《葵花宝典》，岳不群看了创立了气宗，蔡子峰看了创立了剑宗，渡元禅师听了后悟出了辟邪剑法，东方不败看了竟然练出了绣花针绝技！所以接下来的内容，也只是“师父领进门，修行在个人”，如果希望做出优秀的设计，更多还是依靠个人的领悟和实践！</p>
<p><strong>【设计的魔法崇拜】</strong><br>面向对象类的设计很多时候都蒙上了一层神秘的面纱。一个常见的场景是：“设计师”拿到需求后，经过一段时间的设计，感觉就像变戏法一样，然后就拿出了一个类模型。普通的开发人员看到这样的类模型，很难想象如何从需求才能够得到了这些类，由于大部分公司的设计人员确实也都是公司里面的牛人，因此大家就自然而然地认为这是水平和创造力的表现，心底不由得产生由衷的赞叹：“牛逼啊！”</p>
<p>我称这种现象为设计的“魔法崇拜”，具体表现就是认为设计是一种魔法，做设计的人是魔法师，只有牛逼的人才能够做设计。</p>
<p>但这种认识并不准确，就像我们前面提到的，面向对象领域已经发展了几十年，各种思想、理论都已经基本成熟，绝大部分人在做设计的时候，都不可能有什么天才的创新或者天才的灵感，而只是这些已经成熟的思想和理论的应用而已。</p>
<p>之所以现在还会出现这种现象，主要原因还是在于各种思想、理论、方法都是针对具体问题的分析或者总结，但并没有谁明确的将这些东东形成一套完整的面向对象设计体系。</p>
<p>可能很多人都有这种感觉：面向对象我也懂，设计模式我也知道，设计原则我也明白，但真的要进行设计的时候，就不知道如何下手了，比如说：<br>对象从哪里来？<br>什么时候用设计模式？<br>如何判断设计是否正确？<br>什么样的设计才是优秀的设计？<br>。。。。。。。。。。。</p>
<p>正因为存在这样的原因，我们自然会对那些能够设计出完整的类模型的设计师们刮目相看了。</p>
<p>其实面向对象设计并不是什么高深的技术，也不需要天才的创新，更不需要变魔法，而是有章可循的，只要我们按照一定的步骤，一步一个脚印，不断精益求精，就能够完成面向对象的设计。</p>
<p>但正如前面提到的一样，面向对象设计更多的时候是一门艺术。虽然我们按照一定的步骤能够完成面向对象的设计，但在这些步骤实施的过程中，如何应用相关技术，如何做出设计选择等，更多时候是带有艺术色彩的。就像很多人都会弹吉他，但真正的吉他大师弹出来的感觉，肯定和一个普通人弹的不一样。</p>
<p>接下来我们将会分几个小节讲述如何进行面向对象的类设计：</p>
<p>第一步（照猫画虎）：领域类映射 — 告诉你类从哪里来<br>第二步（精雕细琢）：应用设计原则和设计模式   —告诉你如何设计“好”类<br>第三步（照本宣科）：拆分辅助类   —告诉你如何和你的开发框架结合起来</p>
<h1 id="第二十六章"><a href="#第二十六章" class="headerlink" title="第二十六章"></a>第二十六章</h1><p><strong>类模型设计其实就是程咬金打天下 – 三板斧 而已 ：）</strong></p>
<hr>
<h2 id="第一斧（照猫画虎）：领域类映射"><a href="#第一斧（照猫画虎）：领域类映射" class="headerlink" title="第一斧（照猫画虎）：领域类映射"></a><strong>第一斧（照猫画虎）：领域类映射</strong></h2><p>面向对象类设计首先要解决的一个问题是：类从哪里来 ？</p>
<p>有的人可能会认为，要发挥想象力、创造力。。。。。等各种“力”——这种方法的主要问题是：我们不是在进行纯粹的艺术创造，而是要最终满足客户需求，而不能天马行空。</p>
<p>有的人可能会想到，参考其它的系统吧，把类似系统拿过来改吧改吧 ——这种方法的主要问题是：如果没有其它类似系统给你参考呢 ？还有的人干脆就说：拍脑袋吧，凭感觉吧 —— 这种方法的主要问题是：猴子能敲出莎士比亚全集么 ？看起来以上方法都不太可行，那究竟如何才能从哪里找到我们需要的类呢？</p>
<p>相信绝大部分认真看书的同学都会灵光一闪：领域模型。我们将上一章中的领域模型图拿出来，重新再看一下：<img src="http://ww2.sinaimg.cn/large/666cc9e3gw1f4973z2vcdj20wp0g90w8.jpg" alt="">相信不用我多说，绝大部分同学一眼就能看出：哇塞，这不就是类么？</p>
<p>确实是这样的，<strong>领域模型中的“领域类”，是设计模型中“软件类”最好的来源</strong>。通过“领域类”来启发我们设计最初的“软件类”，具有如下几个明显的<strong>优点</strong>：1）软件类来自领域类，领域类来自用例，用例来自客户，这样一环扣一环，软件类的正确性得到了保证，不用担心拍脑袋带来的问题；2）领域类到软件类的转换非常简单，不需要天才的创新，或者丰富的想象力，只要掌握基本的面向对象的知识就能完成，菜鸟也能做设计；3）不需要参考其它系统，不用担心没有参照物时无法设计的问题；从领域类到软件类的转换操作非常简单，基本上就是一个照猫画虎的过程。</p>
<p><strong>【类筛选】</strong>虽然我们说从领域类到软件类是一个照猫画虎的过程，但并不意味着将领域类全盘拷贝过来即可。主要的原因在于“软件类”是软件系统内部的一个概念，而领域类是业务领域的概念，并不是每个领域类最终都会体现在软件系统中。以POS机的领域类为例，领域类“顾客”不需要转换为软件类，因为顾客是POS机业务领域的一个重要参与者，但并不是POS机内部需要实现的一个实体，在POS机业务中，顾客甚至都不是和POS机直接交互的实体，站在POS软件系统的角度来说，顾客和POS机其实没有任何关系。对于屏幕、键盘、扫描仪这些输入输出设备，一般情况下我们认为它们是POS机系统硬件的一部分，而并不是POS机软件系统的一部分。但假如POS机有一个需求是既支持图形界面输出，又支持字符界面输出，那么POS的软件系统就需要处理这种和屏幕相关的需求了，此时屏幕就是POS机软件系统的一部分了，需要将领域类转换为软件类。为了简单处理，接下来的分析中，输入输出设备不做转换。经过筛选后，剩下的领域类就需要都转换为软件类，具体如下：收银员、商品、交易、小票、支付、信用卡、会员卡、现金、购物卡。</p>
<p><strong>【名称映射】</strong>筛选完成后，我们开始讲领域类转换为软件类，转换的方法很简单，首先不管三七二十一，将每个领域类都用一个软件类与对应，名称都保持一样即可。有的同学可能担心这样设计是否会不符合面向对象设计的要求，是否会导致设计质量不高。。。。。。等等，其实这种担心是多余的，因为我们后续还有很多工作要做，目前做的只是一个开始工作。</p>
<p><strong>【属性映射】</strong>通过名称映射的方法得到软件类后，接下来就是要设计类的属性了。由于领域类中也已经有了属性，因此我们也只需简单的照搬过来即可。</p>
<p><strong>【提炼方法】</strong>软件类的属性设计完成后，接下来就需要设计软件类的方法了。但这次我们就没有那么好的运气了，因为领域类中并没有方法！因此我们不能通过简单映射的方法来获取方法，必须采取其它手段。和类的设计一样，类方法的设计同样不能采取“创造力、参考其它系统、拍脑袋”等方式来完成，为了确保正确性，类的方法设计也同样应该能够从已有的模型中推导出来。由于已经明确领域模型中没有方法了，因此就不能从领域模型中得到软件类的方法，剩余只有一个“用例模型”了，因此我们锁定“用例模型”，看看如何从中找到我们所需要的方法。其实方法也很简单，概括一下就是：<strong>找动词</strong>。你可能不敢相信自己的眼睛，这么简单，那几乎初中生都会做设计啊，找动词谁不会呢？然而不管你信不信，这一步确实是这么简单，当然，如果面向对象设计只是到此为止，那确实初中生也是可以做的，但实际上这只是面向对象类设计的开始步骤而已，后面的工作还多着了，所以完全不用担心初中生来抢你的饭碗。我们以POS机为例，来看看如何通过“找动词”这种技巧来找到软件类的方法。如下是POS机的用例，我们将相关动词都<strong>加粗</strong>显示：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">【用例名称】</span><br><span class="line">买单</span><br><span class="line">【场景】</span><br><span class="line">Who：顾客、收银员</span><br><span class="line">Where：商店的收银台</span><br><span class="line">When：营业时间</span><br><span class="line">【用例描述】</span><br><span class="line">1. 顾客*<span class="strong">*携带*</span><span class="strong">*选择好的商品到收银台；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">2. 收银员逐一*</span><span class="strong">*扫描*</span><span class="strong">*商品条形码，系统根据条形码*</span><span class="strong">*查询*</span><span class="strong">*商品信息；</span><br><span class="line">2.1 扫描仪坏了，必须支持*</span><span class="strong">*手工输入*</span><span class="strong">*条形码；</span><br><span class="line">2.2 商品的条形码无法扫描，必须支持*</span><span class="strong">*手工输入*</span><span class="strong">*条形码；</span><br><span class="line">2.3 条形码能够扫描，但查询不到信息，需要收银员和顾客*</span><span class="strong">*沟通*</span><span class="strong">*，放弃购买此产品</span><br><span class="line">3. 扫描完毕，系统*</span><span class="strong">*显示*</span><span class="strong">*商品总额，收银员*</span><span class="strong">*告诉*</span><span class="strong">*顾客商品总额；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">4. 顾客将钱*</span><span class="strong">*交给*</span><span class="strong">*收银员；</span><br><span class="line">4.1 顾客的钱不够，顾客和收银员沟通，*</span><span class="strong">*删除*</span><span class="strong">*某商品；</span><br><span class="line">4.2 顾客的钱不够，顾客和收银员沟通，*</span><span class="strong">*删除*</span><span class="strong">*某类商品中的一个或几个（例如买了5包烟，去掉两包）</span><br><span class="line">4.3 顾客觉得某个商品价格太高，要求*</span><span class="strong">*删除*</span><span class="strong">*某商品；</span><br><span class="line">4-A：顾客使用信用卡*</span><span class="strong">*支付*</span>*</span><br><span class="line">4-A.1 信用卡支付流程（请读者自行思考完善，可以写在这里，如果太多，也可以另外写一个子用例）</span><br><span class="line">4-B：顾客使用购物卡*<span class="strong">*支付*</span>*</span><br><span class="line">        4-B.1 购物卡支付流程</span><br><span class="line">4-C：顾客使用会员卡积分*<span class="strong">*支付*</span>*</span><br><span class="line">        4-C.1 会员卡积分支付流程</span><br><span class="line">5. 收银员*<span class="strong">*清点*</span><span class="strong">*钱数，*</span><span class="strong">*输入*</span><span class="strong">*收到的款额，系统*</span><span class="strong">*给出找零*</span><span class="strong">*的数目；</span><br><span class="line">（这一步没有异常）</span><br><span class="line">6. 收银员将找零的钱还给顾客，并*</span><span class="strong">*打印*</span><span class="strong">*小票；</span><br><span class="line">7. 买单完成，顾客*</span><span class="strong">*携带*</span><span class="strong">*商品和小票*</span><span class="strong">*离开*</span><span class="strong">*；</span><br><span class="line">【用例价值】</span><br><span class="line">顾客买完单以后，就可以携带商品离开，而超市也将得到收入；</span><br><span class="line">【约束和限制】</span><br><span class="line">1. POS机必须符合国标XXX；</span><br><span class="line">2. 键盘使用中文，因为收银员都是中国人；</span><br><span class="line">3. 一次买单数额不能超过99999RMB；</span><br><span class="line">4. POS机要非常稳定，至少一天内不要出现故障；</span></span><br></pre></td></tr></table></figure></p>
<p>标识出所有的动词后，还需要进一步的工作：<br>【筛选】并不是所有的动词都一定是软件类的方法，我们需要将这些动词识别出来并排除在后续设计范围之外。<br>例如：“顾客携带选择好的商品到收银台”：这里的“携带”是顾客的一个动作，而顾客并不是我们的软件类；“收银员告诉顾客商品总额”：这里的“告诉”确实是收银员的一个动作，而且“收银员”确实也是我们的软件类，但这里也要排除“告诉”，因为“告诉”这个动作和POS系统并没有关系，只是业务流程中的一个步骤而已。其它需要排除的动词还有：“需要收银员和顾客沟通”、“顾客将钱交给收银员”、“收银员清点钱数”、“收银员将找零的钱还给顾客”、“顾客携带商品和小票离开”<br>【提炼】筛选完不需要的动词后，剩下的就是我们需要的动词了，但此时并不能简单的将所有动词拿出来直接扔给某个软件类就行了，我们还需要进行一些加工。</p>
<p>继续以POS机为例：“收银员逐一扫描商品条形码”：这里的“扫描”看起来是“收银员”的一个动作，而且“收银员”确实也是我们的软件类，但其实深究一下，“扫描”这个动词并不能分配给“收银员”这个软件类，因为真正执行“扫描”功能的是“扫描仪”，收银员只是拿着扫描仪扫描商品，并不是收银员自己去读取商品条形码；类似的动词还有“必须支持手工输入条形码”，也不能算作“收银员”的功能。</p>
<p>那我们为什么不排除这两个动词呢？秘密就在于我们要从这两个动词提炼出软件类的方法。稍作分析，我们就可以发现，无论是“扫描条形码”，还是“手工输入条形码”，其实最终的目的都是“添加本次交易的商品”，因此我们可以提炼出“增加交易商品”的动词。</p>
<p>还有一种提炼的方法需要从已有的动词中推断出来，例如：“扫描完毕，系统显示商品总额”，这里只提到了“显示”这个动词，但相信大部分人都能一眼看出，“显示”之前肯定要“计算”，不然显示出来的值从哪里来呢？</p>
<p>有的朋友可能会疑惑，为什么不在用例的时候就写清楚呢？例如：扫描完毕，系统计算商品总额，然后系统显示商品总额。这样不就一目了然的看出来了么？</p>
<p>理想情况下这种想法当然没错，但现实往往没有那么美好，写用例的产品人员可能经验不足，也可能表达能力有限，还有可能比较马虎，或者遗漏了。。。。。。总之会有很多异常情况，因此设计人员必须具备这样的推断和判断能力。</p>
<p>经过这一步骤后，我们获得的动词如下：</p>
<ul>
<li>增加商品</li>
<li>计算商品总额</li>
<li>显示商品总额</li>
<li>删除商品</li>
<li>现金支付</li>
<li>信用卡支付</li>
<li>购物卡支付</li>
<li>会员卡积分支付</li>
<li>打印小票<br>当然，以上列出来的动词并不是就一定是100%的标准答案，不同的人来进行分析和设计，可能略有不同，但总体应该比较相似，毕竟业务是一样的，而业务需求就是设计最强的约束。<br>【分配】<br>识别出有效的动词后，最有一步就是分配了，即：将从用例中提炼出来的动词，分配给已经有了属性的软件类。这种分配操作很多时候都是按图索骥，特别是对于有领域经验的人来说，基本上凭直觉就能基本分配正确。当然，如果你的经验并不是很丰富，那么还是老老实实的一个一个来分析吧。<br>以POS机为例：</li>
<li>增加商品：很明显应该分配给“交易”类</li>
<li>计算商品总额：分配给“交易”类</li>
<li>显示商品总额：分配给“交易”类</li>
<li>删除商品：分配给“交易”类</li>
<li>现金支付：分配给“现金”类</li>
<li>信用卡支付：分配给“信用卡”类</li>
<li>购物卡支付：分配给“购物卡”类</li>
<li>会员卡积分支付：分配给“会员卡”类</li>
<li>打印小票：这个动词的分配存在一定的灵活性，有的人可能认为应该分配给“交易”类，因为打印小票可以认为是“交易”流程中的一个步骤；有的人可能认为应该分配给“小票”类，因为打印小票可以认为是“小票”类的一个基本功能。其实两者都有一定道理，如果没有其它更有力的选择因素，我建议根据个人经验选择一个即可，这里我们选择分配给“小票”。分配完成后，我们可以看到“交易”、“小票”、“信用卡”、“购物卡”、“会员卡”、“现金”都已经有方法了。</li>
</ul>
<p>当然，对于有经验的人来说，以上步骤完全可以在脑海中就迅速完成了，而并不会这样一步一步的演示给别人看，所以看起来就像变戏法一样，不知怎么就设计出来了很多的软件类。</p>
<p>经过上面的处理步骤后，我们得到如下的类图：<img src="http://ww2.sinaimg.cn/large/666cc9e3gw1f4974v4brbj20ls0fkjux.jpg" alt=""><br>与领域模型相比，部分领域类被剔除了，留下来的领域类映射成软件类后，又增加了方法。虽然还不完善，但软件类的是越来越有型，越来越清晰了。</p>
<h2 id="第二斧（精雕细琢）：应用设计原则和设计模式"><a href="#第二斧（精雕细琢）：应用设计原则和设计模式" class="headerlink" title="第二斧（精雕细琢）：应用设计原则和设计模式"></a><strong>第二斧（精雕细琢）：应用设计原则和设计模式</strong></h2><p>完成了从领域类到软件类的映射后，类出来了，属性也出来了，方法也有了，看起来设计已经大功告成了。事实上也确实有很多人基本上做到这一步就开始动手编码了，而且经过一番拼搏，最后发布的系统也能用。</p>
<p>但相信很多人都会有这个疑问：这样做就够了么，这样设计是否是好的设计呢？要回答这个问题，我们首先要明确：什么叫做“好”的设计呢 ？</p>
<p>到目前为止，我们已经有了一个类的设计模型，而且如果按照这个模型去实现的话，最终应该也是能够满足用户的需求，毕竟我们这个类模型是按照“需求模型 -&gt; 领域模型 -&gt; 类模型”这样一路推导过来的，不会出现大的偏差。</p>
<p>那么，满足了用户需求的设计就是好的设计么？相信有经验的朋友都会知道答案：“满足用户需求”只是设计的一个最基本要求，而不是一个“好设计”的评判标准。</p>
<p>既然如此，那么到底什么才是好的设计呢，是否有明确的标准来进行评价呢？幸运的是，面向对象领域经过几十年的发展，确实已经发展出了很多成熟的指导思想和方法，用于评价和指导如何才能做好面向对象的设计。其中最具代表性的就是<strong>“设计原则”和“设计模式”</strong>。</p>
<p><strong>【设计原则】</strong></p>
<p>当我们谈到面向对象领域的设计原则的时候，我们其实都是在谈论罗伯特.C.马丁（Robert C. Martin ，又叫Bob大叔）的SOLID原则。这也难怪，Bod大叔实在是太牛了，面向对象领域的设计原则几乎被他全部包揽了，加上他在他的畅销书《敏捷软件开发：原则、模式与实践》中详细的将这些原则集中一 一阐述，面向对象领域设计原则的权威非他莫属。毫不夸张的说，Bob大叔的威名和在面向对象领域中的地位，和设计模式的“四人帮”是不相上下的。虽然很多资料都将SOLID原则和敏捷开发、测试驱动开发等方法绑定在一起，但我觉得只要是面向对象设计，不管是瀑布流程、、CMM流程、RUP流程、还是敏捷开发流程，都应该应用设计原则以提高设计质量。参考wiki百科，SOLID设计原则简单介绍如下：SOLID实际上是取5个设计原则的首字母拼起来的一个助记单词。具体的设计原则如下（详细的设计原则，我们会在后面详细阐述，这里不再详细展开）：</p>
<table>
<thead>
<tr>
<th>首字母</th>
<th>英文简写</th>
<th>英文名称</th>
<th>中文名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>SRP</td>
<td>Single Responsibility Principle</td>
<td>单一职责原则</td>
<td>对象应该只具备单一职责</td>
</tr>
<tr>
<td>O</td>
<td>OCP</td>
<td>Open/Close Principle</td>
<td>开放/封闭原则</td>
<td>认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。</td>
</tr>
<tr>
<td>L</td>
<td>LSP</td>
<td>Liskov Substitution Principle</td>
<td>Liskov替换原则</td>
<td>认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念</td>
</tr>
<tr>
<td>I</td>
<td>ISP</td>
<td>Interface Segregation Principle</td>
<td><a href="http://zh.wikipedia.org/w/index.php?title=%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99&amp;action=edit&amp;redlink=1" target="_blank" rel="external">接口隔离原则</a></td>
<td>多个特定客户端接口要好于一个宽泛用途的接口</td>
</tr>
<tr>
<td>D</td>
<td>DIP</td>
<td>Dependency Inversion Principle</td>
<td><a href="http://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99" target="_blank" rel="external">依赖反转原则</a></td>
<td>依赖于抽象而不是一个实例</td>
</tr>
</tbody>
</table>
<p>[wik链接]（<a href="http://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1）" target="_blank" rel="external">http://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1）</a></p>
<p>前面我们简单的八卦了一下，现在回归正题：设计原则有什么用？其实和所有的原则一样，设计原则也是一个判断标准，说通俗点，设计原则就像是木匠手中的尺子，尺子是用来衡量木材的长短的，而设计原则就是衡量类设计的“尺子”：量一量，看长了还是短了，还是正好，长了就裁短一些，短了就加长一些。经过如此衡量并调整，最终就能够得到我们希望的设计作品。当然，和木匠的尺子稍有不同，木匠不用尺子就做不出能用的家具，但我们不用设计原则的话，其实还是能够做出满足需求的系统的。<br>既然这样，我们为什么一定要用设计原则呢？ARTHUR J.RIEL在《OOD启思录》一书中针对这个问题给出了非常形象的解释：你不必严格遵守这些原则，违背它也不会被处以宗教刑罚。但你应当把这些原则看做警铃，若违背了其中的一条，那么警铃就会响起。”——-ARTHUR J.RIEL,《OOD启思录》<br>也就是说，如果违背了这些设计原则，就可能有危险，但究竟是什么危险呢，警铃要警告我们什么呢，是火灾、水灾、地震、陷阱、还是有狮子、老虎。。。。。？</p>
<p>要回答这个问题，还需要回到面向对象的本源：我们在第一章解释为什么要面向对象的时候提到了面向对象的核心思想是“可扩展性”，这其实就是我们应用设计原则的根本目的：保证可扩展性。如果我们不遵守这些设计原则，警铃就会响起，提醒我们：你的设计可扩展性会有问题！除了设计原则外，后面要讲到的设计模式，其本质也是为了提高可扩展性。这也是为什么我们通过领域类映射得到了很多软件类之后，还需要不辞辛劳的继续应用设计原则和设计模式的主要原因，本质上都是为了提高设计的可扩展性。</p>
<p>SOLID设计原则的各个子原则详细介绍会在后面详细介绍，这里我们简单的以POS机为例，看看如何应用设计原则。</p>
<p>仔细观察我们通过领域类映射得到的软件类，可以发现一个很明显不符合SOLID原则中的DIP原则的地方，即：“交易类”直接依赖“会员卡”、“购物卡”、“信用卡”、“现金”4个子类，这样的实现不符合DIP原则，当需要增加新的支付方式时，“交易类”也需要跟着修改。</p>
<p>既然不满足DIP设计原则，那么我们就按照DIP原则的要求，提取出一个支付的父类来，即：“交易类”依赖“支付类”，“会员卡”、“购物卡”、“信用卡”、“现金”都继承“支付”类。具体实现如下：<br><img src="http://ww4.sinaimg.cn/large/666cc9e3gw1f4975xrknaj20m00kkq6x.jpg" alt=""></p>
<p>可以看到，应用DIP设计原则之后，我们又多出了一个“支付”的类，这个类原来在领域模型中是没有的，而是我们在设计阶段“创造”出来的。对于其它各个类，我们都可以依次使用设计原则进行判断，当发现不符合设计原则的设计时，就采取增加、删除、合并、拆分等手段，使我们的设计逐步改进，最终达到符合设计原则的目的。</p>
<p><strong>【设计模式】</strong></p>
<p>相比设计原则来说，设计模式更加普及和流行，当我们谈到设计方法的时候，大部分人肯定都会想到设计模式，设计模式如此深入人心，几乎到了言必谈设计模式的地步。<br>和设计原则类似，当我们谈论设计模式的时候，我们其实都是在谈论GOF（Gang of Four，中文翻译为“四人帮”）在经典名作《设计模式  –可复用面向对象软件的基础》一书中提到的设计模式。<br>通俗的讲，设计模式是用于指导我们如何做出更好的设计方案，而前面提到的设计原则，其作用也是这样的。那么，设计原则和设计模式，我们该如何选择？<br>有的朋友可能会以为这两个是二选一的关系，要么用设计原则，要么用设计模式。这种理解是错误的，设计原则和设计模式并不是竞争关系，正好相反，它们是互补的关系。<br>设计原则和设计模式互补体现在：<strong>设计原则主要用于指导“类的定义”的设计，而设计模式主要用于指导“类的行为”的设计</strong>，更通俗一点的讲：设计原则是类的静态设计原则，设计模式是类的动态设计原则。</p>
<p>一般情况下，我们是采用“先设计原则，后设计模式”的方法来操作的。</p>
<p>设计模式的相关内容会在后文详细介绍，这里我们以POS机为例，看看如何应用设计模式来优化我们的设计。</p>
<p>通过分析应用设计原则优化后的类，我们发现“信用卡”这个类存在优化的空间，因为国际上存在不同的信用卡，最常见的有中国银联（UnionPay）、Visa、MasterCard这几种，每种信用卡在支付的时候需要接入不同的机构，其接入方式和协议肯定都是有一定差异的。为了封装这种差异以支持后续更好的扩展，我们应用设计模式的Bridge模式，提取出“信用卡处理”这个类，这个类的主要处理“连接、认证、扣款”这样的职责。UnionPay、Visa、MasterCard都继承“信用卡处理”这个类。具体如下：<br><img src="http://ww3.sinaimg.cn/large/666cc9e3gw1f4976hjbucj20yp0omafe.jpg" alt=""></p>
<h2 id="第三斧（照本宣科）：拆分辅助类"><a href="#第三斧（照本宣科）：拆分辅助类" class="headerlink" title="第三斧（照本宣科）：拆分辅助类"></a><strong>第三斧（照本宣科）：拆分辅助类</strong></h2><p>**经过前面的设计步骤之后，面向对象类的设计工作已经完成，我们输出了完整的类模型，看起来已经可以开始动手编码了，你是否舒了一口气，看着自己的设计作品，不由得产生了一种自豪感呢？</p>
<p>确实值得自豪，毕竟我们一步一个脚印，从最初仅仅存在于客户脑袋中的需求，逐步的推导、演变、设计出了能够付诸实施的类模型了。但在最终实施之前，还有一点小小的动作要完成，这就是我们的拆分辅助类操作。</p>
<p>拆分辅助类的主要目的是为了使我们的类在编码的时候能够满足一些框架或者规范的要求。比如说常见的MVC模式，将一个业务拆分成Control、Model、View三个元素；J2EE模式中，将对象分为PO、BO、VO、DTO等众多对象。</p>
<p>之所以说这是一点小小的动作，是因为这个动作确实很简单，只要将我们设计出来的类，按照规范要求，一 一对应分拆即可。</p>
<p>以POS机为例，假如我们的框架要求提供DAO对象，负责数据库的相关操作，则“购物卡”类就应该拆分为两个：“购物卡”、“购物卡DAO”，其中“购物卡”用于负责提供“支付”功能给“交易”类调用，“购物卡DAO”用于负责从数据库读取购物卡信息，修改数据库中购物卡余额等操作。<br><img src="http://ww3.sinaimg.cn/large/666cc9e3gw1f4976wzbsgj20ch03vmxu.jpg" alt=""><br>需要注意的是，拆分设计辅助类仅仅是为了满足框架或者规范的要求，<strong>本身并不是一个设计的步骤，而是实施的一个步骤</strong>，所以我们一般都不需要将拆分的辅助类体现在类模型中，仅仅在编码的时候拆分即可。</p>
<h1 id="第二十七章"><a href="#第二十七章" class="headerlink" title="第二十七章"></a>第二十七章</h1><p>类模型指导我们如何<strong>声明类</strong>，动态模型指导我们如何<strong>实现类</strong>！</p>
<p>动态模型设计一般都是在类模型设计完成后才开始，因为动态模型设计的时候一般都需要用到类模型中的类。相对类模型来说，动态模型要相对简单一些，主要原因在于动态模型设计的时候没有什么设计原则和设计模式需要应用，只需要对照用例模型，根据用例模型的特点，选取一个合适的动态模型将其表述出来即可。</p>
<p>动态模型在实际开发过程中有非常重要的作用，简单来说，如果没有动态模型，那么你虽然完成了类设计，但还是不能编码，或者只能编写类的声明代码（类属性、方法名称），但不能写类的实现代码（方法里面的实现逻辑，即：每个方法的实现）。动态模型就是用来指导我们如何编写具体的方法的。</p>
<p>有的同学可能会有疑问：那些地方要进行动态模型设计呢？<br>还是那句老话，你觉得比较复杂你就设计，简单你就不设计，总之：<strong>你需要你就设计</strong>！<br>像我在实际开发中，基本上一个中等项目就一两个业务设计动态模型（小项目看到需求就编码了 ：） ），其它业务看需求文档就能看出如何编码，这也是有经验和经验不足的差别。</p>
<p>参考UML标准，常见的动态模型如下：<br>【状态模型】<br>状态模型主要用于描述对象的生命周期的状态变化。通过状态图，我们可以了解到对象有哪些状态，状态之间如何转换，转换的触发条件等。当我们发现一个对象的状态比较复杂的时候，就需要设计对象的状态模型。<br>UML中使用状态图来描述状态模型</p>
<p><strong>【活动模型】</strong><br>活动模型主要用于描述一个工作流程或者计算流程。其关注点是在完成某项工作的过程中，系统中的哪些对象承担了什么样的任务、做了什么处理，以及这些对象之间的先后交互关系。当我们发现一个处理流程比较复杂的时候，就需要设计流程的活动模型。<br>UML中使用活动图来描述活动模型</p>
<p><strong>【序列模型】</strong><br>序列模型主要用于描述对象按照时间顺序组织的消息交互过程，其关键特征是强调按照“时间顺序”来组织对象的交互，所以序列图有时又称为“时序图”或者“顺序图”。序列模型是我们最常用的动态模型，特别适合将用例模型或者SSD转换为系统的动态模型。<br>UML中使用序列图来描述序列模型</p>
<p><strong>【协作模型】</strong><br>协作模型主要用于描述按照对象之间的关联来组织的消息交互过程，其关键特征是强调“对象关系”来组织对象的交互。协作模型的作用和序列模型一样，只是强调的点不同，大部分的时候我们都是选择“序列模型”，因为序列模型的时间顺序很多时候和用例模型的步骤不谋而合。<br>UML中使用协助图来描述协作模型</p>
<p>注意：以上模型并不是每个都必须有的，根据实际需要选择即可</p>
<p><strong>建模实践</strong><br>以上这些模型都可以从用例模型推导出来，活动模型、序列模型、协作模型基本上都是和用例模型一一对应的，或者对应用例中的某个分支。一般情况下不推荐一个模型中包含多个分支，因为这样会导致图比较复杂，而且主题不突出。</p>
<p>状态模型和其它模型相比要复杂一些，因为并不能从单个用例或者单个用例分支推导出某个对象的所有状态，而需要综合多个用例模型，从中提取出和某个对象状态相关的内容，再统一设计状态模型。</p>
<p>从用例模型推导出动态模型是一个“分解和分配”的过程，因为在用例模型中，系统是当做一个“黑盒”来看待的，而在动态模型中，系统不再是一个黑盒，而是分解成了一个一个的类。因此我们需要将原来笼统的划分给系统的功能和职责，进一步分解并分配给不同的类。通俗的讲，动态模型就是说：为了完成系统的XXX功能， 先需要类A做任务1，然后需要类B需要做任务2，再由类C做任务3。。。。。。依次分解下去，最终就能够实现将类串起来，相互配合，最后实现了系统的需求。</p>
<p>我们以POS机为例，假设我们基于买单这个用例的正常分支设计“序列模型”，则可以得到如下的“序列模型”：<br><img src="http://ww3.sinaimg.cn/large/666cc9e3gw1f4977ftgrwj20qh0zq41q.jpg" alt="">有了上面这个“序列图”，假设我们要开始写代码，则基本可以按照如下伪码的方式实现（实际的编码肯定不会这么简单，但方法是一样）：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;  </span><br><span class="line">  </span><br><span class="line">    Trade trade = <span class="literal">new</span> Trade();                  </span><br><span class="line">    <span class="built_in">Integer</span> tradeId =trade.makeNewTrade();  <span class="comment">//创建  </span></span><br><span class="line">    trade.addGoods();                       <span class="comment">//增加商品  </span></span><br><span class="line">    trade.cacuMoney();                      <span class="comment">//计算总额  </span></span><br><span class="line">    <span class="attr">...</span><span class="attr">...</span><span class="attr">...</span><span class="attr">...</span><span class="comment">//省略一大段代码  </span></span><br><span class="line">    Receipt receipt = <span class="literal">new</span> Receipt();          </span><br><span class="line">    receipt.print(trade);                   <span class="comment">//打印小票  </span></span><br><span class="line">    <span class="attr">...</span><span class="attr">...</span><span class="attr">...</span>..<span class="comment">//省略一大段代码  </span></span><br><span class="line">    trade.finish();                         <span class="comment">//结束  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;无意间发现这篇文章，文章讲解由浅入深，读完后感触很深&lt;br&gt;特全文转到自己的博客，方便以后自己随时查看&lt;br&gt;文章转载自爱技术的华仔的博客[&lt;a href=&quot;http://blog.csdn.net/yunhua_lee&quot;&gt;http://blog.csdn.net/yunhua_lee&lt;/a&gt;]&lt;br&gt;非常感谢&lt;a href=&quot;http://blog.csdn.net/yunhua_lee&quot;&gt;爱技术的华仔&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;第二十一章-SSD&quot;&gt;&lt;a href=&quot;#第二十一章-SSD&quot; class=&quot;headerlink&quot; title=&quot;第二十一章 SSD&quot;&gt;&lt;/a&gt;第二十一章 SSD&lt;/h1&gt;&lt;p&gt;用例图是用来描述系统的，而SSD（系统序列图）又是来描述用例的，oh my god，这不是在玩我们么？&lt;img src=&quot;http://static.blog.csdn.net/xheditor/xheditor_emot/default/crazy.gif&quot; alt=&quot;抓狂&quot;&gt;
    
    </summary>
    
      <category term="软件笔记" scheme="http://i90s.vip/categories/%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="转载" scheme="http://i90s.vip/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="面向对象" scheme="http://i90s.vip/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
